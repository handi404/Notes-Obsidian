在 Java 中，除了 **建造者模式（Builder Pattern）**，还有许多重要的 **设计模式（Design Patterns）**，它们分为 **创建型、结构型和行为型** 三大类。以下是 Java 中常见且重要的设计模式及其应用场景：

---

## **1. 创建型模式（Creational Patterns）**
**关注对象创建的方式，提供灵活的实例化机制。**

### **(1) 单例模式（Singleton Pattern）**
- **作用**：确保一个类只有一个实例，并提供全局访问点。  
- **Java 应用**：
  - `Runtime.getRuntime()`  
  - Spring 的 `@Bean`（默认单例）  
- **实现方式**：
  ```java
  public class Singleton {
      private static final Singleton INSTANCE = new Singleton();
      
      private Singleton() {}  // 私有构造
      
      public static Singleton getInstance() {
          return INSTANCE;
      }
  }
  ```

### **(2) 工厂方法模式（Factory Method Pattern）**
- **作用**：定义一个创建对象的接口，但让子类决定实例化哪个类。  
- **Java 应用**：
  - `java.util.Calendar.getInstance()`  
  - `java.sql.DriverManager.getConnection()`  
- **示例**：
  ```java
  public interface Car {
      void drive();
  }
  
  public class Tesla implements Car { ... }
  public class BMW implements Car { ... }
  
  public class CarFactory {
      public static Car createCar(String type) {
          if ("Tesla".equals(type)) return new Tesla();
          else if ("BMW".equals(type)) return new BMW();
          else throw new IllegalArgumentException("Unknown car type");
      }
  }
  ```

### **(3) 抽象工厂模式（Abstract Factory Pattern）**
- **作用**：提供一个接口，用于创建 **相关或依赖对象的家族**，而不需要指定具体类。  
- **Java 应用**：
  - `javax.xml.parsers.DocumentBuilderFactory`  
  - `java.sql.Connection`（不同数据库返回不同的 `Statement`）  
- **示例**：
  ```java
  public interface GUIFactory {
      Button createButton();
      Checkbox createCheckbox();
  }
  
  public class WindowsFactory implements GUIFactory { ... }
  public class MacOSFactory implements GUIFactory { ... }
  ```

---

## **2. 结构型模式（Structural Patterns）**
**关注类和对象的组合方式，形成更大的结构。**

### **(4) 适配器模式（Adapter Pattern）**
- **作用**：让不兼容的接口能够一起工作。  
- **Java 应用**：
  - `java.util.Arrays.asList()`（数组 → List 适配器）  
  - `InputStreamReader`（字节流 → 字符流适配器）  
- **示例**：
  ```java
  public class OldSystem {
      public void oldRequest() { ... }
  }
  
  public class Adapter implements NewSystem {
      private OldSystem oldSystem;
      
      public Adapter(OldSystem oldSystem) {
          this.oldSystem = oldSystem;
      }
      
      @Override
      public void newRequest() {
          oldSystem.oldRequest();  // 调用旧方法
      }
  }
  ```

### **(5) 装饰器模式（Decorator Pattern）**
- **作用**：动态地给对象添加额外职责，比继承更灵活。  
- **Java 应用**：
  - `java.io.BufferedInputStream`（增强 `InputStream`）  
  - `java.util.Collections.synchronizedList()`（线程安全装饰）  
- **示例**：
  ```java
  public interface Coffee {
      double getCost();
      String getDescription();
  }
  
  public class SimpleCoffee implements Coffee { ... }
  
  public class MilkDecorator implements Coffee {
      private Coffee coffee;
      
      public MilkDecorator(Coffee coffee) {
          this.coffee = coffee;
      }
      
      @Override
      public double getCost() {
          return coffee.getCost() + 0.5;  // 加牛奶
      }
  }
  ```

### **(6) 代理模式（Proxy Pattern）**
- **作用**：控制对对象的访问（如延迟加载、权限控制）。  
- **Java 应用**：
  - `java.lang.reflect.Proxy`（动态代理）  
  - Spring AOP（基于代理实现）  
- **示例**：
  ```java
  public interface Database {
      void query(String sql);
  }
  
  public class RealDatabase implements Database { ... }
  
  public class DatabaseProxy implements Database {
      private RealDatabase realDatabase;
      
      @Override
      public void query(String sql) {
          if (realDatabase == null) {
              realDatabase = new RealDatabase();  // 延迟加载
          }
          realDatabase.query(sql);
      }
  }
  ```

---

## **3. 行为型模式（Behavioral Patterns）**
**关注对象之间的通信和职责分配。**

### **(7) 观察者模式（Observer Pattern）**
- **作用**：定义对象间的一对多依赖，当一个对象状态改变时，所有依赖它的对象都会收到通知。  
- **Java 应用**：
  - `java.util.Observable` 和 `Observer`（已弃用，但概念仍在）  
  - Spring 的事件监听机制（`ApplicationEvent` + `@EventListener`）  
- **示例**：
  ```java
  public class NewsAgency {
      private List<Observer> observers = new ArrayList<>();
      
      public void addObserver(Observer observer) {
          observers.add(observer);
      }
      
      public void notifyObservers(String news) {
          for (Observer observer : observers) {
              observer.update(news);
          }
      }
  }
  ```

### **(8) 策略模式（Strategy Pattern）**
- **作用**：定义一系列算法，使它们可以互相替换。  
- **Java 应用**：
  - `java.util.Comparator`（不同的排序策略）  
  - Spring 的 `ResourceLoader`（不同资源加载策略）  
- **示例**：
  ```java
  public interface PaymentStrategy {
      void pay(int amount);
  }
  
  public class CreditCardPayment implements PaymentStrategy { ... }
  public class PayPalPayment implements PaymentStrategy { ... }
  
  public class ShoppingCart {
      private PaymentStrategy paymentStrategy;
      
      public void setPaymentStrategy(PaymentStrategy strategy) {
          this.paymentStrategy = strategy;
      }
      
      public void checkout(int amount) {
          paymentStrategy.pay(amount);
      }
  }
  ```

### **(9) 模板方法模式（Template Method Pattern）**
- **作用**：定义一个算法的骨架，允许子类重写某些步骤。  
- **Java 应用**：
  - `java.util.AbstractList`（`get()` 是抽象方法，`ArrayList` 实现）  
  - Spring 的 `JdbcTemplate`（固定流程，自定义 SQL）  
- **示例**：
  ```java
  public abstract class Game {
      abstract void initialize();
      abstract void start();
      abstract void end();
      
      public final void play() {  // 模板方法（不可重写）
          initialize();
          start();
          end();
      }
  }
  
  public class Chess extends Game { ... }
  ```

---

## **总结**
| **分类** | **模式** | **核心思想** | **Java 应用示例** |
|----------|----------|--------------|-------------------|
| **创建型** | 单例模式 | 全局唯一实例 | `Runtime.getRuntime()` |
|  | 工厂方法 | 子类决定实例化 | `Calendar.getInstance()` |
|  | 抽象工厂 | 创建对象家族 | `DocumentBuilderFactory` |
| **结构型** | 适配器 | 接口转换 | `InputStreamReader` |
|  | 装饰器 | 动态增强功能 | `BufferedInputStream` |
|  | 代理 | 控制访问 | Spring AOP |
| **行为型** | 观察者 | 事件通知 | Spring `@EventListener` |
|  | 策略 | 算法替换 | `Comparator` |
|  | 模板方法 | 固定流程，可变步骤 | `JdbcTemplate` |

这些模式在 **Java 核心库**（如集合框架、IO）、**主流框架**（Spring、Hibernate）和 **企业级开发** 中广泛使用，掌握它们能让你写出更 **灵活、可维护、可扩展** 的代码。