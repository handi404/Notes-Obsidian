在Java中，双冒号 `::` 是 **方法引用（Method Reference）** 的语法符号，它是 Java 8 引入的一种简化 Lambda 表达式的写法。当 Lambda 表达式仅仅是调用一个已存在的方法时，可以用方法引用替代，使代码更简洁、可读性更高。

---

### **方法引用的作用**
1. **简化代码**：将 Lambda 表达式中仅调用一个方法的代码替换为更简洁的形式。
2. **提高可读性**：直接引用方法名，明确调用目标。
3. **复用现有方法**：直接引用已有的静态方法、实例方法或构造方法。

---

### **方法引用的类型**
Java 支持以下 4 种方法引用：

| 类型            | 语法格式        | 示例                    |
| ------------- | ----------- | --------------------- |
| **静态方法引用**    | `类名::静态方法名` | `Math::max`           |
| **实例方法引用**    | `对象::实例方法名` | `System.out::println` |
| **任意对象的实例方法** | `类名::实例方法名` | `String::length`      |
| **构造方法引用**    | `类名::new`   | `ArrayList::new`      |

---

### **具体用法及示例**

#### 1. 静态方法引用(类名::静态方法名)
引用类的静态方法，参数需与目标方法一致。
```java
// Lambda表达式
Function<Integer, Double> lambda = a -> Math.sqrt(a);
// 方法引用
Function<Integer, Double> ref = Math::sqrt;

System.out.println(ref.apply(4)); // 输出 2.0
```

#### 2. 实例方法引用(对象::实例方法名)
引用某个对象的实例方法。
```java
List<String> list = Arrays.asList("A", "B", "C");
// Lambda表达式
list.forEach(s -> System.out.println(s));
// 方法引用
list.forEach(System.out::println);
```

#### 3. 任意对象的实例方法引用(类名::实例方法名)
通过类名引用实例方法，第一个参数是调用方法的对象。
```java
// Lambda表达式
BiFunction<String, String, Boolean> lambda = (s1, s2) -> s1.equals(s2);
// 方法引用
BiFunction<String, String, Boolean> ref = String::equals;

System.out.println(ref.apply("Java", "Java")); // 输出 true
```

#### 4. 构造方法引用(类名::new)
引用类的构造方法，用于创建对象。
```java
// Lambda表达式
Supplier<List<String>> lambda = () -> new ArrayList<>();
// 方法引用
Supplier<List<String>> ref = ArrayList::new;

List<String> list = ref.get();
```

---

### **使用场景**
方法引用通常与 **函数式接口（如 `Runnable`, `Function`, `Consumer` 等）** 结合使用，常见于：
4. **集合操作**：如 `Stream` 的 `map`, `filter`, `forEach` 等方法。
   ```java
   List<String> names = Arrays.asList("Alice", "Bob");
   names.stream().map(String::toUpperCase).forEach(System.out::println);
   ```
5. **线程任务**：直接引用方法作为线程执行体。
   ```java
   new Thread(MyClass::doTask).start();
   ```
6. **工厂模式**：通过构造方法引用创建对象。
   ```java
   Function<Integer, LocalDate> dateFactory = LocalDate::of;
   LocalDate date = dateFactory.apply(2023, 10, 1);
   ```

---

### **注意事项**
7. **目标必须是函数式接口**：方法引用必须赋值给一个函数式接口（如 `Function`, `Consumer`）。
8. **参数和返回值匹配**：被引用方法的参数和返回值需与函数式接口的抽象方法一致。
9. **方法重载** ：如果方法被重载，需确保参数类型与函数式接口匹配。

---

## this 和 super

**this 和 super** ：可以引用当前类或父类的方法：
```Java
// 引用当前类的方法
Function<String, String> func = this::process;

// 引用父类的方法
Consumer<String> consumer = super::handle;
```
---

### **使用场景及示例**

#### 1. 替代调用当前对象方法的 Lambda
当 Lambda 表达式仅调用当前对象的某个方法时，可以用 `this::方法` 替代。

**示例**：  
假设有一个 `Processor` 类，其中的 `process` 方法需要调用当前对象的 `validate` 方法：
```java
public class Processor {
    public void validate(String input) {
        System.out.println("Validating: " + input);
    }

    public void process(List<String> inputs) {
        // 使用 Lambda 表达式
        inputs.forEach(s -> this.validate(s));
        
        // 使用方法引用
        inputs.forEach(this::validate);
    }
}
```

#### 2. 在事件监听或回调中简化代码
例如，在 Swing 应用中为按钮绑定点击事件，直接引用当前类的处理方法：
```java
public class MyFrame extends JFrame {
    public MyFrame() {
        JButton button = new JButton("Click");
        // 使用 Lambda 表达式
        button.addActionListener(e -> this.handleClick());
        // 使用方法引用
        button.addActionListener(this::handleClick);
    }

    private void handleClick() {
        System.out.println("Button clicked!");
    }
}
```

#### 3. 结合函数式接口使用
当需要将当前对象的方法传递给需要函数式接口的地方时，`this::方法` 可以直接绑定。

**示例**：  
使用 `Supplier` 接口获取当前对象的状态：
```java
public class DataHolder {
    private String data = "Some data";

    public Supplier<String> getDataSupplier() {
        // 使用 Lambda 表达式
        return () -> this.getData();
        // 使用方法引用
        return this::getData;
    }

    private String getData() {
        return data;
    }
}
```

---

### **注意事项**
10. **静态上下文中不可用**：  
   `this` 在静态方法中不存在，因此在静态方法中使用 `this::方法` 会导致编译错误。

   ```java
   public class Demo {
       public static void staticMethod() {
           // 错误！静态方法中不能使用 this
           Runnable r = this::doSomething; 
       }
       
       private void doSomething() {}
   }
   ```

11. **匿名内部类中的 `this`**：  
   如果在匿名内部类中使用 `this::方法`，`this` 会指向匿名类本身，而非外部类。此时需要显式指定外部类的 `this`：
   ```java
   public class Outer {
       public void init() {
           new Thread(() -> {
               // 匿名内部类中的 this 指向 Runnable 实例
               // 错误：this::doTask 会尝试调用 Runnable 的 doTask 方法
           }).start();

           // 正确：显式使用 Outer 的 this
           new Thread(Outer.this::doTask).start();
       }

       private void doTask() {
           System.out.println("Processing...");
       }
   }
   ```

12. **避免过度使用**：  
   如果 Lambda 表达式逻辑复杂（如包含条件判断或修改状态），使用方法引用可能反而降低可读性。

---

### **与其他方法引用的对比**
| 方法引用类型          | 示例               | 适用场景                          |
|-----------------------|--------------------|-----------------------------------|
| **静态方法引用**       | `Math::max`        | 引用静态方法                      |
| **特定对象实例方法引用** | `System.out::println` | 引用某个已知对象的实例方法        |
| **当前对象实例方法引用** | `this::method`     | 引用当前对象的实例方法            |
| **类的任意实例方法引用** | `String::length`   | 引用某个类的实例方法（参数 1 为调用者） |
| **构造方法引用**       | `ArrayList::new`   | 引用构造方法                      |

---

### **总结**
- **`this::方法` 是什么**：一种引用当前对象实例方法的方法引用。
- **何时使用**：当 Lambda 表达式仅调用当前对象的某个方法时，用来替代冗余的 Lambda 写法。
- **典型场景**：事件监听、Stream API、函数式接口参数传递。
- **注意点**：静态上下文中不可用，匿名内部类中需注意 `this` 的作用域。

通过合理使用 `this::方法`，可以让代码更加简洁，同时明确方法调用的来源，提升代码的可维护性。