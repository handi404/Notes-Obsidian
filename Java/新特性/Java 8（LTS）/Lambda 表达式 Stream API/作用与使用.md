在 Java 中，**Lambda 表达式**是 Java 8 引入的核心特性之一，它允许以简洁的语法表示一个函数式接口（Functional Interface）的实例。Lambda 的核心目的是简化代码，尤其是对匿名内部类的替代，同时为函数式编程提供支持。

---

### **Lambda 的作用**
1. **简化代码**：替代冗长的匿名内部类，尤其是单方法接口（如 `Runnable`, `Comparator`）。
2. **支持函数式编程**：将函数作为参数传递，或作为返回值返回。
3. **提高可读性**：通过更直观的语法表达行为（如排序逻辑、事件处理）。
4. **与 Stream API 结合**：实现声明式的集合操作（如过滤、映射、归约）。

---

### **Lambda 的语法**
Lambda 表达式的基本语法如下：
```java
(参数列表) -> { 方法体 }
```
- **参数列表**：可以是空参数 `()`，单个参数（可省略括号），或多个参数。
- **箭头符号 `->`**：分隔参数和方法体。
- **方法体**：单行代码可省略 `{}` 和 `return`，多行代码需明确编写。

#### 示例对比（Lambda vs 匿名内部类）
```java
// 匿名内部类实现 Runnable
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
};

// Lambda 表达式实现 Runnable
Runnable r2 = () -> System.out.println("Hello");
```

---

### **Lambda 的使用方式**
Lambda 需赋值给一个 **函数式接口**（即仅有一个抽象方法的接口）。Java 内置了多种函数式接口（位于 `java.util.function` 包），如 `Consumer`, `Function`, `Predicate` 等。

#### 1. **无参数 Lambda**
适用于无参数的函数式接口（如 `Runnable`）。
```java
Runnable task = () -> System.out.println("Task executed!");
new Thread(task).start();
```

#### 2. **单参数 Lambda**
参数类型可省略，编译器自动推断。
```java
// Consumer 接受一个参数，无返回值
Consumer<String> print = s -> System.out.println(s);
print.accept("Hello Lambda!");

// 更简洁的写法
Consumer<String> print = System.out::println; // 方法引用
```

#### 3. **多参数 Lambda**
需明确参数类型或括号。
```java
// Comparator 接口
Comparator<Integer> cmp = (a, b) -> a - b;
List<Integer> list = Arrays.asList(3, 1, 4);
list.sort(cmp); // 排序后为 [1, 3, 4]

// BiFunction 接受两个参数，返回一个值
BiFunction<Integer, Integer, Integer> add = (x, y) -> x + y;
System.out.println(add.apply(2, 3)); // 输出 5
```

#### 4. **Lambda 作为方法参数**
将 Lambda 传递给方法，实现行为参数化。
```java
// 自定义方法，接受一个 Predicate 接口
public static void filter(List<String> list, Predicate<String> predicate) {
    for (String s : list) {
        if (predicate.test(s)) {
            System.out.println(s);
        }
    }
}

// 使用 Lambda 调用
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
filter(names, s -> s.length() > 4); // 输出 "Alice", "Charlie"
```

#### 5. **Lambda 与方法引用结合**
当 Lambda 仅调用一个方法时，可用方法引用替代。
```java
// Lambda 写法
Function<String, Integer> lengthLambda = s -> s.length();
// 方法引用写法
Function<String, Integer> lengthRef = String::length;
```

#### 6. **Lambda 中的变量捕获**
Lambda 可以捕获外部的 **final 或等效 final** 变量。
```java
int threshold = 5;
List<String> names = Arrays.asList("Tom", "Jerry", "Spike");
names.stream()
     .filter(s -> s.length() > threshold) // 捕获外部变量 threshold
     .forEach(System.out::println);
```

---

### **Lambda 的高级用法**
#### 1. **与 Stream API 结合**
Lambda 是 Stream 操作的基础，用于实现集合的流水线处理。
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
// 过滤偶数 -> 平方 -> 求和
int sum = numbers.stream()
                 .filter(n -> n % 2 == 0)
                 .map(n -> n * n)
                 .reduce(0, (a, b) -> a + b);
System.out.println(sum); // 输出 20 (2² + 4² = 4 + 16)
```

#### 2. **自定义函数式接口**
定义自己的函数式接口，接受 Lambda。
```java
// 自定义接口
@FunctionalInterface
interface StringProcessor {
    String process(String input);
}

// 使用 Lambda 实现接口
StringProcessor toUpper = s -> s.toUpperCase();
System.out.println(toUpper.process("hello")); // 输出 "HELLO"
```

#### 3. **Lambda 嵌套与链式调用**
结合多个 Lambda 实现复杂逻辑。
```java
// 链式处理：过滤 -> 转换 -> 收集
List<String> result = names.stream()
                           .filter(s -> s.startsWith("A"))
                           .map(s -> "Name: " + s)
                           .collect(Collectors.toList());
```

#### 4. **Lambda 与 Optional**
用于简化空值处理。
```java
Optional<String> name = Optional.ofNullable(getName());
name.ifPresent(s -> System.out.println("Name is: " + s));
```

---

### **Lambda 的注意事项**
1. **变量捕获限制**：只能捕获 `final` 或等效 final 的局部变量。
   ```java
   int count = 0;
   Runnable task = () -> count++; // 编译错误！count 必须为 final
   ```

2. **`this` 的含义**：Lambda 中的 `this` 指向外层类的实例，而非 Lambda 自身。
   ```java
   public class Demo {
       public void run() {
           Runnable r = () -> System.out.println(this.getClass()); // 输出 Demo
       }
   }
   ```

3. **性能考虑**：Lambda 在首次调用时会有初始化开销，但后续调用与普通方法无异。

4. **避免过度使用**：复杂逻辑建议封装为方法，再用方法引用调用。

---

### **Lambda vs 匿名内部类**
| 特性                | Lambda 表达式                     | 匿名内部类                     |
|---------------------|-----------------------------------|--------------------------------|
| **语法简洁性**       | 简洁，无冗余代码                  | 需要完整类定义                 |
| **作用域**           | 共享外层类的 `this`               | 有自己的 `this`                |
| **编译结果**         | 生成动态的 `invokedynamic` 指令   | 生成单独的 `.class` 文件       |
| **性能**            | 通常更高效                        | 可能有额外开销                 |

---

### **总结**
Lambda 表达式是 Java 函数式编程的基石，通过以下方式提升代码质量：
- **简化代码**：替代匿名内部类，减少模板代码。
- **行为参数化**：将函数作为参数传递，增强灵活性。
- **与 Stream API 结合**：实现声明式集合操作。

**适用场景**：
- 单方法接口的实现（如 `Runnable`, `Comparator`）。
- Stream API 的中间操作（`filter`, `map`, `reduce`）。
- 事件监听、回调函数等需要传递行为的场景。

**避免场景**：
- 需要复杂逻辑或多行代码时（建议使用方法引用或封装为独立方法）。
- 需要访问非 final 外部变量时。