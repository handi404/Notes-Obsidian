对中间操作和终端操作的所有方法进行分类，然后系统性逐一讲解。注：是所有方法，无论基础还是高级。

我们将 Stream API 的所有操作方法分为两大类：**中间操作**和**终端操作**，并对每一类中的所有方法进行系统性的逐一讲解。

---

### **核心回顾：操作分类**

*   **中间操作 (Intermediate Operations)**：这类操作是**惰性的 (Lazy)**。它们返回一个新的 Stream，允许你将多个操作链接成一个流水线。它们本身不会触发任何计算，只是构建了处理步骤的蓝图。
    *   **比喻**：在自动化流水线上增加一个新的加工站（如筛选、喷漆、贴标）。
*   **终端操作 (Terminal Operations)**：这类操作是**饥渴的 (Eager)**。它们会触发整个 Stream 流水线的执行，并产生一个最终结果（如一个集合、一个值）或一个副作用（如打印）。一个 Stream 只能被一个终端操作消费，之后该 Stream 就关闭了。
    *   **比喻**：流水线末端的打包或质检环节，它让整条流水线开动起来，并产出最终产品。

---

## 第一部分：中间操作 (Intermediate Operations)

我们将中间操作按功能分为五类：筛选与切片、映射与转换、排序、消费与调试、状态管理。

### 1. 筛选与切片 (Filtering & Slicing)

这类操作用于从流中选取一部分元素。

#### `filter(Predicate<T> predicate)`
*   **核心作用**：过滤流中的元素，只保留那些满足 `predicate` 条件（返回 `true`）的元素。
*   **流水线比喻**：一个质检站，不合格的产品被剔除。
*   **代码示例**：
    ```java
    List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6);
    List<Integer> evenNumbers = numbers.stream()
            .filter(n -> n % 2 == 0) // 保留偶数
            .toList(); // [2, 4, 6]
    ```

#### `distinct()`
*   **核心作用**：去除流中的重复元素。它依赖元素的 `equals()` 和 `hashCode()` 方法。
*   **流水线比喻**：一个去重设备，确保每个产品都是独一无二的。
*   **代码示例**：
    ```java
    List<String> names = List.of("Alice", "Bob", "Alice", "Charlie");
    List<String> distinctNames = names.stream()
            .distinct()
            .toList(); // ["Alice", "Bob", "Charlie"]
    ```

#### `limit(long maxSize)`
*   **核心作用**：截断流，使其元素数量不超过 `maxSize`。这是一个**短路操作**。
*   **流水线比喻**：一个计数器，只允许前 `maxSize` 个产品通过。
*   **代码示例**：
    ```java
    Stream.iterate(1, n -> n + 1) // 1, 2, 3, 4, ... 无限流
            .limit(5) // 只取前5个
            .forEach(System.out::println); // 输出 1, 2, 3, 4, 5
    ```

#### `skip(long n)`
*   **核心作用**：跳过流中的前 `n` 个元素。
*   **流水线比喻**：一个延迟启动的传送带，忽略掉最开始的 `n` 个产品。
*   **代码示例**：常用于分页查询。
    ```java
    List<String> ranks = List.of("Gold", "Silver", "Bronze", "Wood");
    List<String> nonPodiumRanks = ranks.stream()
            .skip(3) // 跳过前三名
            .toList(); // ["Wood"]
    ```

### 2. 映射与转换 (Mapping & Transformation)

这类操作用于将流中的元素转换成另一种形式或类型。

#### `map(Function<T, R> mapper)`
*   **核心作用**：将流中的每个元素 `T` 通过 `mapper` 函数转换为一个新的元素 `R`（一对一映射）。
*   **流水线比喻**：一个加工站，将每个产品（如苹果）加工成另一种产品（如苹果汁）。
*   **代码示例**：
    ```java
    List<String> names = List.of("alice", "bob", "charlie");
    List<String> upperCaseNames = names.stream()
            .map(String::toUpperCase) // "alice" -> "ALICE"
            .toList(); // ["ALICE", "BOB", "CHARLIE"]
    ```

#### `flatMap(Function<T, Stream<R>> mapper)`
*   **核心作用**：将流中的每个元素 `T` 转换为一个 `Stream<R>`，然后将所有这些子流连接成一个单一的、扁平化的 `Stream<R>`（一对多映射）。
*   **流水线比喻**：一个拆包站。每个进来的箱子（元素）里装着多个零件（子流），这个站把所有箱子拆开，把所有零件放到同一条传送带上。
*   **代码示例**：
    ```java
    List<String> sentences = List.of("hello world", "java stream");
    // 目标：获取所有单词
    List<String> words = sentences.stream()
            // .map(s -> s.split(" ")) // 这会得到 Stream<String[]>，不是我们想要的
            .flatMap(s -> Arrays.stream(s.split(" "))) // "hello world" -> Stream["hello", "world"]
            .toList(); // ["hello", "world", "java", "stream"]
    ```

#### `mapToInt`, `mapToLong`, `mapToDouble`
*   **核心作用**：`map` 的特化版本，将对象流（如 `Stream<Integer>`）转换为对应的原始类型流（`IntStream`, `LongStream`, `DoubleStream`）。
*   **为什么需要？** 性能优化。避免了对象和原始类型之间的自动装箱/拆箱（boxing/unboxing），在处理大量数据时能显著提升性能。
*   **代码示例**：
    ```java
    List<User> users = ...; // User有 getAge() 方法
    int totalAge = users.stream()
            .mapToInt(User::getAge) // 得到 IntStream，更高效
            .sum(); // IntStream 有方便的 sum() 方法
    ```
*   **`flatMapToInt` 等**：同样存在 `flatMap` 的原始类型特化版本。

### 3. 排序 (Sorting)

#### `sorted()`
*   **核心作用**：对流中的元素进行自然排序。元素类必须实现 `Comparable` 接口。
*   **流水线比喻**：一个自动排序机，按产品默认的大小或重量排序。
*   **代码示例**：
    ```java
    List<String> names = List.of("Charlie", "Alice", "Bob");
    List<String> sortedNames = names.stream()
            .sorted()
            .toList(); // ["Alice", "Bob", "Charlie"]
    ```

#### `sorted(Comparator<T> comparator)`
*   **核心作用**：根据提供的 `Comparator` 进行自定义排序。
*   **流水线比喻**：一个可编程的排序机，可以按颜色、形状等任何你定义的规则排序。
*   **代码示例**：按字符串长度排序。
    ```java
    List<String> names = List.of("Charlie", "Alice", "Bob");
    List<String> sortedByLength = names.stream()
            .sorted(Comparator.comparingInt(String::length))
            .toList(); // ["Bob", "Alice", "Charlie"]
    ```

### 4. 消费与调试 (Consuming & Debugging)

#### `peek(Consumer<T> action)`
*   **核心作用**：对流中的每个元素执行 `action` 操作，主要用于调试，查看流在某个中间环节的状态。它返回的还是原来的流。
*   **流水线比喻**：在流水线上安装一个摄像头，观察每个经过的产品，但不改变它。
*   **警告**：不要在 `peek` 中执行有副作用的业务逻辑，这会破坏流的纯函数特性。
*   **代码示例**：
    ```java
    List<String> result = Stream.of("one", "two", "three", "four")
        .filter(e -> e.length() > 3)
        .peek(e -> System.out.println("Filtered value: " + e)) // 打印过滤后的值
        .map(String::toUpperCase)
        .peek(e -> System.out.println("Mapped value: " + e)) // 打印映射后的值
        .toList();
    ```

### 5. 状态管理与新特性 (Stateful & Modern Features)

这些是 Java 9+ 引入的更高级的操作。

#### `takeWhile(Predicate<T> predicate)` (Java 9+)
*   **核心作用**：对于一个**有序流**，从头开始获取元素，直到遇到第一个不满足 `predicate` 的元素为止，然后立即停止。
*   **流水线比喻**：一个质检员，从队首开始检查，一旦发现一个不合格的，就把后面所有产品（无论好坏）都退回。
*   **与 `filter` 的区别**：`filter` 会检查所有元素；`takeWhile` 是短路的，遇到不满足条件的就停止。
*   **代码示例**：
    ```java
    Stream.of(2, 4, 6, 8, 9, 10, 12)
        .takeWhile(n -> n % 2 == 0) // 取走所有偶数，直到遇到9
        .forEach(System.out::println); // 输出: 2, 4, 6, 8
    ```

#### `dropWhile(Predicate<T> predicate)` (Java 9+)
*   **核心作用**：对于一个**有序流**，从头开始丢弃元素，直到遇到第一个不满足 `predicate` 的元素为止，然后保留那个元素及之后的所有元素。
*   **流水线比喻**：一个质检员，把队首连续合格的产品都扔掉，从第一个不合格品开始，保留它和后面的所有产品。
*   **代码示例**：
    ```java
    Stream.of(2, 4, 6, 8, 9, 10, 12)
        .dropWhile(n -> n % 2 == 0) // 丢弃所有偶数，直到遇到9
        .forEach(System.out::println); // 输出: 9, 10, 12
    ```

#### `mapMulti(BiConsumer<T, Consumer<R>> mapper)` (Java 12+)
*   **核心作用**：一个更灵活、命令式的 `flatMap` 替代方案。对于流中的每个输入元素 `T`，你可以通过 `mapper` 函数编程决定是输出零个、一个还是多个 `R` 类型的元素。
*   **与 `flatMap` 的区别**：
    *   `flatMap` 必须返回一个 `Stream` 对象，即使是空的。`mapMulti` 不需要，性能上可能更好，因为它避免了创建大量小的、临时的 Stream 对象。
    *   `mapMulti` 的写法更接近命令式，在某些复杂逻辑下可能更易读。
*   **代码示例**：
    ```java
    class Author { List<String> books; /* ... */ }
    List<Author> authors = ...;
    
    // 使用 flatMap
    // authors.stream().flatMap(author -> author.getBooks().stream());
    
    // 使用 mapMulti，可能更高效
    List<String> allBooks = authors.stream()
        .<String>mapMulti((author, consumer) -> {
            for (String book : author.getBooks()) {
                consumer.accept(book); // 手动将每个book放入下游
            }
        })
        .toList();
    ```

---

## 第二部分：终端操作 (Terminal Operations)

我们将终端操作按功能分为五类：遍历、匹配、查找、聚合、收集。

### 1. 遍历 (Iteration)

#### `forEach(Consumer<T> action)`
*   **核心作用**：对流中的每个元素执行 `action` 操作。
*   **注意事项**：在并行流中，不保证处理顺序。
*   **代码示例**：
    ```java
    List.of("A", "B", "C").stream().forEach(System.out::println);
    ```

#### `forEachOrdered(Consumer<T> action)`
*   **核心作用**：对流中的每个元素按其在流中的顺序执行 `action` 操作。
*   **注意事项**：即使在并行流中，它也会强制按顺序执行，这可能会牺牲并行带来的性能优势。

### 2. 匹配 (Matching) - 短路操作

#### `anyMatch(Predicate<T> predicate)`
*   **核心作用**：检查流中是否**至少有一个**元素满足 `predicate` 条件。
*   **代码示例**：
    ```java
    boolean hasEvenNumber = List.of(1, 3, 5, 6).stream().anyMatch(n -> n % 2 == 0); // true
    ```

#### `allMatch(Predicate<T> predicate)`
*   **核心作用**：检查流中是否**所有**元素都满足 `predicate` 条件。
*   **代码示例**：
    ```java
    boolean allEvenNumbers = List.of(2, 4, 6).stream().allMatch(n -> n % 2 == 0); // true
    ```

#### `noneMatch(Predicate<T> predicate)`
*   **核心作用**：检查流中是否**没有一个**元素满足 `predicate` 条件。
*   **代码示例**：
    ```java
    boolean noNegativeNumbers = List.of(1, 2, 3).stream().noneMatch(n -> n < 0); // true
    ```

### 3. 查找 (Finding) - 短路操作

#### `findFirst()`
*   **核心作用**：返回流中的第一个元素。返回一个 `Optional<T>`，因为流可能为空。
*   **代码示例**：
    ```java
    Optional<String> first = List.of("A", "B", "C").stream().findFirst(); // Optional["A"]
    ```

#### `findAny()`
*   **核心作用**：返回流中的任意一个元素。返回一个 `Optional<T>`。
*   **注意事项**：在串行流中，它通常返回第一个元素。但在并行流中，它会返回最先处理完的那个元素，性能可能比 `findFirst()` 更好。

### 4. 聚合 (Reduction)

这类操作将整个流归约成一个单一的值。

#### `count()`
*   **核心作用**：返回流中元素的总个数。
*   **代码示例**：
    ```java
    long count = List.of(1, 2, 3).stream().count(); // 3
    ```

#### `max(Comparator<T> comparator)`, `min(Comparator<T> comparator)`
*   **核心作用**：根据提供的 `Comparator` 返回流中的最大或最小元素。返回 `Optional<T>`。
*   **代码示例**：
    ```java
    Optional<User> oldestUser = users.stream().max(Comparator.comparingInt(User::getAge));
    ```

#### `reduce(...)`
*   **核心作用**：一个通用的聚合操作，可以将流中元素反复结合起来，得到一个值。它有三个重载版本：
    1.  **`reduce(BinaryOperator<T> accumulator)`**:
        *   接收一个累加器函数，返回 `Optional<T>`。
        *   `Optional<Integer> sum = Stream.of(1, 2, 3).reduce((a, b) -> a + b);` // Optional[6]
    2.  **`reduce(T identity, BinaryOperator<T> accumulator)`**:
        *   提供一个初始值 `identity`，所以返回值是 `T` 而不是 `Optional<T>`。
        *   `int sum = Stream.of(1, 2, 3).reduce(0, (a, b) -> a + b);` // 6
    3.  **`reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)`**:
        *   最复杂的版本，主要用于并行流。`accumulator` 用于在各线程内累加，`combiner` 用于合并各线程的结果。

#### `toArray()`
*   **核心作用**：将流中的元素收集到一个数组中。
    1.  `Object[] toArray()`：返回一个 `Object[]`。
    2.  `<A> A[] toArray(IntFunction<A[]> generator)`：**推荐使用这个！** 它可以返回指定类型的数组。
        *   `String[] array = Stream.of("a", "b").toArray(String[]::new);`

### 5. 收集 (Collection) - 最强大的终端操作

#### `collect(Collector<T, A, R> collector)`
*   **核心作用**：一个极其灵活的终端操作，可以将流中的元素转换成各种数据结构，如 `List`, `Set`, `Map`，或者进行复杂的聚合计算。通常与 `java.util.stream.Collectors` 工具类配合使用。

#### **`Collectors` 常用方法详解：**

*   **收集到集合**
    *   `toList()` (Java 16+): **推荐！** 返回一个**不可变**的 `List`。
    *   `toUnmodifiableList()` (Java 10+): 同上。
    *   `toSet()`, `toUnmodifiableSet()`: 返回（不可变）`Set`。
    *   `toCollection(Supplier<C> collectionFactory)`: 收集到指定的集合类型，如 `new ArrayList<>()`。

*   **收集到映射 (Map)**
    *   `toMap(keyMapper, valueMapper)`: 将元素转为 Map。如果 key 重复会抛异常。
    *   `toMap(keyMapper, valueMapper, mergeFunction)`: **常用！** 当 key 重复时，使用 `mergeFunction` 解决冲突。
        ```java
        // (oldValue, newValue) -> newValue 表示保留新值
        Map<String, User> userMap = users.stream()
                .collect(Collectors.toMap(User::getId, u -> u, (old, aNew) -> aNew));
        ```

*   **字符串连接**
    *   `joining()`: 连接成一个字符串。
    *   `joining(delimiter)`: 使用分隔符连接。
    *   `joining(delimiter, prefix, suffix)`: 带分隔符、前缀和后缀。
        ```java
        String names = List.of("A", "B", "C").stream().collect(Collectors.joining(", ", "[", "]")); // "[A, B, C]"
        ```

*   **聚合计算**
    *   `counting()`: 等同于 `stream.count()`。
    *   `summingInt()`, `summingLong()`, `summingDouble()`: 求和。
    *   `averagingInt()`, `averagingLong()`, `averagingDouble()`: 求平均值。
    *   `summarizingInt()`, etc.: 返回一个统计对象（`IntSummaryStatistics`），包含 count, sum, min, max, average。

*   **分组与分区 (最强大)**
    *   `groupingBy(classifier)`: 按 `classifier` 函数的结果进行分组，返回 `Map<K, List<T>>`。
        ```java
        // 按城市对用户进行分组
        Map<String, List<User>> usersByCity = users.stream()
                .collect(Collectors.groupingBy(User::getCity));
        ```
    *   `groupingBy(classifier, downstream)`: **高级用法**。在分组后，对每个组内的元素再进行一次收集操作（下游收集器）。
        ```java
        // 按城市分组，并计算每个城市的用户数
        Map<String, Long> countByCity = users.stream()
                .collect(Collectors.groupingBy(User::getCity, Collectors.counting()));
        ```
    *   `partitioningBy(predicate)`: 特殊的分组，key 永远是 `Boolean`。将流分为两组：满足条件的和不满足条件的。
        ```java
        Map<Boolean, List<User>> seniorAndJunior = users.stream()
                .collect(Collectors.partitioningBy(u -> u.getAge() > 40));
        ```

*   **其他高级收集器**
    *   `reducing(...)`: `reduce` 操作的 `Collector` 版本。
    *   `mapping(...)`, `filtering(...)` (Java 9+), `flatMapping(...)` (Java 9+): 允许在 `collect` 内部进行 map/filter/flatMap 操作，常与 `groupingBy` 结合使用。


这份列表涵盖了从 Java 8 到最新版本中 Stream API 的所有核心操作方法。掌握它们，你就能以一种高效、声明式的方式自如地处理任何数据集合。