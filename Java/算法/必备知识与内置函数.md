# Java 算法题必备知识与内置函数总结

掌握 Java 解决算法题需要系统学习基础知识和常用工具类。下面我为你整理了一份全面的指南：

## 一、输入输出处理

### 1. 标准输入输出
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 读取整数
        int n = sc.nextInt();
        
        // 读取字符串
        String s = sc.next();     // 读取单词（空格分隔）
        String line = sc.nextLine(); // 读取整行
        
        // 读取浮点数
        double d = sc.nextDouble();
        
        // 输出
        System.out.println("结果: " + n);
        
        sc.close();
    }
}
```

### 2. 高效输入输出（大数据量）
```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        // 读取整数
        int n = Integer.parseInt(br.readLine());
        
        // 读取一行多个整数
        String[] parts = br.readLine().split(" ");
        int a = Integer.parseInt(parts[0]);
        int b = Integer.parseInt(parts[1]);
        
        // 高效输出
        bw.write("结果: " + (a + b));
        bw.newLine();
        
        bw.flush();
        br.close();
        bw.close();
    }
}
```

## 二、常用数据结构

### 1. 数组操作
```java
import java.util.Arrays;

public class ArrayExample {
    public static void main(String[] args) {
        // 创建数组
        int[] arr = new int[10];
        
        // 数组排序
        Arrays.sort(arr);
        
        // 数组填充
        Arrays.fill(arr, 0);
        
        // 数组复制
        int[] copy = Arrays.copyOf(arr, arr.length);
        
        // 二分查找（数组必须有序）
        int index = Arrays.binarySearch(arr, 42);
        
        // 数组转字符串
        System.out.println(Arrays.toString(arr));
    }
}
```

### 2. 集合框架
```java
import java.util.*;

public class CollectionExample {
    public static void main(String[] args) {
        // List
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        Collections.sort(list); // 排序
        Collections.reverse(list); // 反转
        
        // Stack
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        int top = stack.pop();
        
        // Queue
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);
        int head = queue.poll();
        
        // Deque（双端队列）
        Deque<Integer> deque = new ArrayDeque<>();
        deque.offerFirst(1);
        deque.offerLast(2);
        
        // Set
        Set<Integer> set = new HashSet<>();
        set.add(1);
        boolean contains = set.contains(1);
        
        // Map
        Map<String, Integer> map = new HashMap<>();
        map.put("key", 1);
        int value = map.getOrDefault("key", 0);
    }
}
```

## 三、字符串处理

### 1. 基本操作
```java
public class StringExample {
    public static void main(String[] args) {
        String s = "Hello World";
        
        // 获取长度
        int len = s.length();
        
        // 获取字符
        char c = s.charAt(0);
        
        // 子字符串
        String sub = s.substring(0, 5); // "Hello"
        
        // 分割字符串
        String[] parts = s.split(" ");
        
        // 连接字符串
        String joined = String.join("-", parts);
        
        // 大小写转换
        String upper = s.toUpperCase();
        String lower = s.toLowerCase();
        
        // 去除空格
        String trimmed = "  text  ".trim();
        
        // 替换
        String replaced = s.replace('o', '0');
    }
}
```

### 2. StringBuilder 高效操作
```java
public class StringBuilderExample {
    public static void main(String[] args) {
        // 创建StringBuilder
        StringBuilder sb = new StringBuilder();
        
        // 追加内容
        sb.append("Hello");
        sb.append(" ");
        sb.append("World");
        
        // 插入内容
        sb.insert(5, ",");
        
        // 删除内容
        sb.delete(5, 6);
        
        // 反转字符串
        sb.reverse();
        
        // 转为字符串
        String result = sb.toString();
    }
}
```

## 四、数学计算

### 1. 基本数学函数
```java
public class MathExample {
    public static void main(String[] args) {
        // 绝对值
        int abs = Math.abs(-10);
        
        // 最大值/最小值
        int max = Math.max(10, 20);
        int min = Math.min(10, 20);
        
        // 幂运算
        double pow = Math.pow(2, 3); // 8.0
        
        // 平方根
        double sqrt = Math.sqrt(16); // 4.0
        
        // 四舍五入
        long round = Math.round(3.6); // 4
        
        // 向上/向下取整
        double ceil = Math.ceil(3.1); // 4.0
        double floor = Math.floor(3.9); // 3.0
        
        // 随机数
        double random = Math.random(); // [0.0, 1.0)
    }
}
```

### 2. 大数运算（BigInteger, BigDecimal）
```java
import java.math.BigInteger;
import java.math.BigDecimal;

public class BigNumberExample {
    public static void main(String[] args) {
        // 大整数
        BigInteger bigInt = new BigInteger("12345678901234567890");
        BigInteger sum = bigInt.add(new BigInteger("1"));
        BigInteger product = bigInt.multiply(new BigInteger("2"));
        
        // 高精度浮点数
        BigDecimal bigDec = new BigDecimal("123.456");
        BigDecimal divided = bigDec.divide(new BigDecimal("2"), 3, BigDecimal.ROUND_HALF_UP);
    }
}
```

## 五、常用算法模板

### 1. 二分查找
```java
public int binarySearch(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

### 2. 快速排序
```java
public void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivot = partition(arr, low, high);
        quickSort(arr, low, pivot - 1);
        quickSort(arr, pivot + 1, high);
    }
}

private int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, high);
    return i + 1;
}

private void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

### 3. DFS 深度优先搜索
```java
// 图遍历
public void dfs(List<List<Integer>> graph, int node, boolean[] visited) {
    visited[node] = true;
    System.out.print(node + " ");
    for (int neighbor : graph.get(node)) {
        if (!visited[neighbor]) {
            dfs(graph, neighbor, visited);
        }
    }
}

// 回溯法模板
public void backtrack(List<List<Integer>> result, List<Integer> temp, int[] nums, int start) {
    result.add(new ArrayList<>(temp));
    for (int i = start; i < nums.length; i++) {
        temp.add(nums[i]);
        backtrack(result, temp, nums, i + 1);
        temp.remove(temp.size() - 1);
    }
}
```

### 4. BFS 广度优先搜索
```java
public void bfs(List<List<Integer>> graph, int start) {
    Queue<Integer> queue = new LinkedList<>();
    boolean[] visited = new boolean[graph.size()];
    
    queue.offer(start);
    visited[start] = true;
    
    while (!queue.isEmpty()) {
        int node = queue.poll();
        System.out.print(node + " ");
        
        for (int neighbor : graph.get(node)) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.offer(neighbor);
            }
        }
    }
}
```

## 六、实用技巧

1. **位运算**：
   ```java
   int a = 5; // 0101
   int b = 3; // 0011
   int and = a & b; // 0001 -> 1
   int or = a | b;  // 0111 -> 7
   int xor = a ^ b; // 0110 -> 6
   int not = ~a;    // 取反
   int leftShift = a << 1; // 1010 -> 10
   int rightShift = a >> 1; // 0010 -> 2
   ```

2. **类型转换**：
   ```java
   // 字符串转数字
   int num = Integer.parseInt("123");
   double d = Double.parseDouble("3.14");
   
   // 数字转字符串
   String s1 = String.valueOf(123);
   String s2 = Integer.toString(456);
   
   // 字符转数字
   int digit = Character.getNumericValue('5');
   ```

3. **时间空间复杂度**：
   - 常用数据结构操作复杂度：
     - 数组：访问 O(1)，搜索 O(n)，插入/删除 O(n)
     - 链表：访问 O(n)，搜索 O(n)，插入/删除 O(1)
     - 哈希表：平均访问/插入/删除 O(1)
     - 二叉搜索树：平均 O(log n)，最坏 O(n)
     - 堆：插入/删除 O(log n)，获取极值 O(1)