从熟练使用框架到亲手实现算法，确实存在一个思维模式的转变。框架开发者习惯于“调用”，而算法解题者则需要“创造”。但这道坎并不难跨越，本质上就是熟悉你的“兵器库”。

Java 的强大之处在于其稳定、高效且功能丰富的标准库（尤其是集合框架 `Collections Framework`），它就是你在 LeetCode 战场上的“瑞士军刀”。

下面，我为你总结出 Java 算法解题所需的核心知识和函数，分为**四大板块**：**核心数据结构**、**常用工具类**、**Java 8+ 新特性** 和 **必须了解的细节**。

---

### 一、核心数据结构 (The Absolute Essentials)

这是你的武器库核心，80% 的题目都围绕它们展开。**请务必熟练掌握它们的特性和常用方法**。

| 数据结构 (接口) | 常用实现类 | 核心特点 & 应用场景 | 必会操作 (代码示例) |
| :--- | :--- | :--- | :--- |
| **列表 (List)** | `ArrayList` | **动态数组**。查询快 (O(1))，增删慢 (O(n))。是**最常用**的动态集合。 | `List<Integer> list = new ArrayList<>();`<br>`list.add(val);`<br>`list.get(index);`<br>`list.set(index, val);`<br>`list.size();` |
| | `LinkedList` | **双向链表**。头尾增删极快 (O(1))，查询慢 (O(n))。适合实现**栈和队列**。 | 与 `ArrayList` 类似，但头尾操作有专用方法：<br>`addFirst()`, `addLast()`, `removeFirst()`, `removeLast()` |
| **栈 (Stack)** &<br>**队列 (Queue)** | `ArrayDeque` | `ArrayDeque` 是**官方推荐**的栈和队列实现（比老旧的 `Stack` 和 `LinkedList` 更快）。<br>**栈 (Stack)**: 后进先出(LIFO)。用于DFS、括号匹配、单调栈。<br>**队列 (Queue)**: 先进先出(FIFO)。用于BFS。 | `// 当作栈使用`<br>`Deque<Integer> stack = new ArrayDeque<>();`<br>`stack.push(val); // 入栈`<br>`stack.pop(); // 出栈`<br>`stack.peek(); // 查看栈顶`<br><br>`// 当作队列使用`<br>`Queue<Integer> queue = new ArrayDeque<>();`<br>`queue.offer(val); // 入队`<br>`queue.poll(); // 出队`<br>`queue.peek(); // 查看队头` |
| **哈希表 (Map)** | `HashMap` | **键值对存储**，无序。提供**平均 O(1)** 的增删查改。**神器！** 用于快速查找、计数、缓存（记忆化搜索）。 | `Map<K, V> map = new HashMap<>();`<br>`map.put(key, value);`<br>`map.get(key);`<br>`map.containsKey(key);`<br>`map.getOrDefault(key, defaultValue); // 极其实用！`<br>`map.keySet(); // 遍历所有键`<br>`map.values(); // 遍历所有值`<br>`for(Map.Entry<K, V> entry : map.entrySet()) { ... }` |
| **哈希集合 (Set)**| `HashSet` | **不重复元素的集合**，无序。提供**平均 O(1)** 的增删查。用于去重、判断元素是否存在。 | `Set<Integer> set = new HashSet<>();`<br>`set.add(val);`<br>`set.contains(val);`<br>`set.remove(val);` |
| **堆 (Heap)** | `PriorityQueue` | **优先队列**，其底层就是**堆**。默认是**小顶堆**。<br>用于求 Top K 问题、Dijkstra算法、合并K个有序链表。 | `// 小顶堆 (默认)`<br>`Queue<Integer> minHeap = new PriorityQueue<>();`<br>`minHeap.offer(val); // 添加元素`<br>`minHeap.poll(); // 弹出堆顶 (最小值)`<br>`minHeap.peek(); // 查看堆顶`<br><br>`// 大顶堆 (通过Lambda表达式自定义比较器)`<br>`Queue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);` |
| **有序表 (Map)**&<br>**有序集 (Set)** | `TreeMap`<br>`TreeSet` | 基于**红黑树**，**有序**。增删查均为 **O(log N)**。<br>当需要保持元素有序，或进行范围查找时使用。 | `TreeMap` 和 `TreeSet` 的方法与 `HashMap/Set` 基本一致，但它们多了**有序相关**的操作：<br>`map.firstKey()`, `map.lastKey()`<br>`map.ceilingKey(key)`, `map.floorKey(key)` |
| **字符串** | `String` & `StringBuilder` | `String` 是**不可变**的，任何修改都会创建新对象。<br>`StringBuilder` 是**可变**的，用于频繁拼接、修改字符串。 | `String s = "abc";`<br>`s.length()`, `s.charAt(i)`, `s.substring(i, j)`<br>`s.toCharArray()`<br><br>`StringBuilder sb = new StringBuilder();`<br>`sb.append(char_or_str);`<br>`sb.reverse();`<br>`sb.toString();` |

---

### 二、常用工具类与函数 (The Time-Savers)

这些是 Java 标准库提供的实用工具，能让你少写很多模板代码。

1.  **`Arrays` 类**
    *   **排序**: `Arrays.sort(arr);` (对基本类型数组使用优化的快排，对对象数组使用 Timsort)。
    *   **填充**: `Arrays.fill(arr, val);` (给数组所有元素赋同一个值)。
    *   **二分查找**: `Arrays.binarySearch(sorted_arr, key);` (注意：必须在**已排序**的数组上使用)。
    *   **拷贝**: `Arrays.copyOf(original, newLength);`，`Arrays.copyOfRange(original, from, to);`。

2.  **`Collections` 类**
    *   **排序**: `Collections.sort(list);` (可传入自定义 `Comparator`)。
    *   **反转**: `Collections.reverse(list);`。
    *   **查找极值**: `Collections.max(collection)`, `Collections.min(collection)`。

3.  **`Math` 类**
    *   `Math.max(a, b)`, `Math.min(a, b)`, `Math.abs(a)`。
    *   `Math.pow(base, exp)`, `Math.sqrt(a)`。
    *   `Math.ceil(a)` (向上取整), `Math.floor(a)` (向下取整)。

4.  **`Character` 类**
    *   `Character.isDigit(ch)`: 判断是否为数字。
    *   `Character.isLetter(ch)`: 判断是否为字母。
    *   `Character.isLetterOrDigit(ch)`: 判断是否为字母或数字。
    *   `Character.toLowerCase(ch)`, `Character.toUpperCase(ch)`。

---

### 三、 Java 8+ 新特性 (The Modern Touches)

掌握这些能让你的代码更简洁、更具表现力。

1.  **Lambda 表达式**
    *   **核心用途**：替代冗长的匿名内部类，尤其是在**定义比较器**和**遍历**时。
    *   **示例 (排序)**：
        ```java
        // 按二维数组的第一个元素升序排序
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        // 按自定义对象的 age 属性降序排序
        people.sort((p1, p2) -> p2.getAge() - p1.getAge());
        ```
    *   **示例 (大顶堆)**：已在 `PriorityQueue` 中展示。

2.  **Stream API**
    *   **核心思想**：提供一种声明式、链式的方式来处理集合数据。
    *   **常用操作**：`filter` (过滤), `map` (转换), `collect` (收集), `forEach` (遍历), `reduce` (规约)。
    *   **注意**：在追求极致性能的算法竞赛中，传统 `for` 循环通常比 Stream 更快。但在代码简洁性要求高的场景（或不那么卡性能的题目）中非常好用。
    *   **示例**：
        ```java
        // 将一个字符串列表过滤出长度大于3的，并转为大写，最后收集成新列表
        List<String> result = words.stream()
                                   .filter(s -> s.length() > 3)
                                   .map(String::toUpperCase)
                                   .collect(Collectors.toList());
        ```

---

### 四、必须了解的细节 (The Gotchas)

1.  **基本类型 vs. 包装类 (int vs. Integer)**
    *   **性能**: `int` 是基本类型，存储在栈上，速度快。`Integer` 是对象，存储在堆上，有额外开销。**在算法中，优先使用基本类型** (`int`, `long`, `double`, `char`)。
    *   **集合**: Java 的集合类（如 `ArrayList`, `HashMap`）只能存储对象，所以会自动发生**装箱/拆箱** (`int` <-> `Integer`)。
    *   **Null**: `Integer` 可以为 `null`，`int` 不行。在 `HashMap` 的 value 中，如果 `null` 有特殊含义，就必须用 `Integer`。

2.  **整数溢出**
    *   两个 `int` 相加可能超过 `Integer.MAX_VALUE`。在计算前，可以先将其中一个转为 `long`。
    *   **示例**: `long sum = (long)a + b;`

---

### 总结与学习路径建议

1.  **心态转变**：不要害怕“造轮子”。算法题的乐趣就在于用基础工具巧妙地搭建出解决方案。
2.  **第一步：掌握核心武器**
    *   **死磕 `HashMap` 和 `ArrayList`**。刷 LeetCode 前 50 道题，你会发现它们无处不在。务必做到像用筷子一样熟练。
    *   **理解 `ArrayDeque`** 作为栈和队列的统一用法。练习所有相关的题目（括号匹配、BFS 等）。
3.  **第二步：升级装备**
    *   **学习 `PriorityQueue`**。攻克所有 “Top K” 和 “堆” 相关的题目。
    *   **掌握 `String` 和 `StringBuilder`** 的区别和应用。
4.  **第三步：磨练技巧**
    *   在排序场景，**习惯使用 Lambda 表达式**。
    *   遇到需要计数的 `Map`，**多用 `map.getOrDefault()`**。
5.  **第四步：刻意练习**
    *   **分类刷题**。例如，今天就只做“哈希表”相关的题，明天只做“栈”相关的题。这样能快速加深对特定数据结构的理解和应用。

你的 Java 框架知识是你的优势，因为它意味着你已经有了很好的工程思维。现在，你只需要把这个思维应用到更细粒度的“零件”——也就是这些数据结构和算法上。