Java 泛型是 Java 5 引入的一项强大的语言特性，它允许在定义类、接口和方法时使用类型参数，从而使代码更加通用、灵活且安全。泛型使得代码可以操作不同类型的对象，而不必为了每种类型都创建单独的类或方法。

### 一、Java 泛型详解

#### 1. **泛型的基本概念**

泛型允许我们在定义类、接口和方法时使用一种占位符类型，而不是具体的类。这个占位符类型将在实际使用时被指定为某种具体类型。

- **泛型类**：使用泛型定义的类。例如：
  
  ```java
  public class Box<T> {
      private T item;
  
      public void setItem(T item) {
          this.item = item;
      }
  
      public T getItem() {
          return item;
      }
  }
  ```
  
  这里的 `T` 是一个类型参数，它将在实例化 `Box` 类时被具体的类型取代。

- **泛型方法**：可以在方法级别定义泛型。例如：
  
  ```java
  public <T> void printArray(T[] array) {
      for (T element : array) {
          System.out.println(element);
      }
  }
  ```
  
  这里的 `<T>` 声明了方法 `printArray` 是一个泛型方法，`T` 是该方法的类型参数。

#### 2. **泛型的类型擦除**

Java 泛型是通过类型擦除实现的，这意味着所有的泛型信息在编译后都会被擦除。类型参数在编译时被替换为它们的上界（默认为 `Object`），因此在运行时不会有泛型的类型信息。

例如，上面的 `Box<T>` 类在编译后，`T` 类型参数会被替换为 `Object`，即变为：

```java
public class Box {
    private Object item;

    public void setItem(Object item) {
        this.item = item;
    }

    public Object getItem() {
        return item;
    }
}
```

#### 3. **泛型的边界（Bounded Types）**

泛型可以定义类型参数的上下界，以限制类型参数的范围。

- **上界通配符**：`<? extends T>`，表示类型参数是 `T` 或 `T` 的子类。例如：
  
  ```java
  public static void process(List<? extends Number> list) {
      // 可以处理任何类型为 Number 或 Number 的子类的 List
  }
  ```

- **下界通配符**：`<? super T>`，表示类型参数是 `T` 或 `T` 的超类。例如：
  
  ```java
  public static void addNumbers(List<? super Integer> list) {
      list.add(new Integer(10));  // 可以添加 Integer 类型或 Integer 的子类
  }
  ```

- **泛型方法的边界**：
  
  ```java
  public static <T extends Comparable<T>> T max(T a, T b) {
      return a.compareTo(b) > 0 ? a : b;
  }
  ```
  
  这里的 `T extends Comparable<T>` 表示 `T` 必须实现 `Comparable` 接口。

### 二、泛型在集合框架中的应用

Java 集合框架中的接口和类广泛使用了泛型，使得集合能够安全地存储和操作特定类型的对象。

#### 1. **常用泛型集合类**

- **List`<E>`**：例如 `ArrayList<E>` 和 `LinkedList<E>`，`E` 代表列表中元素的类型。
  
  ```java
  List<String> stringList = new ArrayList<>();
  stringList.add("Hello");
  String str = stringList.get(0);  // 类型安全，无需强制转换
  ```

- **Set`<E>`**：例如 `HashSet<E>` 和 `TreeSet<E>`，`E` 代表集合中元素的类型。
  
  ```java
  Set<Integer> intSet = new HashSet<>();
  intSet.add(1);
  ```

- **Map<K, V>**：例如 `HashMap<K, V>` 和 `TreeMap<K, V>`，`K` 代表键的类型，`V` 代表值的类型。
  
  ```java
  Map<String, Integer> map = new HashMap<>();
  map.put("One", 1);
  Integer value = map.get("One");
  ```

- **Queue`<E>`**：例如 `PriorityQueue<E>` 和 `LinkedList<E>`，`E` 代表队列中元素的类型。
  
  ```java
  Queue<String> queue = new LinkedList<>();
  queue.add("First");
  ```

#### 2. **类型安全**

使用泛型使得集合在编译时就能检查类型的正确性，从而避免运行时的 `ClassCastException`。例如：

```java
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123); // 编译错误，防止了错误的数据类型插入
String str = list.get(0);  // 不需要强制类型转换
```

#### 3. **泛型的通配符**

集合框架中的泛型方法经常使用通配符来处理各种类型的集合。

- **`? extends T`**：可以读取但不能写入。适用于只读操作。
  
  ```java
  public static void processNumbers(List<? extends Number> list) {
      for (Number num : list) {
          System.out.println(num);
      }
  }
  ```

- **`? super T`**：可以写入但不能读取。适用于写入操作。
  
  ```java
  public static void addNumbers(List<? super Integer> list) {
      list.add(10);
  }
  ```

#### 4. **PECS 原则**

PECS 是 "Producer Extends, Consumer Super" 的缩写，用于记忆通配符的使用场景：

- 如果集合提供数据（生产者），使用 `extends`，如 `List<? extends T>`。
- 如果集合消耗数据（消费者），使用 `super`，如 `List<? super T>`。

### 三、泛型的局限性

尽管泛型为 Java 带来了许多好处，但也有一些局限性：

1. **泛型不能用于基本类型**：泛型只能用于对象类型，不能用于像 `int`、`char` 这样的基本数据类型。

2. **运行时类型信息丢失**：由于类型擦除，在运行时无法获取泛型的具体类型信息。

3. **不能创建泛型数组**：例如，`new T[10]` 是非法的，因为 JVM 无法确定数组的实际类型。

4. **泛型类的静态上下文**：静态方法和静态变量不能直接使用类的泛型参数，因为泛型是在实例化时才确定的。

### 四、总结

Java 泛型通过类型参数化使得代码更具通用性、可重用性和类型安全性，特别是在集合框架中得到了广泛的应用。掌握泛型的使用及其背后的原理，可以帮助你编写出更加健壮和灵活的代码。