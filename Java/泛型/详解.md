Java 泛型是 Java 语言的一项重要特性，它在 Java SE 5 引入，用于增强代码的类型安全性、可读性和复用性。以下是 Java 泛型的详细讲解：

---

## **1. 什么是泛型**

泛型（Generics）允许类、接口和方法能够操作指定类型的数据类型，而无需在定义时明确具体类型。泛型的核心思想是 **“参数化类型”**，即类型可以作为参数传递给类、接口或方法。

---

## **2. 泛型的作用**

- **类型安全**：在编译时检查类型，从而避免运行时的 `ClassCastException`。
- **代码复用**：使用泛型可以让代码更具通用性，而不需要为每种类型单独实现逻辑。
- **可读性和维护性**：代码更加清晰，减少了强制类型转换。

---

## **3. 泛型的语法**

### **泛型类**

```java
public class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

// 使用泛型类
Box<String> stringBox = new Box<>();
stringBox.setItem("Hello");
String str = stringBox.getItem();  // 类型安全
```

- **`<T>`** 是类型参数。
- 在使用时，`T` 会被具体类型替换，例如 `String`。

---

### **泛型方法**

```java
public class GenericMethod {
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
}

// 使用泛型方法
Integer[] numbers = {1, 2, 3};
GenericMethod.printArray(numbers);  // 自动推断为 Integer
```

- 在方法名前加上 `<T>` 声明这是一个泛型方法。
- 泛型方法可以定义在普通类或泛型类中。

---

### **泛型接口**

```java
public interface Repository<T> {
    void save(T item);
    T find(int id);
}

// 实现泛型接口
public class UserRepository implements Repository<User> {
    @Override
    public void save(User user) {
        // 保存逻辑
    }

    @Override
    public User find(int id) {
        return new User();  // 返回用户
    }
}
```

- **泛型接口**可以在实现类中指定具体类型。

---

### **泛型通配符**

通配符用于表示不确定的类型。

1. **无界通配符**：`<?>`
    
    ```java
    public void printList(List<?> list) {
        for (Object obj : list) {
            System.out.println(obj);
        }
    }
    ```
    
    - 表示可以接受任何类型的 `List`。
2. **有限制通配符**：
    
    - **上界通配符**：`<? extends T>`
        
        ```java
        public void printNumbers(List<? extends Number> list) {
            for (Number number : list) {
                System.out.println(number);
            }
        }
        ```
        
        - 限制类型为 `T` 或 `T` 的子类。
    - **下界通配符**：`<? super T>`
        
        ```java
        public void addNumbers(List<? super Integer> list) {
            list.add(10);  // 可以添加 Integer 或子类
        }
        ```
        
        - 限制类型为 `T` 或 `T` 的父类。

---

## **4. 类型擦除**

Java 泛型在编译后会进行 **类型擦除（Type Erasure）**，将泛型类型替换为其 **擦除类型**：

- 如果没有指定边界，泛型类型会被替换为 `Object`。
- 如果指定了边界，例如 `<T extends Number>`，则替换为 `Number`。

类型擦除的影响：

- 无法直接使用泛型类型创建实例：
    
    ```java
    T obj = new T();  // 编译错误
    ```
    
- 无法使用泛型类型的静态变量：
    
    ```java
    static T value;  // 编译错误
    ```
    

---

## **5. 限制和注意事项**

1. **泛型的静态上下文**：
    
    - 静态成员（如方法和变量）不能使用类的类型参数。
    
    ```java
    public class MyClass<T> {
        private static T obj;  // 错误
    }
    ```
    
2. **泛型数组**：
    
    - 不允许直接创建泛型数组。
    
    ```java
    List<String>[] lists = new List<String>[10];  // 错误
    ```
    
3. **原始类型（Raw Type）**：
    
    - 使用未指定类型参数的泛型称为原始类型，例如 `List`。
    - **不推荐**使用原始类型，因为会丧失类型检查的优势。

---

## **6. 示例：自定义泛型栈**

```java
public class GenericStack<T> {
    private List<T> elements = new ArrayList<>();

    public void push(T item) {
        elements.add(item);
    }

    public T pop() {
        if (elements.isEmpty()) {
            throw new EmptyStackException();
        }
        return elements.remove(elements.size() - 1);
    }
}
```

使用：

```java
GenericStack<Integer> stack = new GenericStack<>();
stack.push(10);
stack.push(20);
System.out.println(stack.pop());  // 输出 20
```

---

## **7. 泛型与反射**

在运行时可以通过反射获取泛型的实际类型。

```java
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public class GenericReflect<T> {
    public static void main(String[] args) {
        GenericReflect<String> obj = new GenericReflect<>();
        Type type = obj.getClass().getGenericSuperclass();
        if (type instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) type;
            System.out.println("泛型类型：" + pt.getActualTypeArguments()[0]);
        }
    }
}
```

---

### **总结**

Java 泛型是一种强大的工具，可以提高代码的安全性、复用性和可读性。熟练掌握泛型可以帮助你写出更优雅和灵活的代码，但也需要注意泛型的一些限制（如类型擦除）。