对于简单的单表查询，Spring Data JPA 允许你仅通过方法命名约定来自动生成 SQL，而无需手动实现。但当涉及到复杂的多表查询时（例如联表查询、聚合查询、动态查询等），方法命名约定通常就不够用了，此时可以采用以下几种方案来处理复杂的查询需求：

---

## 1. 使用 JPQL（Java Persistence Query Language）和 @Query 注解

JPQL 是面向对象的查询语言，允许你基于实体之间的关系进行查询。你可以在 Repository 接口的方法上使用 `@Query` 注解编写 JPQL 查询。例如，假设有两个实体 **User** 和 **Order**，且 User 与 Order 存在一对多关系（即一个 User 可以有多个 Order），你可以这样写：

### 示例

假设实体关系如下：

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @Temporal(TemporalType.DATE)
    private Date birthdate;

    // 假设一个用户有多个订单
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Order> orders;

    // getter/setter...
}

@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    // getter/setter...
}
```

在 Repository 接口中编写联表查询的方法：

```java
package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface UserRepository extends JpaRepository<User, Long> {

    // 使用 JPQL 查询所有拥有特定订单状态的用户
    @Query("SELECT u FROM User u JOIN u.orders o WHERE o.status = :status")
    List<User> findUsersByOrderStatus(@Param("status") String status);
}
```

这里：

- `JOIN u.orders o` 表示根据 **User** 实体中定义的 `orders` 关联进行联表查询。
- `:status` 是一个命名参数，表示订单的状态。

---

## 2. 使用原生 SQL 查询

如果 JPQL 无法满足你的需求（例如使用数据库特定的功能），可以直接编写原生 SQL 查询。注意需要设置 `nativeQuery = true`。

### 示例

```java
package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.List;

public interface UserRepository extends JpaRepository<User, Long> {

    // 使用原生 SQL 查询所有拥有特定订单状态的用户
    @Query(value = "SELECT u.* FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.status = ?1", nativeQuery = true)
    List<User> findUsersByOrderStatusNative(String status);
}
```

使用原生 SQL 查询时，你需要关注数据库表和列的命名，因为这直接依赖于底层数据库结构。

---

## 3. 使用 Criteria API 或 Querydsl 进行动态查询

对于需要根据动态条件构建查询（例如条件可能由前端传入，且组合较为复杂）的场景，可以使用 JPA 的 Criteria API 或集成 Querydsl。

### 3.1 Criteria API 示例

Criteria API 是 JPA 提供的一套类型安全的动态查询构造工具，虽然代码相对冗长，但非常灵活。例如：

```java
@Repository
public class UserRepositoryCustomImpl implements UserRepositoryCustom {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<User> findUsersWithDynamicCriteria(String status, Date orderAfterDate) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<User> query = cb.createQuery(User.class);
        Root<User> user = query.from(User.class);
        Join<User, Order> orders = user.join("orders", JoinType.INNER);

        // 构造条件：订单状态匹配且订单日期在指定日期之后（假设 Order 中有 orderDate 字段）
        Predicate statusPredicate = cb.equal(orders.get("status"), status);
        // 例如：Predicate datePredicate = cb.greaterThan(orders.get("orderDate"), orderAfterDate);

        // 组合条件（这里仅示例 statusPredicate）
        query.select(user).where(statusPredicate);

        return entityManager.createQuery(query).getResultList();
    }
}
```

需要注意的是：

- 为了使用自定义查询，你通常需要定义一个自定义的 Repository 接口（例如 `UserRepositoryCustom`）并在主 Repository 接口中继承它。
- Criteria API 的优势在于查询条件可以完全动态构造。

### 3.2 Querydsl

Querydsl 提供了类型安全的查询构造工具，能够生成用于构造查询的 Q 类型类，但需要额外添加依赖和代码生成配置。它在大型项目中非常受欢迎，能大幅减少错误。

---

## 4. 自定义 Repository 实现

当以上方式均不满足需求时，你也可以通过实现自定义的 Repository 方法来处理复杂的多表查询。步骤如下：

1. 定义一个自定义 Repository 接口，例如 `UserRepositoryCustom`：
    
    ```java
    public interface UserRepositoryCustom {
        List<User> findUsersWithComplexCriteria(String status, Date someDate);
    }
    ```
    
2. 修改主 Repository 接口继承这个接口：
    
    ```java
    public interface UserRepository extends JpaRepository<User, Long>, UserRepositoryCustom {
        // 其他方法...
    }
    ```
    
3. 编写该自定义接口的实现类：
    
    ```java
    @Repository
    public class UserRepositoryCustomImpl implements UserRepositoryCustom {
    
        @PersistenceContext
        private EntityManager entityManager;
    
        @Override
        public List<User> findUsersWithComplexCriteria(String status, Date someDate) {
            CriteriaBuilder cb = entityManager.getCriteriaBuilder();
            CriteriaQuery<User> query = cb.createQuery(User.class);
            Root<User> user = query.from(User.class);
            Join<User, Order> orders = user.join("orders", JoinType.INNER);
    
            // 构建复杂的条件组合
            Predicate statusPredicate = cb.equal(orders.get("status"), status);
            // Predicate datePredicate = cb.greaterThan(orders.get("orderDate"), someDate);
            // query.where(cb.and(statusPredicate, datePredicate));
            query.where(statusPredicate);
    
            return entityManager.createQuery(query).getResultList();
        }
    }
    ```
    

---

## 总结

- **JPQL + @Query 注解**：适合查询逻辑明确、条件固定的多表联查，利用实体关系进行联表操作。
- **原生 SQL 查询**：当需要使用数据库特定特性或者 JPQL 无法满足需求时，可直接编写 SQL。
- **Criteria API / Querydsl**：适用于需要动态构造查询条件的场景，能够在代码中以类型安全的方式构造复杂查询。
- **自定义 Repository 实现**：当以上方式无法满足需求时，完全可以自定义 Repository 实现，通过 EntityManager 灵活构造任意复杂查询。

通过以上这些方式，你可以应对大多数复杂的多表查询需求，并且在保证代码灵活性的同时还能保持较好的可维护性。