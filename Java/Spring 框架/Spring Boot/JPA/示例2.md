下面给出一个示例项目，使用 Spring Boot 集成 Hibernate 访问 MySQL 数据库，对应的实体类为 User，其属性为 **id**、**name**、**birthdate**，数据库表为 **users**，表中的列为 **ID**、**NAME**、**BIRTH_DATE**。示例中采用了典型的分层架构（Controller → Service → Repository → Entity）。

下面给出的示例基于 Maven 项目结构，你可以根据需要进行调整。

---

## 1. Maven 配置（pom.xml）

在 `pom.xml` 中添加 Spring Boot、Spring Data JPA、Spring Web 以及 MySQL 驱动依赖。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  
  <groupId>com.example</groupId>
  <artifactId>demo</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>
  
  <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-parent</artifactId>
      <version>2.7.6</version>
  </parent>
  
  <dependencies>
      <!-- Spring Boot Web Starter -->
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
      </dependency>
      
      <!-- Spring Boot Data JPA Starter（内部默认使用 Hibernate） -->
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-data-jpa</artifactId>
      </dependency>
      
      <!-- MySQL 数据库驱动 -->
      <dependency>
          <groupId>mysql</groupId>
          <artifactId>mysql-connector-java</artifactId>
          <scope>runtime</scope>
      </dependency>
      
      <!-- 测试相关 -->
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-test</artifactId>
          <scope>test</scope>
      </dependency>
  </dependencies>
  
  <build>
      <plugins>
          <plugin>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-maven-plugin</artifactId>
          </plugin>
      </plugins>
  </build>
</project>
```

---

## 2. 配置文件（application.properties）

在 `src/main/resources/application.properties` 中配置数据源、JPA 属性等。请将 `your_database`、`your_username`、`your_password` 替换为你的数据库名称和认证信息。

```properties
# 数据库连接配置
spring.datasource.url=jdbc:mysql://localhost:3306/your_database?useSSL=false&serverTimezone=UTC
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA 和 Hibernate 配置
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.show-sql=true
```

> **说明：**
> 
> - `spring.jpa.hibernate.ddl-auto=update` 会在启动时自动更新数据库表结构，开发环境下可用，生产环境建议关闭或使用其他方式管理数据结构。
> - `spring.jpa.show-sql=true` 用于在控制台输出生成的 SQL 语句，便于调试。

---

## 3. 实体类（User.java）

在 `com.example.demo.entity` 包下创建 `User.java` 文件，对应数据库表 **users**，注意使用 `@Table` 指定表名，以及使用 `@Column` 对应每个列名。

```java
package com.example.demo.entity;

import javax.persistence.*;
import java.util.Date;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Long id;

    @Column(name = "NAME", nullable = false)
    private String name;

    @Column(name = "BIRTH_DATE")
    @Temporal(TemporalType.DATE)
    private Date birthdate;

    // 默认构造函数
    public User() {
    }

    // 带参数构造函数
    public User(String name, Date birthdate) {
        this.name = name;
        this.birthdate = birthdate;
    }

    // getter 和 setter 方法
}
```

---

## 4. 数据访问层（Repository）

在 `com.example.demo.repository` 包下创建 `UserRepository.java`，继承 Spring Data JPA 提供的 `JpaRepository`，即可获得基本的 CRUD 操作方法。

```java
package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
    // 如有需要，可自定义其他查询方法
}
```

---

## 5. 业务逻辑层（Service）

### 5.1 定义接口

在 `com.example.demo.service` 包下定义接口 `UserService.java`，声明基本的 CRUD 操作。

```java
package com.example.demo.service;

import com.example.demo.entity.User;
import java.util.List;
import java.util.Optional;

public interface UserService {

    // 新增用户
    User createUser(User user);

    // 修改用户
    User updateUser(User user);

    // 根据ID删除用户
    void deleteUser(Long id);

    // 根据ID查询用户
    Optional<User> getUserById(Long id);

    // 查询所有用户
    List<User> getAllUsers();
}
```

### 5.2 实现接口

在 `com.example.demo.service.impl` 包下实现 `UserServiceImpl.java`。

```java
package com.example.demo.service.impl;

import com.example.demo.entity.User;
import com.example.demo.repository.UserRepository;
import com.example.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Optional;

@Service
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;

    @Autowired
    public UserServiceImpl(UserRepository userRepository){
        this.userRepository = userRepository;
    }
    
    @Override
    public User createUser(User user) {
        return userRepository.save(user);
    }
    
    @Override
    public User updateUser(User user) {
        // 此处建议先判断用户是否存在，再执行更新操作
        return userRepository.save(user);
    }
    
    @Override
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
    
    @Override
    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }
    
    @Override
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
```

---

## 6. 控制层（Controller）

在 `com.example.demo.controller` 包下创建 `UserController.java`，通过 REST 接口提供对外 CRUD 操作。

```java
package com.example.demo.controller;

import com.example.demo.entity.User;
import com.example.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;
    
    @Autowired
    public UserController(UserService userService){
        this.userService = userService;
    }
    
    // 新增用户
    @PostMapping
    public User createUser(@RequestBody User user){
        return userService.createUser(user);
    }
    
    // 修改用户
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody User user){
        // 确保将传入的id设置到user对象中
        user.setId(id);
        return userService.updateUser(user);
    }
    
    // 根据ID删除用户
    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable Long id){
        userService.deleteUser(id);
    }
    
    // 根据ID查询用户
    @GetMapping("/{id}")
    public Optional<User> getUserById(@PathVariable Long id){
        return userService.getUserById(id);
    }
    
    // 查询所有用户
    @GetMapping
    public List<User> getAllUsers(){
        return userService.getAllUsers();
    }
}
```

---

## 7. Spring Boot 启动类

在主包下创建启动类，例如 `DemoApplication.java`：

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
  public static void main(String[] args) {
      SpringApplication.run(DemoApplication.class, args);
  }
}
```

---

## 8. 总结

- **配置层**：在 `pom.xml` 和 `application.properties` 中完成 MySQL 数据源和 JPA（Hibernate）配置。
- **实体层**：使用 JPA 注解在 `User` 类中映射数据库表 `users`。
- **数据访问层（Repository）**：利用 Spring Data JPA 的 `JpaRepository` 直接获得 CRUD 方法。
- **业务逻辑层（Service）**：封装具体的业务操作，便于后期扩展及单元测试。
- **控制层（Controller）**：通过 RESTful 接口暴露 CRUD 服务。

这样一个典型的分层架构项目就构建完成了，你可以根据业务需要进一步扩展各层的功能。

## 问 ：是否使用了数据库连接池，若无则添加HikariCP连接池

Spring Boot 从 2.x 版本开始默认使用 **HikariCP** 作为连接池，所以如果你使用 `spring-boot-starter-data-jpa`（或 `spring-boot-starter-jdbc`）时，并且没有额外排除 HikariCP，那么实际上已经是在使用 HikariCP。

不过，如果你想显式地添加或调整 HikariCP 的配置，可以参考下面的做法：

---

### 1. Maven 依赖（可选）

一般情况下，`spring-boot-starter-data-jpa` 会自动引入 HikariCP 的依赖，你无需手动添加。但如果你想明确指定，可以在 `pom.xml` 中添加：

```xml
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>5.0.1</version>
</dependency>
```

> **注意**：请根据项目情况和 Spring Boot 的版本选择合适的 HikariCP 版本。

---

### 2. 在 application.properties 中配置 HikariCP

你可以在原有数据库配置的基础上，添加 HikariCP 相关的属性。例如：

```properties
# 数据库连接配置
spring.datasource.url=jdbc:mysql://localhost:3306/your_database?useSSL=false&serverTimezone=UTC
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 指定使用 HikariCP 连接池（可选，默认情况下 Spring Boot 已经会使用 HikariCP）
spring.datasource.type=com.zaxxer.hikari.HikariDataSource

# HikariCP 连接池相关配置
spring.datasource.hikari.pool-name=HikariCP
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=30000
spring.datasource.hikari.connection-timeout=30000

# JPA 和 Hibernate 配置
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.show-sql=true
```

通过以上配置，你就明确指定了数据源使用 HikariCP，并对其连接池的一些关键参数进行了设置。

---

### 3. 总结

- **默认情况下**：Spring Boot 已经内置使用 HikariCP 作为数据源连接池，你只需要确保没有排除相关依赖即可。
- **显式配置**：可以在 `application.properties` 中添加 `spring.datasource.type` 以及 HikariCP 的其他参数来定制化连接池的行为。

这样，你的 Spring Boot 项目就会使用 HikariCP 连接池来管理与 MySQL 数据库的连接。


