### ✨ Java 反射从 0 到 1 通俗易懂讲解（附示例）

---

#### **一、什么是反射？**
> **反射 = 照妖镜 + 动态操作**
- 在程序运行时，**可以动态查看类的结构**（方法、字段、构造器等），甚至**修改私有成员、创建对象、调用方法**。
- **核心思想**：  
  > 类还没写完，程序就知道它有哪些方法/属性 → 运行时动态分析类。

---

#### **二、反射的三大核心类**
都在 `java.lang.reflect` 包中：

| 类名 | 功能 |
|------|------|
| `Class` | 每个类都有一个唯一的 `Class` 对象，是反射的入口 |
| `Method` | 表示类的方法，可以调用方法 |
| `Field` | 表示类的字段，可以读写属性值 |
| `Constructor` | 表示构造方法，可以创建对象 |

---

#### **三、获取 Class 对象的 3 种方式**
```java
// 方式1：通过类名（推荐）
Class<?> clazz = String.class;

// 方式2：通过对象
String str = "hello";
Class<?> clazz = str.getClass();

// 方式3：通过类路径字符串（常用于配置文件）
Class<?> clazz = Class.forName("java.lang.String");
```

---

#### **四、反射的基本操作**

##### **1. 创建对象**
```java
// 默认构造函数
Object obj = clazz.newInstance(); 

// 带参数构造函数
Constructor<?> constructor = clazz.getConstructor(String.class);
Object obj = constructor.newInstance("abc");
```

##### **2. 调用方法**
```java
// 获取方法并调用
Method method = clazz.getMethod("methodName", 参数类型.class);
method.invoke(obj, 参数值); 

// 示例：调用 String.length()
Method lengthMethod = String.class.getMethod("length");
int len = (int) lengthMethod.invoke("hello"); // 输出5
```

##### **3. 访问字段**
```java
// 获取字段并设置/获取值
Field field = clazz.getDeclaredField("fieldName");
field.setAccessible(true); // 打破封装（重要！）
field.set(obj, value);     // 设置值
Object value = field.get(obj); // 获取值

// 示例：修改 String 的私有 value 字段
Field valueField = String.class.getDeclaredField("value");
valueField.setAccessible(true);
char[] chars = (char[]) valueField.get("hello");
chars[0] = 'H'; // 修改为 "Hello"
```

---

#### **五、高级玩法**

##### **1. 处理泛型**
```java
Method method = list.getClass().getMethod("add", Object.class);
Type genericType = method.getGenericParameterTypes()[0]; 
// 输出：E（泛型类型信息）
```

##### **2. 读取注解**
```java
// 判断类是否有注解
if (clazz.isAnnotationPresent(MyAnnotation.class)) {
    MyAnnotation anno = clazz.getAnnotation(MyAnnotation.class);
    System.out.println(anno.value()); 
}
```

##### **3. 动态代理（AOP 核心）**
```java
// 使用 Proxy 创建代理对象
MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
    clazz.getClassLoader(),
    new Class[]{MyInterface.class},
    (proxyObj, method, args) -> {
        // 拦截所有方法调用
        System.out.println("Before method call");
        return method.invoke(realObj, args);
    }
);
```

---

#### **六、反射的典型应用场景**

| 场景              | 举例                          |
| --------------- | --------------------------- |
| 🧱 **框架开发**     | Spring IOC 容器自动创建 Bean、依赖注入 |
| ⚙️ **动态加载插件**   | 根据配置文件加载不同实现类               |
| 🔁 **序列化/反序列化** | JSON 工具（如 Jackson）读写对象字段    |
| 🧪 **单元测试**     | JUnit 自动发现并执行测试方法           |
| 🛡️ **权限绕过调试**  | 修改私有字段、调用隐藏 API（慎用！）        |

---

#### **七、注意事项 & 常见坑点**

| 问题           | 说明                            |
| ------------ | ----------------------------- |
| ⚠️ **性能问题**  | 反射比直接调用慢很多（适合初始化阶段，不适合高频调用）   |
| 🔒 **安全性限制** | Java 9+ 默认禁止访问私有成员，需加 JVM 参数： |
  `--add-opens java.base/java.lang=ALL-UNNAMED` |
| 🤖 **编译期不可知性** | 如果类结构变化，反射代码不会报错，运行时报错 |
| 💥 **破坏封装性** | 滥用反射会破坏面向对象原则，降低可维护性 |

---

#### **八、一句话总结**
> **反射就像程序运行时的“探照灯”和“手术刀”**，可以在不修改源码的情况下，动态操作类的行为，是构建灵活系统的关键工具，但也需谨慎使用。

---
