泛型是 Java 中一个非常重要的特性，它允许我们在编译时检查类型安全，并且可以创建可重用的代码，这些代码可以处理多种数据类型，而无需为每种类型都编写重复的代码。

---

### Java 泛型 (Generics)

**1. 为什么需要泛型？ (What & Why)**

在泛型出现之前 (JDK 1.5 之前)，Java 集合（如 `ArrayList`）存储的是 `Object` 类型的对象。这意味着：

*   **存入时没有类型检查：** 你可以向一个 `ArrayList` 中存入任何类型的对象，比如 `String`、`Integer` 甚至自定义对象。
    ```java
    // JDK 1.5 之前
    List list = new ArrayList();
    list.add("Hello");
    list.add(123); // 编译通过，但逻辑上可能不希望这样
    ```
*   **取出时需要强制类型转换：** 从集合中取出元素时，你得到的是 `Object` 类型，必须手动将其强制转换为你期望的类型。
    ```java
    // JDK 1.5 之前
    String firstElement = (String) list.get(0); // 需要强制转换
    ```
*   **运行时可能发生 `ClassCastException`：** 如果在取出元素时转换的类型与实际存入的类型不匹配，程序将在运行时抛出 `ClassCastException`。这使得错误难以在编译阶段发现。
    ```java
    // JDK 1.5 之前
    Integer problematicElement = (Integer) list.get(0); // 运行时会抛出 ClassCastException，因为第一个元素是 "Hello"
    ```

**泛型的引入解决了这些问题：**

*   **类型安全 (Type Safety)：** 泛型允许你为集合（或其他泛型类/接口）指定它可以容纳的元素类型。编译器会在编译时检查你存入的元素是否符合指定的类型。
    ```java
    // JDK 1.5 及之后
    List<String> stringList = new ArrayList<>(); // 指定只能存放 String
    stringList.add("Hello");
    // stringList.add(123); // 编译错误！不能添加 Integer 到 List<String>
    ```
*   **消除强制类型转换：** 当你从泛型集合中取出元素时，编译器知道元素的具体类型，因此不再需要手动进行强制类型转换。
    ```java
    // JDK 1.5 及之后
    String firstElement = stringList.get(0); // 无需强制转换
    ```
*   **代码更清晰、更健壮：** 泛型使得代码的意图更加明确，减少了运行时错误的可能性。

**核心思想：参数化类型 (Parameterized Types)**

你可以把泛型看作是类型的参数。就像方法有参数一样，类和接口也可以有类型参数。

**2. 类型擦除 (Type Erasure) - 它是如何工作的？**

这是一个非常重要的概念，也是 Java 泛型与 C++ 模板等机制的一个关键区别。

*   **编译时检查，运行时擦除：** Java 的泛型主要是在编译阶段进行类型检查和转换。在编译完成后，泛型信息（如 `<String>`）会被“擦除”掉，替换为其**上界 (upper bound)**，如果没有指定上界，则默认为 `Object`。
*   **字节码中的泛型：** 泛型类型信息在字节码层面通常会被擦除。这意味着在运行时，`List<String>` 和 `List<Integer>` 在 JVM 看来实际上都是 `List`（原始类型）。
*   **桥方法 (Bridge Methods)：** 为了保持多态性，编译器有时会生成一些额外的“桥方法”来处理泛型擦除后可能出现的类型不匹配问题（例如在继承泛型类或实现泛型接口时）。

**为什么类型擦除？**

*   **向后兼容：** 这是为了让泛型代码能够与 JDK 1.5 之前的非泛型代码和库兼容。如果泛型在运行时也存在，那么旧代码将无法与新代码交互。

**类型擦除带来的影响：**

*   **不能创建泛型类型的数组：** 你不能直接 `new T[10]` (其中 `T` 是类型参数)，因为 `T` 在运行时被擦除了，JVM 不知道要创建什么类型的数组。通常的解决方法是创建 `Object[]` 然后进行类型转换（需要 `@SuppressWarnings("unchecked")`），或者使用 `List<T>`。
*   **不能对泛型类型使用 `instanceof`：** 你不能写 `if (obj instanceof List<String>)`，因为 `<String>` 在运行时不存在。你可以写 `if (obj instanceof List)`。
*   **静态上下文中不能使用类型参数：** 类的静态成员（静态变量、静态方法）不能引用类的类型参数，因为类型参数是与类的实例相关联的。
*   **不能创建泛型异常类：** `Exception` 类或其子类不能是泛型的。

**3. 泛型类 (Generic Classes)**

定义一个类时，可以在类名后使用尖括号 `<T>` 来声明一个或多个类型参数。`T` 通常用作类型占位符，你也可以使用其他大写字母（如 `E` for Element, `K` for Key, `V` for Value, `N` for Number）。

```java
public class Box<T> { // T 是类型参数
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }

    public static void main(String[] args) {
        Box<Integer> integerBox = new Box<>(); // 实例化时指定具体类型为 Integer
        integerBox.setItem(123);
        Integer content = integerBox.getItem();
        System.out.println("Integer Box contains: " + content);

        Box<String> stringBox = new Box<>(); // 实例化时指定具体类型为 String
        stringBox.setItem("Hello Generics");
        String message = stringBox.getItem();
        System.out.println("String Box contains: " + message);

        // Box<Double> doubleBox = new Box<Integer>(); // 编译错误！泛型类型必须匹配
        // (注意：Java 7+ 支持类型推断，右边可以省略类型参数，即 "diamond operator" <>)
        Box<Double> doubleBox = new Box<>(); // 正确，编译器会推断为 Box<Double>
        doubleBox.setItem(3.14);
    }
}
```

**4. 泛型接口 (Generic Interfaces)**

与泛型类类似，接口也可以定义类型参数。

```java
public interface Shippable<T> {
    void ship(T item);
    T unwrap();
}

// 实现泛型接口时，可以指定具体类型
class BookShipper implements Shippable<Book> {
    @Override
    public void ship(Book item) {
        System.out.println("Shipping book: " + item.getTitle());
    }

    @Override
    public Book unwrap() {
        // ... logic to get a book
        return new Book("Effective Java");
    }
}

// 也可以在实现时继续保持泛型
class GenericShipper<U> implements Shippable<U> {
    @Override
    public void ship(U item) {
        System.out.println("Shipping generic item: " + item.toString());
    }

    @Override
    public U unwrap() {
        // ... logic to get a U
        return null; // Placeholder
    }
}

class Book {
    private String title;
    public Book(String title) { this.title = title; }
    public String getTitle() { return title; }
}
```

**5. 泛型方法 (Generic Methods)**

泛型方法是指在方法声明中定义类型参数的方法。这些类型参数的作用域仅限于该方法。泛型方法可以定义在普通类中，也可以定义在泛型类中。

*   类型参数声明在**返回值之前**。
*   泛型方法使得方法的参数类型或返回类型可以灵活变化。

```java
public class Utils {
    // 泛型方法 <T> 是类型参数声明
    public static <T> T getFirstElement(List<T> list) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }

    // 多个类型参数
    public static <K, V> boolean comparePairs(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }

    public static void main(String[] args) {
        List<String> names = List.of("Alice", "Bob");
        String firstName = Utils.getFirstElement(names); // 编译器自动推断 T 为 String
        System.out.println("First name: " + firstName);

        List<Integer> numbers = List.of(1, 2, 3);
        Integer firstNumber = Utils.getFirstElement(numbers); // 编译器自动推断 T 为 Integer
        System.out.println("First number: " + firstNumber);

        // 也可以显式指定类型参数 (通常不需要)
        // String first = Utils.<String>getFirstElement(names);
    }
}

// 辅助类 Pair
class Pair<K, V> {
    private K key;
    private V value;
    public Pair(K key, V value) { this.key = key; this.value = value; }
    public K getKey() { return key; }
    public V getValue() { return value; }
}
```
**关键点：** 泛型方法的类型参数是独立于类的类型参数的（如果类也是泛型的话）。

**6. 通配符 (Wildcards)**

通配符用 `?` 表示，它代表一种未知的类型。通配符主要用于提高 API 的灵活性，特别是在处理参数化的类型时。

*   **上界通配符 (Upper Bounded Wildcard): `? extends Type`**
    *   表示参数化的类型可能是 `Type` 或 `Type` 的某个子类型。
    *   **PECS 原则 (Producer Extends, Consumer Super) 中的 "Producer Extends"：** 如果一个泛型结构主要是用来**生产** (读取/提供) `T` 类型的数据，那么应该使用 `? extends T`。
    *   对于 `List<? extends Number>`，你可以安全地从中读取元素并赋值给 `Number` 类型的变量，因为你知道它至少是 `Number`。
    *   但是，你**不能**向 `List<? extends Number>` 中添加元素 (除了 `null`)，因为编译器不知道 `?` 具体是哪个 `Number` 的子类型 (可能是 `Integer`，也可能是 `Double`，存入 `Integer` 到 `List<Double>` 是不安全的)。

    ```java
    public static double sumOfList(List<? extends Number> list) {
        double sum = 0.0;
        for (Number n : list) { // 安全读取，n 是 Number 或其子类
            sum += n.doubleValue();
        }
        // list.add(1); // 编译错误！不能添加，不知道 ? 具体是什么
        return sum;
    }

    public static void main(String[] args) {
        List<Integer> intList = List.of(1, 2, 3);
        List<Double> doubleList = List.of(1.0, 2.5, 3.5);
        List<String> stringList = List.of("a", "b");

        System.out.println("Sum of integers: " + sumOfList(intList));
        System.out.println("Sum of doubles: " + sumOfList(doubleList));
        // sumOfList(stringList); // 编译错误！String 不是 Number 的子类
    }
    ```

*   **下界通配符 (Lower Bounded Wildcard): `? super Type`**
    *   表示参数化的类型可能是 `Type` 或 `Type` 的某个父类型。
    *   **PECS 原则中的 "Consumer Super"：** 如果一个泛型结构主要是用来**消费** (写入/接收) `T` 类型的数据，那么应该使用 `? super T`。
    *   对于 `List<? super Integer>`，你可以安全地向其中添加 `Integer` 对象或者 `Integer` 的子类型对象 (因为它们都可以向上转型为 `Integer` 或 `Integer` 的父类型)。
    *   但是，当你从中读取元素时，你只能保证得到的是 `Object` 类型 (因为你不知道 `?` 具体是哪个 `Integer` 的父类型，可能是 `Number` 或 `Object`)。

    ```java
    public static void addNumbers(List<? super Integer> list) {
        list.add(10);    // 安全添加 Integer
        list.add(20);
        // Integer num = list.get(0); // 编译错误！只能确定是 Object
        Object obj = list.get(0); // 安全读取为 Object
    }

    public static void main(String[] args) {
        List<Integer> intList = new ArrayList<>();
        List<Number> numList = new ArrayList<>();
        List<Object> objList = new ArrayList<>();

        addNumbers(intList);
        addNumbers(numList);
        addNumbers(objList);

        // List<Double> doubleList = new ArrayList<>();
        // addNumbers(doubleList); // 编译错误！Double 不是 Integer 的父类
    }
    ```

*   **无界通配符 (Unbounded Wildcard): `?`**
    *   表示参数化的类型是任意类型。`List<?>` 读作 "a list of unknown type"。
    *   当你使用的方法不依赖于具体的类型参数时可以使用。
    *   对于 `List<?>`，你不能向其中添加元素 (除了 `null`)，因为不知道元素的具体类型。
    *   你可以从中读取元素，但只能得到 `Object` 类型。
    *   常用于打印集合内容、获取集合大小等与具体类型无关的操作。

    ```java
    public static void printList(List<?> list) {
        for (Object elem : list) { // 读取为 Object
            System.out.print(elem + " ");
        }
        System.out.println();
        // list.add("new element"); // 编译错误！
    }

    public static void main(String[] args) {
        List<String> names = List.of("Alice", "Bob");
        List<Integer> numbers = List.of(1, 2, 3);
        printList(names);
        printList(numbers);
    }
    ```

**PECS 原则总结 (Producer Extends, Consumer Super):**

这个原则是 Joshua Bloch 在《Effective Java》中提出的，用于指导何时使用 `extends` 和 `super` 通配符：

*   **"Producer Extends"**: 如果你需要一个列表来**产出** `T` 类型的值（你是从中读取），那么使用 `? extends T`。这个列表可以是 `List<T>`，也可以是 `List<S>`（其中 `S` 是 `T` 的子类）。
*   **"Consumer Super"**: 如果你需要一个列表来**消费** `T` 类型的值（你是向其中写入），那么使用 `? super T`。这个列表可以是 `List<T>`，也可以是 `List<S>`（其中 `S` 是 `T` 的父类）。
*   **如果既生产又消费：** 不要使用通配符，直接使用精确的泛型类型（如 `List<T>`）。

**7. 泛型与继承**

*   `List<String>` **不是** `List<Object>` 的子类型！这是一个常见的误解。
    *   如果 `List<String>` 是 `List<Object>` 的子类型，那么下面的代码就应该编译通过，但这会导致运行时类型错误：
        ```java
        // 假设 List<String> 是 List<Object> 的子类 (错误假设)
        // List<String> strList = new ArrayList<>();
        // List<Object> objList = strList; // 编译通过 (错误假设)
        // objList.add(123); // 试图向 List<String> 中添加 Integer，这破坏了类型安全
        // String s = strList.get(0); // ClassCastException
        ```
    *   这就是为什么需要通配符。如果你想编写一个可以接受任何类型列表的方法，你应该使用 `List<?>` 或 `List<? extends Object>` (它们是等价的，但前者更简洁)。
*   泛型类可以继承或实现其他泛型类或接口，类型参数可以传递或具体化。
    ```java
    class NumberBox<T extends Number> extends Box<T> { /* ... */ } // T 必须是 Number 或其子类
    class StringBox extends Box<String> { /* ... */ } // 具体化为 String
    ```

**8. 原始类型 (Raw Types)**

在泛型代码中，如果你使用了一个泛型类而没有指定其类型参数，那么你使用的就是它的**原始类型**。例如，`List list = new ArrayList();` 中的 `List` 就是原始类型。

*   **应该避免使用原始类型：** 编译器会给出警告。使用原始类型会丢失泛型带来的类型安全和表达能力。
*   **与遗留代码兼容：** 原始类型主要是为了与 JDK 1.5 之前的非泛型代码兼容。

**最新进展与实践：**

*   **Diamond Operator (`<>`):** 从 Java 7 开始，在创建泛型实例时，如果编译器能够从上下文中推断出类型参数，你可以使用空尖括号 (`<>`)，称为菱形操作符。
    ```java
    List<String> names = new ArrayList<>(); // 等同于 new ArrayList<String>();
    Map<String, List<Integer>> map = new HashMap<>();
    ```
*   **`var` 与泛型 (Java 10+)：** `var` 关键字可以用于局部变量类型推断，它与泛型一起使用时非常方便，但要注意 `var` 推断的是确切的泛型类型，而不是原始类型或通配符类型。
    ```java
    var stringList = new ArrayList<String>(); // stringList 类型是 ArrayList<String>
    var numberList = List.of(1, 2.0, 3L); // numberList 类型是 List<Number> (编译器推断的最具体公共超类型)
    ```
*   **泛型和 Records (Java 14+)：** Record 类也可以是泛型的。
    ```java
    record Point<T extends Number>(T x, T y) {}
    Point<Integer> p1 = new Point<>(10, 20);
    Point<Double> p2 = new Point<>(10.5, 20.5);
    ```

**总结与重要性：**

*   泛型是 Java 类型系统的核心部分，主要目的是**提高类型安全**和**代码重用性**。
*   理解**类型擦除**是深入掌握 Java 泛型的关键。
*   熟练运用**泛型类、泛型接口、泛型方法**。
*   掌握**通配符 (`extends`, `super`, `?`)** 的使用场景，特别是 **PECS 原则**，对于编写灵活且类型安全的 API 至关重要。
*   避免使用原始类型，拥抱现代 Java 的泛型特性。

泛型是理解和使用 Java 集合框架 (JCF) 的绝对前提，因为 JCF 中的所有核心接口和类都是泛型的。