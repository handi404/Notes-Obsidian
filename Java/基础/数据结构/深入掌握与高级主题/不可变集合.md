在软件开发中，不可变性是一个非常有价值的特性，它可以带来诸多好处，如简化并发编程、提高代码的可预测性和可维护性、以及潜在的性能优势。Java 集合框架也提供了创建不可变集合的机制。

我们将重点讨论两种主要的创建方式：

1.  `Collections.unmodifiableXxx()` 系列方法。
2.  Java 9+ 引入的 `List.of()`, `Set.of()`, `Map.of()` 等静态工厂方法。

---

### 不可变集合 (Immutable Collections)

**什么是不可变集合？**

一个不可变集合是指在它被创建之后，其内容（即它所包含的元素或映射关系）**不能被修改**的集合。这意味着不能向其中添加元素、移除元素，或者改变现有元素（如果元素本身是可变的，集合的不可变性通常不保证元素内部状态的不可变）。

**为什么使用不可变集合？**

1.  **线程安全 (Thread Safety)：**
    *   不可变对象本质上是线程安全的，因为它们的状态不会改变，所以多个线程可以同时访问它们而不需要任何同步机制，不会产生竞态条件。
    *   这大大简化了并发程序的设计。

2.  **可预测性和可靠性 (Predictability and Reliability)：**
    *   当你将一个不可变集合传递给一个方法或者在多个地方共享它时，你确信它的内容不会被意外修改，从而避免了许多难以追踪的 bug。
    *   代码的推理变得更容易。

3.  **可作为常量 (Usable as Constants)：**
    *   不可变集合非常适合用作程序中定义的常量集合数据。

4.  **性能 (Potential Performance Benefits)：**
    *   由于状态固定，不可变集合的 `hashCode()` 可以被缓存，从而提高其作为 `Map` 键或在 `Set` 中存储时的性能。
    *   某些不可变集合的实现可以进行内存优化（例如，更紧凑的内部表示）。
    *   不需要为防御性拷贝分配额外内存（因为原始集合不会改变）。

5.  **安全性 (Security)：**
    *   如果一个类暴露了其内部集合的引用，将其包装成不可变集合可以防止外部代码修改其内部状态。

---

### 1. `Collections.unmodifiableXxx()` 方法

这是在 Java 9 之前创建不可变集合视图的主要方式。

*   **方法概览：**
    *   `Collections.unmodifiableCollection(Collection<? extends T> c)`
    *   `Collections.unmodifiableList(List<? extends T> list)`
    *   `Collections.unmodifiableSet(Set<? extends T> s)`
    *   `Collections.unmodifiableMap(Map<? extends K, ? extends V> m)`
    *   以及针对 `SortedSet`, `SortedMap`, `NavigableSet`, `NavigableMap` 的相应方法。

*   **工作原理：**
    *   这些方法返回的是一个**不可修改的视图 (unmodifiable view)**，而不是一个全新的、独立的不可变集合副本。
    *   返回的包装器集合会重写所有修改操作的方法（如 `add`, `remove`, `set`, `clear`, `put` 等），使其抛出 `UnsupportedOperationException`。
    *   所有的只读操作（如 `get`, `size`, `contains`, `iterator` 等）都会委托给底层的原始集合。

*   **关键特性与局限性：**
    1.  **视图而非副本：**
        *   **如果底层的原始集合在视图创建之后被修改了，那么这个“不可修改”的视图也会反映这些变化！** 这是 `unmodifiableXxx()` 最重要的一个特性，也是它与 Java 9+ `of()` 方法的主要区别之一。
        ```java
        List<String> mutableList = new ArrayList<>(List.of("A", "B"));
        List<String> unmodifiableView = Collections.unmodifiableList(mutableList);

        System.out.println(unmodifiableView); // [A, B]
        // unmodifiableView.add("C"); // Throws UnsupportedOperationException

        mutableList.add("C"); // 修改原始列表
        System.out.println(unmodifiableView); // [A, B, C] - 视图也变化了!
        ```

    2.  **创建真正不可变的防御性拷贝：**
        *   为了创建一个在创建后内容完全固定的不可变集合（即原始集合的修改不影响它），你需要：
            1.  首先创建一个原始集合的**防御性拷贝 (defensive copy)**。
            2.  然后用 `unmodifiableXxx()` 包装这个拷贝。
            3.  确保不再有任何可变引用指向这个拷贝。
        ```java
        List<String> originalList = new ArrayList<>(List.of("X", "Y"));
        // 创建防御性拷贝并包装
        List<String> trulyImmutableList = Collections.unmodifiableList(new ArrayList<>(originalList));

        originalList.add("Z"); // 修改原始列表
        System.out.println(trulyImmutableList); // [X, Y] - 不受影响
        System.out.println(originalList);       // [X, Y, Z]
        ```

    3.  **允许 `null` 元素/键/值：**
        *   是否允许 `null` 取决于底层的原始集合。如果原始集合允许 `null`，那么不可修改视图也会包含它们。

    4.  **序列化：**
        *   返回的视图是可序列化的，如果底层集合也是可序列化的。

    5.  **性能开销：**
        *   每次方法调用都需要经过包装器的一层委托，理论上会有一点点性能开销，但通常可以忽略不计。

*   **使用场景：**
    *   当需要向外部代码提供一个集合的只读访问权限，同时又希望这个视图能实时反映内部集合的变化时。
    *   在 Java 9 之前，作为创建内容固定的不可变集合的主要手段（配合防御性拷贝）。
    *   用于保护类内部的可变集合字段，防止外部修改。
        ```java
        public class MyDataContainer {
            private final List<String> internalData = new ArrayList<>();

            public void addData(String data) {
                internalData.add(data);
            }

            // 返回不可修改的视图，保护内部数据
            public List<String> getDataView() {
                return Collections.unmodifiableList(internalData);
            }
        }
        ```

---

### 2. Java 9+ `List.of()`, `Set.of()`, `Map.of()` 静态工厂方法

Java 9 (JEP 269) 引入了一系列静态工厂方法，用于方便地创建**真正的、紧凑的、不可变的集合实例**。

*   **方法概览 (部分)：**
    *   **`List.of()` 系列：**
        *   `static <E> List<E> of()` (空列表)
        *   `static <E> List<E> of(E e1)`
        *   `static <E> List<E> of(E e1, E e2, ..., E e10)` (多个固定参数数量的重载)
        *   `static <E> List<E> of(E... elements)` (可变参数版本)
    *   **`Set.of()` 系列：**
        *   (与 `List.of()` 类似，但用于创建 `Set`)
    *   **`Map.of()` 系列：**
        *   `static <K,V> Map<K,V> of()` (空映射)
        *   `static <K,V> Map<K,V> of(K k1, V v1)`
        *   `static <K,V> Map<K,V> of(K k1, V v1, ..., K k10, V v10)` (多个固定参数数量的重载)
    *   **`Map.ofEntries(Map.Entry<? extends K, ? extends V>... entries)`:**
        *   通过 `Map.entry(K k, V v)` (Java 9 新增的静态方法) 创建的条目来构造不可变映射。

*   **关键特性与优势：**

    1.  **真正的不可变性：**
        *   这些方法返回的是**全新的、专门设计的不可变集合实例**，而不是视图。它们的内容在创建后**绝对不能被修改**。
        *   没有底层的可变集合可以被修改来影响它们。

    2.  **紧凑和高效 (Compact and Efficient)：**
        *   JDK 内部为这些不可变集合提供了高度优化的实现。
        *   对于小型集合（尤其是空集合或只有少量元素的集合），它们的内存占用通常比通过 `Collections.unmodifiableXxx()` 包装传统集合要小。
        *   访问性能也可能更好，因为不需要经过包装器的委托。

    3.  **禁止 `null` 元素/键/值：**
        *   这些工厂方法**不允许**传入 `null` 元素（对于 `List` 和 `Set`）或 `null` 键/值（对于 `Map`）。如果尝试传入 `null`，会立即抛出 `NullPointerException`。
        *   这是为了保证集合的完整性和避免 `null` 带来的歧义。

    4.  **对重复元素的处理 (对于 `Set` 和 `Map` 键)：**
        *   `Set.of()` 如果传入重复元素，会抛出 `IllegalArgumentException`。
        *   `Map.of()` 如果传入重复的键，会抛出 `IllegalArgumentException`。
        *   这与可变 `Set` 和 `Map` 的 `add` / `put` 行为不同（它们会忽略重复或覆盖）。

    5.  **迭代顺序：**
        *   **`List.of()`:** 保持传入参数的顺序。
        *   **`Set.of()` 和 `Map.of()`:** **不保证**迭代顺序。虽然在当前的 JDK 实现中，对于少量元素，顺序可能是可预测的（基于参数位置或哈希），但官方文档明确指出**不应依赖此顺序**，它未来可能会改变。如果需要有序的不可变 `Set` 或 `Map`，你需要先创建 `TreeSet` 或 `TreeMap`，然后用 `Collections.unmodifiableSortedSet/Map` 包装，或者使用第三方库（如 Guava）。

    6.  **序列化：**
        *   返回的不可变集合是可序列化的。

*   **示例：**
    ```java
    List<String> immutableList = List.of("Apple", "Banana", "Cherry");
    // immutableList.add("Date"); // Throws UnsupportedOperationException
    // immutableList.set(0, "Apricot"); // Throws UnsupportedOperationException

    Set<Integer> immutableSet = Set.of(10, 20, 30);
    // Set<Integer> duplicateSet = Set.of(10, 20, 10); // Throws IllegalArgumentException

    Map<String, Integer> immutableMap = Map.of("One", 1, "Two", 2);
    // Map<String, Integer> duplicateKeyMap = Map.of("A", 1, "B", 2, "A", 3); // Throws IllegalArgumentException
    // Map<String, Integer> nullKeyMap = Map.of(null, 0); // Throws NullPointerException

    // 使用 Map.entry()
    Map<String, String> capitals = Map.ofEntries(
        Map.entry("USA", "Washington D.C."),
        Map.entry("UK", "London"),
        Map.entry("Japan", "Tokyo")
    );
    ```

---

### `Collections.unmodifiableXxx()` vs Java 9+ `of()` 方法对比

| 特性                      | `Collections.unmodifiableXxx(collection)` | `List/Set/Map.of(...)`                             |
| ------------------------- | ------------------------------------------- | -------------------------------------------------- |
| **返回类型**              | 不可修改的**视图 (View)**                   | **全新的不可变实例 (Instance)**                      |
| **底层集合可变性影响**    | **受影响** (如果原始集合改变，视图也变)     | **不受影响** (创建后内容固定)                        |
| **`null` 元素/键/值**   | 允许 (取决于原始集合)                       | **不允许** (抛 `NullPointerException`)               |
| **重复元素 (`Set` / `Map` 键)** | 忽略/覆盖 (取决于原始集合行为)            | **不允许** (抛 `IllegalArgumentException`)           |
| **内存/性能**             | 包装器开销，依赖原始集合的实现            | 通常更紧凑，性能可能更好 (特别是小集合)              |
| **创建方式**              | 包装已有的可变集合                          | 直接通过静态工厂方法创建                             |
| **迭代顺序 (`Set` / `Map`)** | 依赖原始集合的顺序                          | **不保证** (除非 `List.of()`)                        |
| **适用 Java 版本**        | JDK 1.2+                                    | Java 9+                                            |

**选择建议：**

*   **如果你的目标是创建一个在创建后其内容就完全固定、真正不可变的集合，并且你在使用 Java 9 或更高版本：**
    *   **优先选择 `List.of()`, `Set.of()`, `Map.of()` 系列方法。** 它们更简洁、通常更高效，并且语义上更清晰地表达了“创建后即不可变”的意图。
*   **如果你需要一个现有可变集合的只读视图，并且这个视图需要能反映对原始可变集合的后续更改：**
    *   使用 `Collections.unmodifiableXxx()`。
*   **如果你需要在 Java 8 或更早版本中创建内容固定的不可变集合：**
    *   使用 `Collections.unmodifiableXxx()` 包装一个**防御性拷贝**。
*   **如果你的不可变集合需要包含 `null` 元素/键/值：**
    *   你不能使用 `List/Set/Map.of()`。你需要使用 `Collections.unmodifiableXxx()` 包装一个允许 `null` 的可变集合（的拷贝）。
*   **如果你的不可变 `Set` 或 `Map` 需要特定的迭代顺序 (如插入顺序或排序)：**
    *   对于插入顺序：先创建 `LinkedHashSet` / `LinkedHashMap`，然后用 `Collections.unmodifiableSet/Map` 包装其拷贝。
    *   对于排序顺序：先创建 `TreeSet` / `TreeMap`，然后用 `Collections.unmodifiableSortedSet/Map` 包装其拷贝。
    *   `Set.of()` 和 `Map.of()` 不保证顺序。

**第三方库中的不可变集合 (如 Guava)：**

在 Java 9 之前，Google 的 Guava 库是提供高质量不可变集合 (如 `ImmutableList`, `ImmutableSet`, `ImmutableMap`) 的流行选择。Guava 的不可变集合设计精良，提供了丰富的特性 (如构建器、排序的不可变集合等)，并且在许多方面与 Java 9+ 的 `of()` 方法类似（例如，不允许 `null`，创建的是真实副本）。

如果你还在使用 Java 8 或需要 Guava 提供的额外功能，它仍然是一个很好的选择。但对于 Java 9+ 的新项目，标准库的 `of()` 方法通常足够且更轻量。

---

**总结与重要性：**

*   不可变集合是构建健壮、可维护和线程安全 Java 应用的重要工具。
*   理解 `Collections.unmodifiableXxx()`（视图）和 Java 9+ `of()`（实例）之间的核心区别至关重要。
*   根据你的需求（是否需要反映底层变化、是否允许 `null`、是否需要特定顺序、Java 版本）来选择合适的创建不可变集合的方式。
*   拥抱 Java 9+ 的 `of()` 方法可以让你编写更简洁、更安全的创建不可变集合的代码。