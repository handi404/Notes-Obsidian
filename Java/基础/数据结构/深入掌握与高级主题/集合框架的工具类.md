从**集合框架的工具类**开始，主要是 `java.util.Collections` 类，同时也会简要回顾一下 `java.util.Arrays` 中与集合相关的内容。

---

### 集合框架的工具类：`java.util.Collections`

`java.util.Collections` 类包含了一系列**静态的实用方法 (utility methods)**，用于操作或返回集合。这些方法提供了对集合的常见操作，如排序、搜索、填充、线程安全包装、不可变包装等。

这个类中的所有方法都是 `static` 的，因此你不能创建 `Collections` 类的实例。

#### **1. 排序 (Sorting)**

*   **`static <T extends Comparable<? super T>> void sort(List<T> list)`:**
    *   使用元素的**自然顺序**对指定的列表进行升序排序。列表中的所有元素必须实现 `Comparable` 接口。
    *   底层通常使用高效的排序算法，如归并排序或 TimSort (Java 7+ 对对象排序)。
    *   此方法会**直接修改**原始 `list`。

*   **`static <T> void sort(List<T> list, Comparator<? super T> c)`:**
    *   使用指定的 `Comparator` 对列表进行排序。
    *   如果 `c` 为 `null`，则行为与第一个 `sort` 方法相同（要求元素实现 `Comparable`）。
    *   此方法也会**直接修改**原始 `list`。

    ```java
    List<String> names = new ArrayList<>(List.of("Charlie", "Alice", "Bob"));
    Collections.sort(names); // 按自然顺序 (字典序)
    System.out.println(names); // [Alice, Bob, Charlie]

    List<Integer> numbers = new ArrayList<>(List.of(5, 1, 9, 3));
    Collections.sort(numbers, Comparator.reverseOrder()); // 按降序
    System.out.println(numbers); // [9, 5, 3, 1]

    // 注意：Java 8+ List 接口自身也提供了 sort 方法: list.sort(comparator)
    // names.sort(Comparator.naturalOrder());
    ```

#### **2. 搜索 (Searching)**

*   **`static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key)`:**
    *   在指定的**已排序**列表中使用二分搜索算法查找指定的对象。
    *   列表必须预先按照元素的**自然顺序**排序。如果列表未排序，结果是未定义的。
    *   返回：
        *   如果找到 `key`，返回其索引。
        *   如果未找到 `key`，返回 `(-(insertion point) - 1)`。

*   **`static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c)`:**
    *   在指定的**已排序**列表中使用二分搜索算法查找指定的对象。
    *   列表必须预先按照指定的 `Comparator` 排序。如果 `c` 为 `null`，则按自然顺序。
    *   返回值同上。

    ```java
    List<Integer> sortedNumbers = List.of(10, 20, 30, 40, 50);
    int index = Collections.binarySearch(sortedNumbers, 30); // 2
    int notFound = Collections.binarySearch(sortedNumbers, 35); // -4
    ```

#### **3. 修改顺序与内容 (Modifying Order and Content)**

*   **`static void reverse(List<?> list)`:**
    *   反转指定列表中元素的顺序。

*   **`static void shuffle(List<?> list)`:**
    *   使用默认的随机源随机打乱指定列表中元素的顺序。

*   **`static void shuffle(List<?> list, Random rnd)`:**
    *   使用指定的随机源 `rnd` 随机打乱列表。

*   **`static void fill(List<? super T> list, T obj)`:**
    *   用指定的元素 `obj` 替换指定列表中的所有元素。

*   **`static <T> void copy(List<? super T> dest, List<? extends T> src)`:**
    *   将源列表 `src` 中的所有元素复制到目标列表 `dest` 中。
    *   **重要：** `dest` 列表的**大小必须至少与 `src` 列表的大小相同**。它只会覆盖 `dest` 中从索引 0 开始的相应位置的元素，不会改变 `dest` 的大小。如果 `dest` 比 `src` 长，`dest` 中多余的元素不受影响。
    *   如果 `dest` 比 `src` 短，会抛 `IndexOutOfBoundsException`。

    ```java
    List<Integer> nums = new ArrayList<>(List.of(1, 2, 3, 4, 5));
    Collections.reverse(nums); // [5, 4, 3, 2, 1]
    Collections.shuffle(nums); // 顺序随机
    System.out.println(nums);

    List<String> letters = new ArrayList<>(List.of("A", "B", "C"));
    Collections.fill(letters, "X"); // [X, X, X]

    List<Integer> source = List.of(10, 20);
    List<Integer> destination = new ArrayList<>(List.of(0, 0, 0, 0)); // 必须足够大
    Collections.copy(destination, source);
    System.out.println(destination); // [10, 20, 0, 0]
    ```

*   **`static <T> void rotate(List<T> list, int distance)`:**
    *   将列表中的元素循环移动指定的距离。
    *   `distance > 0`: 元素向右移动 (列表尾部的元素移到头部)。
    *   `distance < 0`: 元素向左移动。
    *   `list.set(i, list.get((i - distance + size) % size))`

    ```java
    List<Character> chars = new ArrayList<>(List.of('a', 'b', 'c', 'd', 'e'));
    Collections.rotate(chars, 2);  // 向右移动2位
    System.out.println(chars); // [d, e, a, b, c]
    Collections.rotate(chars, -1); // 向左移动1位
    System.out.println(chars); // [e, a, b, c, d]
    ```

*   **`static <T> boolean replaceAll(List<T> list, T oldVal, T newVal)`:**
    *   用 `newVal` 替换列表中所有出现的 `oldVal`。如果发生替换则返回 `true`。

#### **4. 查找极值 (Finding Extrema)**

*   **`static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll)`:**
    *   返回给定集合中按自然顺序的最小元素。

*   **`static <T> T min(Collection<? extends T> coll, Comparator<? super T> comp)`:**
    *   返回给定集合中根据指定比较器确定的最小元素。

*   **`static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)`:**
    *   返回给定集合中按自然顺序的最大元素。

*   **`static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp)`:**
    *   返回给定集合中根据指定比较器确定的最大元素。

    ```java
    List<Integer> data = List.of(5, 1, 9, 3, 7);
    Integer minimum = Collections.min(data); // 1
    Integer maximum = Collections.max(data); // 9
    ```

#### **5. 频率与不相交 (Frequency and Disjoint)**

*   **`static int frequency(Collection<?> c, Object o)`:**
    *   返回指定集合中指定元素 `o` 出现的次数。

*   **`static boolean disjoint(Collection<?> c1, Collection<?> c2)`:**
    *   如果两个指定集合没有共同元素，则返回 `true`。

#### **6. 同步包装器 (Synchronized Wrappers) - 用于线程安全**

这些方法返回一个由指定集合支持的**线程安全 (同步) 的集合视图**。

*   `static <T> Collection<T> synchronizedCollection(Collection<T> c)`
*   `static <T> Set<T> synchronizedSet(Set<T> s)`
*   `static <T> List<T> synchronizedList(List<T> list)`
*   `static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)`
*   `static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s)`
*   `static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m)`
*   `static <T> NavigableSet<T> synchronizedNavigableSet(NavigableSet<T> s)` (Java 6+)
*   `static <K,V> NavigableMap<K,V> synchronizedNavigableMap(NavigableMap<K,V> m)` (Java 6+)

*   **工作原理：**
    *   返回的包装集合会将对其所有公共方法的调用委托给底层集合，并在委托调用之前和之后获取包装集合对象自身的**内部锁 (intrinsic lock, 即 `synchronized(this)`)**。
    *   **迭代时的线程安全问题：** 即使使用了这些同步包装器，当通过迭代器遍历集合时，**迭代过程本身不是原子性的**。如果在迭代过程中，其他线程修改了集合（即使是通过同步包装器），仍可能导致 `ConcurrentModificationException` 或不确定的行为。
    *   **正确的迭代方式：** 如果需要线程安全地迭代，必须在迭代期间手动在同步包装集合对象上进行同步：
        ```java
        List<String> list = new ArrayList<>();
        List<String> syncList = Collections.synchronizedList(list);
        // ... 其他线程可能在修改 syncList ...

        // 线程安全迭代
        synchronized (syncList) { // 必须在 syncList 对象上加锁
            Iterator<String> i = syncList.iterator(); // Must be in synchronized block
            while (i.hasNext()) {
                // process(i.next());
            }
        }
        ```
*   **性能：** 由于每次方法调用都需要获取锁，同步包装器的性能通常低于 `java.util.concurrent` 包中专门设计的并发集合 (如 `ConcurrentHashMap`, `CopyOnWriteArrayList` 等)。
*   **现代 Java 的选择：** 在现代 Java 并发编程中，**通常更推荐使用 `java.util.concurrent` 包下的并发集合**，因为它们通常提供了更高的并发性能和更细粒度的锁控制 (或者无锁实现)。同步包装器更多地用于将已有的非线程安全集合快速适配到多线程环境，或者在一些简单场景下。

#### **7. 不可修改包装器 (Unmodifiable Wrappers) - 创建只读视图**

这些方法返回一个由指定集合支持的**不可修改的视图**。

*   `static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c)`
*   `static <T> Set<T> unmodifiableSet(Set<? extends T> s)`
*   `static <T> List<T> unmodifiableList(List<? extends T> list)`
*   `static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m)`
*   `static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<? extends T> s)`
*   `static <K,V> SortedMap<K,V> unmodifiableSortedMap(SortedMap<? extends K, ? extends V> m)`
*   `static <T> NavigableSet<T> unmodifiableNavigableSet(NavigableSet<? extends T> s)` (Java 6+)
*   `static <K,V> NavigableMap<K,V> unmodifiableNavigableMap(NavigableMap<? extends K, ? extends V> m)` (Java 6+)

*   **工作原理：**
    *   返回的包装集合会重写所有修改操作的方法 (如 `add`, `remove`, `set`, `clear`, `put` 等)，使其抛出 `UnsupportedOperationException`。
    *   只读操作 (如 `get`, `size`, `contains`, `iterator` 等) 会委托给底层集合。
*   **视图特性：**
    *   返回的是**视图 (view)**，不是副本。如果底层的原始集合被修改了，这个不可修改的视图也会反映这些变化。
    *   **创建真正的不可变集合：** 如果你想要一个内容完全固定的不可变集合，你需要：
        1.  先创建一个可变集合的副本 (例如，`new ArrayList<>(originalList)`)。
        2.  然后用 `Collections.unmodifiableXxx()` 包装这个副本。
        3.  确保不再有任何引用指向这个副本（除了通过不可修改包装器）。
    *   **Java 9+ `List.of()`, `Set.of()`, `Map.of()`：** Java 9 引入了更方便、更高效的方式来创建**真正的、紧凑的、不可变的集合实例** (而不是视图)。这些静态工厂方法通常是创建不可变集合的首选。

*   **用途：**
    *   防御性编程：当一个方法返回一个集合给调用者，但不希望调用者修改它时。
    *   创建常量集合。
    *   多线程环境下，如果一个集合在创建后不再改变，可以发布为其不可修改视图，以保证线程安全 (因为没有写操作)。

#### **8. 空集合与单例集合 (Empty and Singleton Collections)**

这些方法返回特殊的、通常是不可变的空集合或只包含一个元素的集合。它们有助于避免创建不必要的临时小集合对象，并减少 `null` 检查。

*   **空集合 (Immutable)：**
    *   `static <T> List<T> emptyList()`
    *   `static <T> Set<T> emptySet()`
    *   `static <K,V> Map<K,V> emptyMap()`
    *   `static <T> Iterator<T> emptyIterator()` (Java 7+)
    *   `static <T> ListIterator<T> emptyListIterator()` (Java 7+)
    *   `static <T> Enumeration<T> emptyEnumeration()` (Java 7+)
    *   返回的空集合是不可变的，并且通常是序列化安全的、类型安全的。

*   **单例集合 (Immutable)：**
    *   `static <T> List<T> singletonList(T o)`: 返回一个只包含指定对象的不可变列表。
    *   `static <T> Set<T> singleton(T o)`: (方法名是 `singleton` 而不是 `singletonSet`) 返回一个只包含指定对象的不可变集。
    *   `static <K,V> Map<K,V> singletonMap(K key, V value)`: 返回一个只包含指定键值对的不可变映射。

    ```java
    List<String> noNames = Collections.emptyList();
    // noNames.add("test"); // UnsupportedOperationException

    Set<Integer> justOne = Collections.singleton(42);
    // justOne.add(1); // UnsupportedOperationException
    ```

#### **9. 类型安全的动态检查视图 (Checked Collection Wrappers)**

这些方法用于在运行时动态检查添加到集合中的元素类型，主要用于与遗留的、未使用泛型的代码交互时，提供额外的类型安全保障。

*   `static <E> Collection<E> checkedCollection(Collection<E> c, Class<E> type)`
*   `static <E> List<E> checkedList(List<E> list, Class<E> type)`
*   (类似方法 для `Set`, `Map`, `Queue`, `SortedSet`, `SortedMap`, `NavigableSet`, `NavigableMap`)

*   **工作原理：** 返回一个包装集合，该集合会在尝试添加不兼容类型的元素时（即不是 `type` 的实例）立即抛出 `ClassCastException`。
*   **使用场景：**
    *   当你的泛型集合需要传递给一个接受原始类型 (raw type) 集合的旧 API 时，你可以用 `checkedXxx` 包装一下，以确保旧 API 不会错误地插入不兼容类型的元素。
    *   在现代使用泛型的代码中，编译器通常已经提供了足够的类型检查，所以这些方法用得相对较少。

#### **10. 其他方法**

*   `static <E> Enumeration<E> enumeration(Collection<E> c)`: 返回指定集合的枚举 (Enumeration)。`Enumeration` 是一个比 `Iterator` 更老的迭代接口，主要用于兼容旧 API。
*   `static <T> ArrayList<T> list(Enumeration<T> e)`: 返回一个 `ArrayList`，其中包含由指定枚举返回的元素，顺序与枚举返回的顺序相同。
*   `static <E> Comparator<E> reverseOrder()`: 返回一个比较器，它施加了实现 `Comparable` 接口的对象集合的自然顺序的逆序。
*   `static <T> Comparator<T> reverseOrder(Comparator<T> cmp)`: 返回一个比较器，它施加了指定比较器的逆序。
*   `static <T> Collection<T> newSetFromMap(Map<T, Boolean> map)` (Java 6+): 返回由指定映射支持的 Set。Set 中的元素是映射的键，所有对 Set 的操作都会直接写入底层的 Map。这对于创建自定义 Set 实现很有用 (例如，创建一个并发的 Set，其底层是 `ConcurrentHashMap`)。
*   `static <E> Queue<E> asLifoQueue(Deque<E> deque)` (Java 6+): 将 `Deque` 视图作为 LIFO (后进先出) `Queue` 返回。`add` 映射到 `push`，`remove` 映射到 `pop` 等。

---

### `java.util.Arrays` (回顾与集合相关部分)

我们之前在学习数组时已经详细讨论过 `Arrays` 类，这里快速回顾一下它与集合框架交互最紧密的方法：

*   **`static <T> List<T> asList(T... a)`:**
    *   返回一个由指定数组支持的**固定大小的 `List`**。
    *   **重要：**
        *   返回的 `List` **不是** `java.util.ArrayList`，而是 `Arrays` 类的内部类。
        *   对返回 `List` 的修改 (如 `set()`) 会反映到原始数组中，反之亦然。
        *   **不支持 `add()` 和 `remove()`** (会抛 `UnsupportedOperationException`)。
        *   如果参数是基本类型数组 (如 `int[]`)，它会创建一个只包含该数组对象本身作为唯一元素的 `List<int[]>`，而不是 `List<Integer>`。需要先将基本类型数组转换为包装类型数组或使用 Stream API。

---

**总结与重要性：**

*   `Collections` 类是 Java 集合框架的瑞士军刀，提供了大量方便的静态方法来处理集合。
*   熟练掌握这些方法（如排序、同步包装、不可修改包装、空/单例集合）可以极大地简化代码并提高代码质量。
*   对于线程安全，现代 Java 更倾向于使用 `java.util.concurrent` 包下的并发集合，但 `Collections.synchronizedXxx()` 仍然在某些情况下有用。
*   对于不可变集合，Java 9+ 的 `List.of()`, `Set.of()`, `Map.of()` 是更现代和高效的选择，而 `Collections.unmodifiableXxx()` 返回的是视图。
*   `Arrays.asList()` 是一个方便但有坑的方法，务必注意其返回列表的特性。