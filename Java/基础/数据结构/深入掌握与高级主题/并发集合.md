并发集合是 Java 中一个非常重要且实用的话题，尤其在现代多核处理器和高并发应用日益普及的背景下。

我们将深入探讨 `java.util.concurrent` 包中提供的并发集合类，它们是专门为多线程环境设计的，旨在提供比传统同步包装器 (`Collections.synchronizedXxx()`) 更好的性能和可伸缩性。

---

### 并发集合 (`java.util.concurrent` 包)

**为什么需要并发集合？**

传统的 `java.util` 包中的集合类（如 `ArrayList`, `HashMap`）是**线程不安全的**。如果在多线程环境中不加控制地共享和修改这些集合，会导致数据不一致、`ConcurrentModificationException` 等问题。

`Collections.synchronizedXxx()` 方法可以将普通集合包装成线程安全的版本，但它们通常通过在每个方法（包括迭代器相关方法外的访问方法）上使用**粗粒度的锁 (例如，对整个集合对象加锁)** 来实现同步。这种方式简单直接，但在高并发场景下，会导致严重的**性能瓶颈**，因为同一时间只有一个线程能访问集合，大大降低了并发度。

`java.util.concurrent` 包中的并发集合类采用了更高级的并发控制技术，如：

*   **细粒度锁 (Fine-grained locking)：** 例如 `ConcurrentHashMap` 中的分段锁 (Segment-based locking, JDK 7 及之前) 或节点锁 (Node-level locking, JDK 8+)。
*   **无锁算法 (Lock-free algorithms)：** 基于 CAS (Compare-And-Swap) 原子操作，如 `ConcurrentLinkedQueue`。
*   **写时复制 (Copy-On-Write)：** 如 `CopyOnWriteArrayList` 和 `CopyOnWriteArraySet`。

这些技术旨在**减少锁竞争，提高并发访问的吞吐量和可伸缩性**。

**核心并发集合类概览：**

我们将重点介绍以下几类：

1.  **`ConcurrentMap<K, V>` 接口及其主要实现 `ConcurrentHashMap<K, V>`**
2.  **`CopyOnWriteArrayList<E>` 和 `CopyOnWriteArraySet<E>`**
3.  **`BlockingQueue<E>` 接口及其各种实现** (如 `ArrayBlockingQueue`, `LinkedBlockingQueue`, `PriorityBlockingQueue`, `SynchronousQueue`, `DelayQueue`)
4.  **`ConcurrentLinkedQueue<E>` 和 `ConcurrentLinkedDeque<E>`**
5.  **`ConcurrentSkipListMap<K, V>` 和 `ConcurrentSkipListSet<E>`**

---

### 1. `ConcurrentHashMap<K, V>`

`ConcurrentHashMap` 是 `HashMap` 的线程安全版本，并且提供了比 `Collections.synchronizedMap(new HashMap<>())` 或 `Hashtable` (已过时) 好得多的并发性能。

*   **关键特性：**
    *   **线程安全：** 专为并发访问设计。
    *   **高性能并发：** 允许多个读线程同时访问，并且在一定程度上允许多个写线程同时操作不同的数据段/节点。
    *   **弱一致性迭代器 (Weakly Consistent Iterators)：**
        *   `ConcurrentHashMap` 的迭代器（通过 `keySet().iterator()`, `values().iterator()`, `entrySet().iterator()` 获取）是**弱一致性**的。
        *   它们**不会抛出 `ConcurrentModificationException`**。
        *   迭代器创建后，可以反映创建时或创建后某些（但不必是所有）对映射的修改。它们保证至少遍历一次创建迭代器时已存在的元素，并且可能（但不保证）反映创建后的修改。
        *   它们不会因为其他线程的并发修改而失败。
    *   **不允许 `null` 键和 `null` 值：** 这点与 `HashMap` 不同。尝试插入 `null` 键或值会导致 `NullPointerException`。这是为了避免歧义，因为 `get(key)` 返回 `null` 可以明确表示键不存在，而不是键存在但映射到 `null`。
    *   **聚合操作的原子性 (JDK 8+)：** Java 8 引入的 `compute*`, `merge`, `forEach`, `search`, `reduce` 等批量操作，在 `ConcurrentHashMap` 中通常是原子执行的（针对单个键的操作）。

*   **内部实现演进 (非常重要)：**

    *   **JDK 7 及之前 (分段锁 - Segment Locking)：**
        *   `ConcurrentHashMap` 内部由一个 `Segment` 数组组成，每个 `Segment` 本质上是一个小的、独立的、线程安全的哈希表 (类似于 `Hashtable`)，它有自己的锁。
        *   默认情况下有 16 个 `Segment` (并发级别 `concurrencyLevel`)。
        *   当操作一个键值对时，会先根据键的哈希值定位到对应的 `Segment`，然后只锁住那个 `Segment`。
        *   这意味着，只要操作的键位于不同的 `Segment` 中，多个写线程就可以并发执行，而不会相互阻塞。读操作在大多数情况下不需要加锁。
        *   `size()` 操作比较昂贵，因为它需要汇总所有 `Segment` 的大小，可能需要锁住所有 `Segment` 或使用不精确的估计。

    *   **JDK 8 及之后 (CAS + `synchronized` 节点锁)：**
        *   **取消了 `Segment` 数组，回归到与 `HashMap` 类似的单个哈希表结构 (Node[] table)。**
        *   **锁的粒度更细：** 锁不再是针对整个 `Segment`，而是针对哈希表中的**每个桶的头节点 (Node)**。
        *   **写操作同步：**
            *   如果桶为空，使用 **CAS (Compare-And-Swap)** 原子操作尝试插入新节点。
            *   如果桶不为空（发生哈希冲突），则对该桶的**头节点对象使用 `synchronized` 关键字加锁**。这意味着只有当多个线程尝试修改**同一个桶**时才会发生锁竞争。
            *   如果桶中的链表过长，会转换为红黑树以优化查找，树节点的更新也会有相应的同步机制。
        *   **读操作 (如 `get`)：** 大部分情况下是**无锁**的，通过 `volatile` 读取节点内容来保证可见性。
        *   **`size()` 操作优化：** JDK 8 使用了一个 `baseCount` 和一个 `CounterCell[]` 数组来高效地、近似准确地（或在需要时精确地）计算大小，避免了全局锁。
        *   **整体性能提升：** JDK 8+ 的实现在多数情况下比 JDK 7 的分段锁机制有更好的性能和更低内存占用，尤其是在高并发和大量 CPU 核心的场景下。

*   **构造函数：**
    *   `ConcurrentHashMap()`
    *   `ConcurrentHashMap(int initialCapacity)`
    *   `ConcurrentHashMap(int initialCapacity, float loadFactor)`
    *   `ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)`:
        *   `concurrencyLevel` 在 JDK 8+ 中主要是为了向后兼容，它会被用来估算初始表的大小，但不再直接决定段的数量。

*   **适用场景：**
    *   需要高并发、线程安全的键值对存储。
    *   替代 `Hashtable` 或 `Collections.synchronizedMap(new HashMap<>())` 的首选。
    *   非常适合用作缓存实现（尽管更专业的缓存库如 Caffeine, Guava Cache 提供了更多功能）。

---

### 2. `CopyOnWriteArrayList<E>` 和 `CopyOnWriteArraySet<E>`

这两个类提供了通过“写时复制”策略实现的线程安全列表和集合。

*   **写时复制 (Copy-On-Write) 原理：**
    *   **读操作不加锁：** 任何线程读取列表/集合中的数据时，都不需要加锁，可以直接访问内部数组。
    *   **写操作加锁并复制：** 当需要进行修改操作时（如 `add`, `set`, `remove`）：
        1.  获取一个锁，确保只有一个写线程在操作。
        2.  创建一个底层数组的**全新副本**。
        3.  在新副本上执行修改操作。
        4.  将内部指向数组的引用原子性地更新为指向这个新副本。
        5.  释放锁。
    *   这种机制保证了读操作总是访问到一个一致的（可能是旧的）数据快照，而不会被写操作干扰。

*   **`CopyOnWriteArrayList<E>` 特性：**
    *   **线程安全。**
    *   **读操作非常快且无锁**，因为它们直接操作一个不可变的数组快照。
    *   **写操作非常昂贵**，因为每次写都会复制整个底层数组。因此，它适用于**读多写少**的场景。
    *   **迭代器也是弱一致性的快照迭代器：**
        *   迭代器遍历的是创建迭代器时数组的快照。
        *   **不会抛出 `ConcurrentModificationException`。**
        *   迭代器创建后，对列表的修改不会反映在迭代器中。
    *   允许重复元素，保持插入顺序。
    *   `set()` 操作也是写操作，也会复制数组。

*   **`CopyOnWriteArraySet<E>` 特性：**
    *   内部使用一个 `CopyOnWriteArrayList` 来存储元素。
    *   保证元素唯一性（通过在添加时检查）。
    *   其他特性与 `CopyOnWriteArrayList` 类似：线程安全，读快写慢，弱一致性快照迭代器。

*   **适用场景：**
    *   **读操作远多于写操作**的并发场景。
    *   当集合较小，复制成本可以接受时。
    *   例如：事件监听器列表 (Listeners)。监听器列表很少改变，但可能被频繁地迭代调用。
    *   **不适合：** 数据量大，且写操作频繁的场景。

---

### 3. `BlockingQueue<E>` 接口及其实现

`BlockingQueue` 扩展了 `Queue` 接口，增加了**阻塞式的插入和移除**操作。这意味着：

*   当尝试从空队列中获取元素时，获取操作的线程会被阻塞，直到队列中有元素可用。
*   当尝试向已满的队列中添加元素时，添加操作的线程会被阻塞，直到队列中有空间可用。

`BlockingQueue` 是实现**生产者-消费者模式 (Producer-Consumer Pattern)** 的核心组件。

*   **`BlockingQueue<E>` 核心阻塞方法：**
    *   `void put(E e) throws InterruptedException`: 将元素插入队列尾部，如果队列已满，则**阻塞**等待空间可用。
    *   `E take() throws InterruptedException`: 检索并移除队列头部元素，如果队列为空，则**阻塞**等待元素可用。
    *   `boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException`: 在指定时间内尝试插入元素，如果超时前队列仍满，则返回 `false`。
    *   `E poll(long timeout, TimeUnit unit) throws InterruptedException`: 在指定时间内尝试移除并返回头部元素，如果超时前队列仍空，则返回 `null`。

*   **主要实现类：**

    1.  **`ArrayBlockingQueue<E>`:**
        *   **有界 (Bounded)** 阻塞队列，底层基于**数组**实现。
        *   创建时必须指定容量。
        *   FIFO 顺序。
        *   内部使用单个锁 (`ReentrantLock`) 和两个条件变量 (`notEmpty`, `notFull`) 来控制并发。
        *   可以选择公平性策略 (fairness)：`true` 表示等待时间最长的线程优先获得访问权 (吞吐量较低)，`false` (默认) 表示不保证公平性 (吞吐量较高)。

    2.  **`LinkedBlockingQueue<E>`:**
        *   **可选有界 (Optionally-bounded)** 阻塞队列，底层基于**链表**实现。
        *   如果构造时不指定容量，则容量为 `Integer.MAX_VALUE` (近似无界)。
        *   FIFO 顺序。
        *   内部使用两个锁 (`putLock`, `takeLock`) 和相应的条件变量，分别控制生产者和消费者的操作，从而实现了**生产和消费操作的并发执行** (只要队列既不空也不满)。这通常使其在高并发场景下比 `ArrayBlockingQueue` 有更高的吞吐量。

    3.  **`PriorityBlockingQueue<E>`:**
        *   **无界 (Unbounded)** 的阻塞优先级队列，底层基于**优先级堆** (与 `PriorityQueue` 类似)。
        *   元素按自然顺序或指定的 `Comparator` 排序。
        *   `put()` 操作不会阻塞 (因为无界)，但 `take()` 会在队列为空时阻塞。

    4.  **`SynchronousQueue<E>`:**
        *   一个**不存储元素的阻塞队列**。每个插入操作必须等待一个对应的移除操作，反之亦然。
        *   它没有内部容量，甚至没有一个元素可以容纳的空间。
        *   `put(e)` 会阻塞，直到另一个线程调用 `take()`。
        *   `take()` 会阻塞，直到另一个线程调用 `put(e)`。
        *   非常适合实现**直接的线程间传递 (hand-off)** 机制。
        *   可以选择公平性或非公平性。
        *   性能通常很高，因为它避免了数据在队列中的实际存储。

    5.  **`DelayQueue<E extends Delayed>`:**
        *   **无界**阻塞队列，其中的元素只有在其**延迟 (delay) 到期后**才能被取出。
        *   队列的头部是具有“最近”到期时间的 `Delayed` 元素。如果所有元素的延迟都尚未到期，则 `poll()` 将返回 `null`。当元素的 `getDelay(TimeUnit.NANOSECONDS)` 方法返回零或负值时，表示延迟已到期。
        *   元素必须实现 `java.util.concurrent.Delayed` 接口，该接口包含：
            *   `long getDelay(TimeUnit unit)`: 返回此对象相关的剩余延迟时间。
            *   `int compareTo(Delayed other)`: 用于在队列内部排序。
        *   常用于实现定时任务调度、缓存过期等。

    6.  **`LinkedBlockingDeque<E>`:** `LinkedBlockingQueue` 的双端队列版本，支持在两端进行阻塞的插入和移除。

*   **适用场景：**
    *   生产者-消费者模型。
    *   线程池的任务队列 (`ThreadPoolExecutor` 常用 `BlockingQueue` 来存放待执行的任务)。
    *   任何需要在线程间安全传递数据并进行流量控制的场景。

---

### 4. `ConcurrentLinkedQueue<E>` 和 `ConcurrentLinkedDeque<E>`

*   **`ConcurrentLinkedQueue<E>`:**
    *   一个**无界、线程安全**的 FIFO 队列，底层基于**链表**实现。
    *   使用高效的**无锁 (CAS-based) 算法**，通常比 `LinkedBlockingQueue` (在非阻塞场景下) 有更高的并发吞吐量。
    *   `add()`, `offer()`, `poll()`, `peek()` 等操作都是原子性的。
    *   由于是无界的，`offer()` 永远返回 `true` (不会阻塞)。`poll()` 在队列为空时返回 `null`。
    *   迭代器是弱一致性的。
    *   不允许 `null` 元素。
    *   `size()` 方法不是 O(1) 的，它需要遍历整个队列，效率较低。如果需要频繁获取大小，可能不是最佳选择。

*   **`ConcurrentLinkedDeque<E>`:**
    *   `ConcurrentLinkedQueue` 的双端队列版本，支持在两端进行无锁的、线程安全的插入和移除。

*   **适用场景：**
    *   需要高性能、无界、非阻塞的线程安全队列或双端队列时。
    *   当对 `size()` 操作的性能要求不高时。

---

### 5. `ConcurrentSkipListMap<K, V>` 和 `ConcurrentSkipListSet<E>`

*   **`ConcurrentSkipListMap<K, V>`:**
    *   一个**线程安全、可排序**的 `ConcurrentNavigableMap` 实现，底层基于**跳表 (Skip List)** 数据结构。
    *   **跳表**是一种概率性数据结构，它通过维护多层链表来实现类似平衡树的 O(log n) 平均查找、插入、删除性能，但实现上通常比平衡树简单。
    *   键根据自然顺序或提供的 `Comparator` 排序。
    *   提供了 `ConcurrentNavigableMap` 的所有导航方法 (如 `lowerEntry`, `ceilingKey`, `subMap` 等)，这些操作也是线程安全的。
    *   迭代器是弱一致性的。
    *   不允许 `null` 键，但允许 `null` 值。

*   **`ConcurrentSkipListSet<E>`:**
    *   一个线程安全、可排序的 `NavigableSet` 实现，内部使用 `ConcurrentSkipListMap` (元素作为键，值为一个固定的 PRESENT 对象)。
    *   特性与 `ConcurrentSkipListMap` 类似。

*   **适用场景：**
    *   当你需要一个**线程安全的、有序的** `Map` 或 `Set`，并且期望有较好的并发性能时。
    *   当需要并发地执行范围查询或导航操作时。
    *   可以作为 `Collections.synchronizedSortedMap/Set(new TreeMap/Set<>())` 的高性能替代品。

---

**总结与选择并发集合的考量：**

| 需求/场景                                  | 推荐并发集合 (可能选项)                                        | 关键原因                                                              |
| ------------------------------------------ | ------------------------------------------------------------- | --------------------------------------------------------------------- |
| **线程安全的通用 Map (无序)**                | **`ConcurrentHashMap`**                                       | 高并发性能，JDK 8+ 优化良好                                              |
| **列表，读远多于写**                         | **`CopyOnWriteArrayList`**                                    | 读无锁，写时复制                                                        |
| **Set，读远多于写**                          | **`CopyOnWriteArraySet`**                                     | 同上                                                                  |
| **生产者-消费者，有界队列**                  | `ArrayBlockingQueue`, `LinkedBlockingQueue` (指定容量)          | 阻塞，流量控制                                                          |
| **生产者-消费者，近似无界队列 (FIFO)**       | `LinkedBlockingQueue` (不指定容量)                             | 阻塞，高吞吐量                                                          |
| **生产者-消费者，优先级**                    | `PriorityBlockingQueue`                                       | 按优先级阻塞获取                                                        |
| **线程间直接数据传递 (无缓冲)**              | `SynchronousQueue`                                            | 高效握手                                                              |
| **延迟任务队列**                             | `DelayQueue`                                                  | 按延迟到期顺序获取                                                      |
| **高性能非阻塞无界队列 (FIFO)**              | **`ConcurrentLinkedQueue`**                                   | 无锁算法，高吞吐                                                        |
| **高性能非阻塞无界双端队列**                 | **`ConcurrentLinkedDeque`**                                   | 同上                                                                  |
| **线程安全的有序 Map (可导航)**              | **`ConcurrentSkipListMap`**                                   | 跳表实现，支持并发有序操作                                                |
| **线程安全的有序 Set (可导航)**              | **`ConcurrentSkipListSet`**                                   | 同上                                                                  |
| **需要避免 `null` 键/值 (Map)**              | `ConcurrentHashMap`, `ConcurrentSkipListMap`                  | 设计如此                                                              |
| **迭代时不允许 `ConcurrentModificationException`** | 大多数并发集合的迭代器都是弱一致性或快照式的，不会抛此异常 | 为并发设计                                                            |

**重要提示：**

*   **迭代器的一致性：** 大多数并发集合的迭代器是“弱一致性 (weakly consistent)”或“快照式 (snapshot-style)”的，它们不会抛出 `ConcurrentModificationException`，但可能不反映迭代开始后的所有修改。
*   **原子复合操作：** 对于需要“检查后执行 (check-then-act)”的复合操作 (例如，如果键不存在则添加)，并发集合通常提供了原子性的方法（如 `putIfAbsent`，`computeIfAbsent`，`replace` 等）来避免竞态条件。应优先使用这些原子方法，而不是自己组合非原子操作并加锁。
*   **性能权衡：** 没有一种并发集合是万能的。选择时需要根据具体的读写比例、数据量、对顺序的要求、是否需要阻塞等因素进行权衡。

---

这些工具对于构建高性能、高并发的 Java 应用至关重要。