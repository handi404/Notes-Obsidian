聊聊 Java 中的**集合工厂方法 (Collection Factory Methods)**。这绝对是 Java 9 引入的一个非常受欢迎且实用的特性，极大地提升了我们创建小型、不可变集合的便捷性和代码的可读性。

**一、为什么需要集合工厂方法？ (痛点)**

在 Java 9 之前，如果你想创建一个包含少量元素的集合，通常有以下几种方式，但都略显繁琐：

1.  **`Arrays.asList()` 配合构造函数：**
    ```java
    // List
    List<String> oldList = new ArrayList<>(Arrays.asList("Java", "Python", "Go"));
    // Set
    Set<String> oldSet = new HashSet<>(Arrays.asList("Java", "Python", "Go"));
    ```
    注意：`Arrays.asList()` 返回的是一个固定大小的 `List`，对其进行添加或删除操作会抛出 `UnsupportedOperationException`。而且，它仍然是可变的（可以修改元素）。

2.  **逐个添加：**
    ```java
    List<String> anotherOldList = new ArrayList<>();
    anotherOldList.add("Java");
    anotherOldList.add("Python");
    anotherOldList.add("Go");

    Map<String, Integer> oldMap = new HashMap<>();
    oldMap.put("One", 1);
    oldMap.put("Two", 2);
    ```
    这种方式代码冗余，尤其当元素不多时。

3.  **双括号初始化 (Double Brace Initialization) - 不推荐：**
    ```java
    // List<String> doubleBraceList = new ArrayList<>() {{
    //     add("Java");
    //     add("Python");
    // }};
    ```
    这种方式实际上是创建了一个匿名内部类，它有一些潜在的序列化问题和内存泄漏风险，并且可读性也并非最佳。

这些老方法不仅代码冗长，而且默认创建的集合都是**可变的 (Mutable)**。很多时候，我们需要的仅仅是一个包含固定元素、后续不会再改变的集合，比如用作常量、配置数据等。

**二、Java 9+ 的集合工厂方法 (核心内容)**

Java 9 在 `List`, `Set`, `Map` 接口中引入了一系列静态的 `of()` 工厂方法，用于方便地创建**不可变的 (Immutable)** 集合实例。

**1. `List.of()`**

```java
// 创建一个空的不可变 List
List<String> emptyList = List.of();

// 创建包含元素的不可变 List
List<String> names = List.of("Alice", "Bob", "Charlie");
// names.add("David"); // 这行会抛出 UnsupportedOperationException
// names.set(0, "Eve"); // 这行也会抛出 UnsupportedOperationException

System.out.println(names); // 输出: [Alice, Bob, Charlie]
```

**2. `Set.of()`**

```java
// 创建一个空的不可变 Set
Set<String> emptySet = Set.of();

// 创建包含元素的不可变 Set
Set<String> languages = Set.of("Java", "Python", "Go");
// languages.add("C++"); // 抛出 UnsupportedOperationException

// 注意：如果尝试用 Set.of() 创建包含重复元素的 Set，会抛出 IllegalArgumentException
// Set<String> duplicateSet = Set.of("Java", "Python", "Java"); // 抛出 IllegalArgumentException

System.out.println(languages); // 输出可能是 (顺序不保证): [Python, Java, Go]
```

**3. `Map.of()` 和 `Map.ofEntries()`**

`Map.of()` 提供多个重载版本，最多支持 10 个键值对。

```java
// 创建一个空的不可变 Map
Map<String, Integer> emptyMap = Map.of();

// 创建包含少量键值对的不可变 Map
Map<String, Integer> scores = Map.of("Alice", 90, "Bob", 85, "Charlie", 95);
// scores.put("David", 80); // 抛出 UnsupportedOperationException

// 注意：如果键重复，会抛出 IllegalArgumentException
// Map<String, Integer> duplicateKeyMap = Map.of("A", 1, "B", 2, "A", 3); // 抛出 IllegalArgumentException

System.out.println(scores); // 输出: {Alice=90, Bob=85, Charlie=95} (Java 9+ Map.of() 保证迭代顺序)
```

如果需要创建超过 10 个键值对的 `Map`，或者键值对是通过某种方式动态生成的，可以使用 `Map.ofEntries()`：

```java
import static java.util.Map.entry; // 静态导入 Map.entry()

Map<String, Integer> largeMap = Map.ofEntries(
    entry("A", 1),
    entry("B", 2),
    entry("C", 3),
    // ...更多 entry
    entry("K", 11)
);
System.out.println(largeMap);
```
`Map.entry(key, value)` 是一个辅助静态方法，用于创建 `Map.Entry` 对象。

**三、关键特性与注意事项 (完美无遗漏)**

1.  **不可变性 (Immutability):**
    *   这是这些工厂方法创建的集合最核心的特性。一旦创建，就不能添加、删除或修改元素。
    *   任何尝试修改的操作（如 `add()`, `remove()`, `set()`, `put()`, `clear()` 等）都会抛出 `UnsupportedOperationException`。
    *   这种不可变性使得集合在并发环境中更安全，也适合用作常量。

2.  **Null 元素/键/值不允许:**
    *   `List.of()` 和 `Set.of()` 不允许传入 `null` 元素。
    *   `Map.of()` 和 `Map.ofEntries()` 不允许传入 `null` 键或 `null` 值。
    *   如果尝试传入 `null`，会立即抛出 `NullPointerException`。这是设计上的选择，旨在避免后续使用中出现 `NullPointerException` 的麻烦，提倡“快速失败”。

3.  **重复元素/键的处理:**
    *   `Set.of()`: 如果传入重复元素，会抛出 `IllegalArgumentException`。
    *   `Map.of()` / `Map.ofEntries()`: 如果传入重复的键，会抛出 `IllegalArgumentException`。
    *   `List.of()`: 允许重复元素，因为 `List` 本身就支持重复。

4.  **序列化:**
    *   这些不可变集合是可序列化的，前提是它们包含的元素也是可序列化的。

5.  **迭代顺序:**
    *   `List.of()`: 元素顺序与传入参数的顺序一致。
    *   `Set.of()`: 元素的迭代顺序是**不确定**的（虽然对于少量元素，实际实现可能表现出某种固定顺序，但不应依赖）。
    *   `Map.of()` / `Map.ofEntries()`: 键值对的迭代顺序是**基于参数传入的顺序**。这一点与传统的 `HashMap` (无序) 和 `LinkedHashMap` (插入顺序) 不同，`Map.of()` 创建的 `Map` 是有序的。

6.  **底层实现:**
    *   这些工厂方法返回的并不是我们熟知的 `ArrayList`, `HashSet`, `HashMap` 的实例。它们是 JDK 内部专门实现的、高度优化的、紧凑的不可变集合类型（例如，`ImmutableCollections.ListN`, `ImmutableCollections.SetN`, `ImmutableCollections.MapN` 等）。

**四、优势总结**

1.  **简洁性 (Conciseness):** 代码量大大减少，一行代码即可创建并初始化集合。
2.  **可读性 (Readability):** 代码意图更清晰，一眼就能看出是在创建一个固定的集合。
3.  **安全性 (Safety):**
    *   **不可变性**：避免了集合在后续代码中被意外修改，尤其在多线程环境或作为 API 返回值时非常有用。
    *   **Null 安全**：创建时就禁止 `null`，减少了后续的 `NullPointerException` 风险。
    *   **类型安全**：利用了泛型。
4.  **空间效率 (Space Efficiency):** 通常比对应的可变集合更节省内存，因为它们可以针对固定数量的元素进行优化。

**五、应用场景与扩展**

*   **定义常量集合:**
    ```java
    public static final List<String> SUPPORTED_FORMATS = List.of("JPEG", "PNG", "GIF");
    public static final Set<Character> VOWELS = Set.of('a', 'e', 'i', 'o', 'u');
    ```

*   **单元测试中的测试数据:**
    ```java
    // assertEquals(expectedOutput, process(List.of("input1", "input2")));
    ```

*   **方法返回值 (防御性拷贝的替代):** 当方法需要返回一个集合，并且不希望调用者修改它时，这些工厂方法是绝佳选择。
    ```java
    public List<String> getSupportedFeatures() {
        // ... 内部可能是可变集合
        List<String> features = new ArrayList<>();
        features.add("FeatureA");
        features.add("FeatureB");
        // return Collections.unmodifiableList(features); // Java 8 及以前的方式
        return List.copyOf(features); // Java 10+ 的方式，更推荐
        // 或者如果数据是固定的，直接：
        // return List.of("FeatureA", "FeatureB");
    }
    ```
    注意：`List.copyOf()`, `Set.copyOf()`, `Map.copyOf()` 是 Java 10 引入的，它们接受一个已有的集合作为参数，并返回该集合的一个不可变副本。如果源集合本身已经是不可变的且符合要求，`copyOf` 方法可能会直接返回源集合，避免不必要的拷贝。

*   **替代 `Collections.unmodifiableXxx()`:**
    在 Java 9 之前，创建不可变集合通常使用 `Collections.unmodifiableList(new ArrayList<>(Arrays.asList(...)))` 这样的冗长方式。现在 `List.of()` 等方法简洁得多。
    对于已有的可变集合，如果想得到其不可变视图（注意是视图，不是拷贝），仍然可以使用 `Collections.unmodifiableXxx()`。但如果想得到一个真正的不可变拷贝，Java 10+ 的 `List.copyOf()`, `Set.copyOf()`, `Map.copyOf()` 是更好的选择。

*   **与 Stream API 结合:**
    虽然集合工厂方法主要用于创建包含少量固定元素的集合，但 Stream API 提供了更灵活的创建不可变集合的方式，特别是从已有数据源转换时：
    ```java
    List<String> source = ...;
    List<String> immutableList = source.stream()
                                       .filter(s -> s.length() > 3)
                                       .collect(Collectors.toUnmodifiableList()); // Java 10+
    Set<String> immutableSet = source.stream()
                                     .map(String::toUpperCase)
                                     .collect(Collectors.toUnmodifiableSet()); // Java 10+
    // Map<K, V> immutableMap = source.stream()
    //                              .collect(Collectors.toUnmodifiableMap(keyMapper, valueMapper)); // Java 10+
    ```
    `Collectors.toUnmodifiableList()`, `toUnmodifiableSet()`, `toUnmodifiableMap()` 同样返回不可变集合。

**六、何时不适用？**

*   当集合需要在创建后被修改时。
*   当集合中需要存储 `null` 元素/键/值时。
*   当需要创建包含大量元素的 `Set` 或 `Map` 并关心重复元素/键的处理方式时（例如，如果希望忽略重复而不是抛异常，则不能直接用 `Set.of()` 或 `Map.of()`）。

总而言之，Java 9 引入的集合工厂方法 (`List.of()`, `Set.of()`, `Map.of()`, `Map.ofEntries()`) 是现代 Java 开发中创建小型、固定、不可变集合的首选方式。它们让代码更简洁、更安全、更易读。后续 Java 10 引入的 `copyOf` 方法和 `Collectors.toUnmodifiableXxx` 则进一步完善了不可变集合的生态。