
# Spring事务管理（非 Spring Boot）详解

## 1. 数据库事务简介

数据库事务（Database Transaction）是一系列操作的逻辑单元，具有 **ACID** 四大特性：原子性、一致性、隔离性和持久性。例如，在转账场景中，需要同时执行从账户 A 减钱和向账户 B 加钱两步操作，这两步要么都执行成功，要么都不生效，以保证资金一致性。下例通过 SQL 演示事务操作：

```sql
-- 示例：从账户1转100元到账户2
BEGIN;  -- 开启事务
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT; -- 提交事务
-- 如果任一步骤失败，应执行 ROLLBACK 回滚
```

- **原子性**：事务是不可再分的整体，内部操作要么全部成功要么全部失败。
    
- **一致性**：事务执行前后，数据必须保持一致性约束。即使事务失败，系统状态也应恢复到一致状态。
    
- **隔离性**：并发事务之间相互隔离，一个事务的中间状态对其他事务不可见。
    
- **持久性**：一旦事务提交，其对数据的修改就是持久的，不会因系统故障而丢失。
    

## 2. Spring中的事务管理方式

Spring 框架提供两种事务管理方式：**声明式事务**和**编程式事务**。

- **声明式事务（Declarative Transaction）**：通过配置（XML 或注解）将事务属性与业务方法关联，Spring 用 AOP 代理自动开启、提交或回滚事务，将事务管理“解耦”出业务逻辑。在大部分应用场景下，声明式事务是首选，因为它使代码简洁易维护。
    
- **编程式事务（Programmatic Transaction）**：由开发者在代码中手动使用 Spring 的事务 API（如 `TransactionTemplate` 或 `PlatformTransactionManager`）来控制事务。当需要根据运行时条件决定事务边界或需显式指定事务名称时，可以使用编程式事务。编程式方式通常用于事务操作较少或需要灵活控制的场景。
    

## 3. 事务管理的配置方式

### 3.1 纯 XML 配置方式（使用 `<tx:advice>` 和 AOP）

在纯 XML 配置中，需要定义事务管理器和事务通知（`<tx:advice>`），并通过 AOP 切面将其应用到目标方法上。例如：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans 
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/tx 
           https://www.springframework.org/schema/tx/spring-tx.xsd
           http://www.springframework.org/schema/aop 
           https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 定义数据源和事务管理器 -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <!-- 配置数据库连接属性 -->
    </bean>
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- 声明事务通知，指定事务管理器和事务属性 -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <!-- 所有以 get 开头的方法使用只读事务 -->
            <tx:method name="get*" read-only="true"/>
            <!-- 其他方法使用默认事务属性（Propagation=REQUIRED、readOnly=false） -->
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!-- 配置 AOP 切入点，应用事务通知到所有服务层方法 -->
    <aop:config>
        <aop:pointcut id="serviceMethods" expression="execution(* com.example.service.*.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="serviceMethods"/>
    </aop:config>
</beans>
```

上述配置中，`<tx:advice>` 定义了对目标方法的事务属性，`transaction-manager` 指定使用的 `PlatformTransactionManager`。`<tx:method>` 可以根据方法名模式配置传播行为、隔离级别、只读等属性。在 `<aop:advisor>` 中通过切点表达式将事务通知应用到相应的类或方法上。这种方式无需修改业务代码，只需在配置层面声明即可。

**更新 XML 配置**
在纯 XML 配置中，如果想要在不改动 Java 代码的情况下直接识别并应用 `@Transactional` 注解，还需要在 `<beans>` 中加入：

```xml
<!-- 定义数据源和事务管理器 -->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- 配置数据库连接属性 -->
</bean>
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!-- 启用基于注解的事务注解识别 -->
<tx:annotation-driven transaction-manager="txManager"/>

<!-- springAOP自动代理 spring事务基于AOP所以事务的注解开发需要开启AOP的自动代理 --> 
<aop:aspectj-autoproxy />
```

解释：

- `<tx:annotation-driven>` 会自动为所有被 `@Transactional` 注解的方法创建 AOP 拦截器，拦截并在方法调用前后分别开启、提交或回滚事务。
    
- 默认它会对所有带有 `@Transactional` 的 `public` 方法生效；如果需要对非 `public` 方法也生效，必须额外配置 `proxy-target-class="true"` 或使用 AspectJ 模式。

这样一来，你就既可以在 XML 中通过 `<tx:advice>`/`<aop:advisor>` 按命名规则管理事务，也可以直接在 Service 层用 `@Transactional` 注解来声明事务。

### 3.2 基于 Java 注解的配置方式（`@EnableTransactionManagement` 和配置类）

在纯 Java 配置中，可以通过 `@EnableTransactionManagement` 注解开启事务管理支持。例如：

```java
@Configuration
@EnableTransactionManagement  // 启用注解事务管理
public class AppConfig {
    @Bean
    public DataSource dataSource() {
        // 配置并返回数据源
    }

    @Bean
    public PlatformTransactionManager txManager(DataSource dataSource) {
        // 定义事务管理器，并注入数据源
        return new DataSourceTransactionManager(dataSource);
    }
}
```

上例通过 `@EnableTransactionManagement` 和 `@Configuration` 将事务管理配置为 Spring 容器的一部分。随后在业务类（如 Service）中使用 `@Transactional` 注解即可实现事务拦截，无需 XML 配置。注意：默认情况下，只有 `public` 方法可被代理拦截，且事务应用在由外部调用的情况下（内部自调用不会触发事务）。

## 4. 高级配置选项

- **事务传播行为（Propagation）**：定义当前方法在存在或不存在事务时的执行策略。常用类型包括：
    
    - `REQUIRED`（默认）：支持当前事务；如果没有，则新建事务。
        
    - `REQUIRES_NEW`：新建事务，并挂起当前事务（如果存在的话）。
        
    - `SUPPORTS`：支持当前事务；如果没有事务，就以非事务方式执行。
        
    - `MANDATORY`：支持当前事务；如果没有事务则抛出异常。
        
    - `NOT_SUPPORTED`：以非事务方式执行；如果当前有事务，则将其挂起。
        
    - `NEVER`：以非事务方式执行；如果当前有事务，则抛出异常。
        
    - `NESTED`：如果当前有事务，则在嵌套事务（保存点）中执行；否则行为等同于 `REQUIRED`。
        
- **隔离级别（Isolation）**：定义事务可见其他事务未提交数据的程度，对应 JDBC 的隔离级别。常用有：
    
    - `DEFAULT`：使用底层数据库默认隔离级别。
        
    - `READ_UNCOMMITTED`：允许脏读、不可重复读和幻读。
        
    - `READ_COMMITTED`：禁止脏读，但允许不可重复读和幻读。
        
    - `REPEATABLE_READ`：禁止脏读和不可重复读，但允许幻读。
        
    - `SERIALIZABLE`：禁止脏读、不可重复读和幻读。
        
- **回滚规则（rollbackFor、noRollbackFor）**：默认情况下，Spring 仅对未检查的运行时异常（`RuntimeException` 及其子类）或 `Error` 执行回滚，而对检查异常（如 `Exception`）不回滚。可以通过配置指定哪些异常类型需要回滚或不回滚：
    
    - 在注解方式中，使用 `@Transactional(rollbackFor=SomeException.class, noRollbackFor=OtherException.class)`。
        
    - 在 XML 配置中，使用 `<tx:method rollback-for="com.example.MyException" no-rollback-for="com.example.OtherException"/>`。  
        例如：`@Transactional(rollbackFor=Exception.class)` 会使检查异常也触发回滚。
        
- **只读事务、超时等**：
    
    - `readOnly`：标志事务为只读，可用于优化（如 Hibernate 可避免脏检查）。在注解中可写为 `@Transactional(readOnly=true)`；在 XML 中可在 `<tx:method>` 上设置 `read-only="true"`。
        
    - `timeout`：事务超时时间（以秒为单位），超过指定时间 Spring 会自动回滚事务。在注解中使用 `@Transactional(timeout=30)`；在 XML 中使用 `<tx:method timeout="30"/>`。
        

## 5. 示例代码

### 5.1 XML 配置示例

```xml
<!-- Spring XML 配置（示例片段） -->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
    <!-- 数据库连接配置 -->
</bean>
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
        <tx:method name="get*" read-only="true"/>
        <tx:method name="*"/>
    </tx:attributes>
</tx:advice>

<aop:config>
    <aop:pointcut id="serviceMethods" expression="execution(* com.example.service.*.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="serviceMethods"/>
</aop:config>
```

以上配置使得 `com.example.service` 包下所有以 `get` 开头的方法使用只读事务，其他方法使用默认事务。配合业务代码：

```java
@Service
public class OrderServiceImpl implements OrderService {
    // 由 Spring AOP 拦截，自动开启/提交事务
    public Order getOrder(int id) { /* 查询操作 */ }
    public void createOrder(Order o) { /* 插入操作 */ }
}
```

### 5.2 Java 注解配置示例

```java
@Configuration
@EnableTransactionManagement  // 启用基于注解的事务管理
public class AppConfig {
    @Bean
    public DataSource dataSource() { /* 返回配置好的数据源 */ }

    @Bean
    public PlatformTransactionManager txManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

```java
@Service
public class UserService {
    // 调用时自动开启事务
    @Transactional(readOnly = true)
    public User findUser(int id) { /* 查询操作 */ }

    @Transactional(propagation = Propagation.REQUIRES_NEW,
                   isolation = Isolation.SERIALIZABLE,
                   rollbackFor = Exception.class,
                   timeout = 30)
    public void updateUser(User u) { /* 更新操作 */ }
}
```

在上述示例中，`@Transactional` 注解可灵活指定传播行为、隔离级别、回滚规则、只读及超时等属性。

### 5.3 编程式事务示例

```java
public class AccountService {
    private final TransactionTemplate txTemplate;

    public AccountService(PlatformTransactionManager txManager) {
        this.txTemplate = new TransactionTemplate(txManager);
    }

    public void transferMoney(int fromId, int toId, BigDecimal amount) {
        // 使用 TransactionTemplate 编程式管理事务
        txTemplate.execute(status -> {
            // 事务内的数据库操作
            withdraw(fromId, amount);
            deposit(toId, amount);
            return null;
        });
    }
}
```

```java
public class AccountServiceManual {
    private final PlatformTransactionManager txManager;

    public AccountServiceManual(PlatformTransactionManager txManager) {
        this.txManager = txManager;
    }

    public void transferMoney(int fromId, int toId, BigDecimal amount) {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        TransactionStatus status = txManager.getTransaction(def);
        try {
            // 事务内的数据库操作
            withdraw(fromId, amount);
            deposit(toId, amount);
            txManager.commit(status);
        } catch (RuntimeException ex) {
            // 手动回滚并重新抛出异常
            txManager.rollback(status);
            throw ex;
        }
    }
}
```

### 5.4 注解事务的常见用法示例

```java
@Service
public class ProductService {
    @Transactional  // 默认事务（Propagation.REQUIRED）
    public void addProduct(Product p) { /* 新增操作 */ }

    @Transactional(readOnly = true)  // 只读事务，用于查询
    public Product findProduct(int id) { /* 查询操作 */ }

    @Transactional(propagation = Propagation.REQUIRES_NEW,
                   rollbackFor = IllegalArgumentException.class)
    public void updateStock(int productId, int qty) {
        if (qty < 0) throw new IllegalArgumentException("数量不能为负");
        // 更新库存操作
    }
}
```

## 6. 适用的 Spring 版本

Spring 框架自 2.5 版本以来就支持注解式事务，本文所述的事务管理配置在 Spring 4.x 和 5.x 系列中均可使用，无需依赖 Spring Boot 的自动配置特性。只要在非 Spring Boot 的项目中正确配置 `DataSource`、`TransactionManager` 以及相应的事务拦截器（XML 或注解），即可实现事务功能。

**参考资料：** Spring 官方文档及社区资料 [cnblogs.com](https://www.cnblogs.com/ysocean/p/7617620.html#:~:text=%E2%91%A0%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89%EF%BC%9A%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%8C%E7%94%B1%E4%B8%80%E7%B3%BB%E5%88%97%E5%8A%A8%E4%BD%9C%E7%BB%84%E6%88%90%E3%80%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E7%A1%AE%E4%BF%9D%E5%8A%A8%E4%BD%9C%E8%A6%81%E4%B9%88%E5%85%A8%E9%83%A8%E5%AE%8C%E6%88%90%EF%BC%8C%E8%A6%81%E4%B9%88%E5%AE%8C%E5%85%A8%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E3%80%82)[docs.spring.io](https://docs.spring.io/spring-framework/reference/data-access/transaction/tx-decl-vs-prog.html#:~:text=Programmatic%20transaction%20management%20is%20usually,programmatic%20approach%20to%20transaction%20management)[docs.spring.io](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/rolling-back.html#:~:text=Rollback%20rules%20may%20be%20configured,attributes%2C%20which%20allow%20rules%20to)[docs.spring.io](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html#:~:text=)[docs.spring.vmware.com](https://docs.spring.vmware.com/spring-framework/docs/6.0.27/javadoc-api/org/springframework/transaction/annotation/Isolation.html#:~:text=A%20constant%20indicating%20that%20dirty,and%20phantom%20reads%20can%20occur)[docs.spring.vmware.com](https://docs.spring.vmware.com/spring-framework/docs/6.0.27/javadoc-api/org/springframework/transaction/annotation/Isolation.html#:~:text=A%20constant%20indicating%20that%20dirty,and%20phantom%20reads%20are%20prevented) 等。


## 示例

### 事务配置
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <context:property-placeholder location="jdbc.properties"/>

    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <bean id="accountDao" class="com.sqsf.dao.impl.AccountDaoImpl">
        <property name="jdbcTemplate" ref="jdbcTemplate"/>
    </bean>

    <bean id="accountService" class="com.sqsf.service.impl.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"/>
    </bean>

    <!--平台事务管理器
    将平台事务管理器交由spring管理 后续spring才能使用其为我们进行事务管理
    -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--事务增强配置
    用于定义事务的配置信息 隔离级别 传播行为 超时时间 是否只读
    transaction-manager="transactionManager" 可以不写
    会自动识别当前spring中的事务管理器
    -->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <!-- 实际开发中可能需要为不同的方法进行不同的事务配置 -->
            <tx:method name="zz" isolation="DEFAULT" propagation="REQUIRED" timeout="-1" read-only="false"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!--事务的aop增强
    事务本质基于AOP 所以使用切点表达式对需要进行事务管理的方法进行切入
    -->
    <aop:config>
        <aop:pointcut id="myPointcut" expression="execution(* com.sqsf.service.impl.*.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="myPointcut"></aop:advisor>
    </aop:config>
</beans>
```

### 事务注解配置及使用
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx 
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <context:property-placeholder location="jdbc.properties"/>

    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- springIOC组件扫描 用于扫描dao与service实现类对象并进行注入 -->
    <context:component-scan base-package="com.sqsf"/>

    <!-- springAOP自动代理 spring事务基于AOP所以事务的注解开发需要开启AOP的自动代理 -->
    <aop:aspectj-autoproxy />

    <!-- 平台事务管理器对象是spring进行事务管理最核心的对象 事务的管理功能都是由该对象提供 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- spring事务的注解配置
     等价于<tx:advice id="myTx" transaction-manager="transactionManager">
     -->
    <tx:annotation-driven transaction-manager="transactionManager"/>
</beans>
```

```java
@Service("accountService")  
//如果一个方法中拥有多个事务 配置相同可以将事务注解书写在类上  
//当前类下所有的方法使用同一的事务管理配置  
@Transactional  
public class AccountServiceImpl implements AccountService {  
  
    @Autowired  
    AccountDao accountDao;  
  
    @Override  
    //@Transactional  
    //事务注解 用于标识当前方法需要进行事务管理 等价于切点表达式识别    //可以像配置一样通过对应的属性设置隔离级别 传播属性 超时时间 是否只读    
    @Transactional(isolation = Isolation.DEFAULT,propagation = Propagation.REQUIRED,timeout = -1,readOnly = false)  
    public void zz(String out, String in, double money) {  
        accountDao.updateSubMoneyByName(out, money);  
        System.out.println(1/0);  
        accountDao.updateAddMoneyByName(in, money);  
    }  
}
```