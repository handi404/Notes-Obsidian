系统性地梳理 Controller 中处理请求与响应的所有核心注解。将它们分为五大类，建立一个清晰的知识框架。

这五类就像一个请求处理的流水线：

1.  **控制器定义注解**：首先，得有个“车间”来处理请求。
2.  **请求映射注解**：然后，需要“交通警察”根据请求的 URL、方法等，将其引导到正确的处理方法。
3.  **请求输入注解**：接着，需要“装卸工”从请求中把数据（参数、请求体、头信息等）取出来。
4.  **响应输出注解**：处理完毕后，需要“包装工”来决定如何打包响应数据（比如格式、状态码）。
5.  **功能增强注解**：最后，还有一些“质检员”和“流程优化师”来处理异常、跨域等横切关注点。

---

### 一、控制器定义注解 (Controller Definition)

这类注解定义了一个类是什么类型的控制器。

#### 1. `@Controller`
*   **核心功能**：将一个类标记为 Spring MVC 的控制器，用于处理 HTTP 请求。
*   **详解与应用场景**：
    *   这是最基础的控制器注解。Spring 容器会扫描并实例化被此注解标记的类。
    *   传统上，`@Controller` 返回的是一个**视图名称**（比如 JSP 页面的名字或 Thymeleaf 模板名），由视图解析器（ViewResolver）去渲染成最终的 HTML 页面。
    *   如果你需要在这种模式下返回 JSON/XML 数据，方法上需要额外配合 `@ResponseBody` 注解。
*   **示例**：
    ```java
    @Controller
    public class PageController {
        @GetMapping("/home")
        public String homePage() {
            return "home"; // 返回视图名 home.html
        }
    }
    ```

#### 2. `@RestController`
*   **核心功能**：一个组合注解，相当于 `@Controller` + `@ResponseBody`。
*   **详解与应用场景**：
    *   **现代 Web 开发（尤其是前后端分离）的首选**。它表明这个控制器下的所有方法都默认返回**数据**（如 JSON、XML），而不是视图。
    *   Spring Boot 会通过内置的 `HttpMessageConverter`（默认是 Jackson）将返回的对象自动序列化为 JSON 字符串。
*   **扩展与最佳实践**：开发 RESTful API 时，**永远优先使用 `@RestController`**。这让代码更简洁，意图更明确。
*   **示例**：
    ```java
    @RestController
    @RequestMapping("/api/users")
    public class UserApiController {
        @GetMapping("/{id}")
        public User getUserById(@PathVariable Long id) {
            // Spring Boot 会自动将 User 对象转换为 JSON
            return new User(id, "spring-dev");
        }
    }
    ```

---

### 二、请求映射注解 (Request Mapping)

这类注解将 HTTP 请求精确地映射到具体的处理方法上。

#### 1. `@RequestMapping`
*   **核心功能**：最通用的请求映射注解，可以配置请求的 URL、方法、头信息等。
*   **详解与应用场景**：
    *   可以用在**类级别**，定义所有方法的基础路径。
    *   可以用在**方法级别**，定义方法的完整或部分路径。
    *   **属性**：
        *   `value` 或 `path`：映射的 URL 路径。
        *   `method`：请求方法，如 `RequestMethod.GET`, `RequestMethod.POST`。
        *   `params`：要求请求中必须包含某些参数，如 `params = "myParam=myValue"`。
        *   `headers`：要求请求头中必须包含某些信息，如 `headers = "Content-Type=application/json"`。
        *   `consumes`：指定处理请求的提交内容类型（Content-Type），例如 `application/json`。
        *   `produces`：指定返回的内容类型，仅当请求头中的 `Accept` 类型中包含该指定类型才返回。
*   **最佳实践**：虽然功能强大，但现在更推荐使用下面更具体的快捷注解，代码可读性更高。

#### 2. 快捷映射注解 (HTTP Method Specific Shortcuts)
这些是 `@RequestMapping` 的派生注解，使意图更加清晰。

*   `@GetMapping`：处理 GET 请求。
*   `@PostMapping`：处理 POST 请求。
*   `@PutMapping`：处理 PUT 请求。
*   `@DeleteMapping`：处理 DELETE 请求。
*   `@PatchMapping`：处理 PATCH 请求。

*   **扩展与最佳实践**：**强烈建议使用这些快捷注解**。一眼就能看出方法是用来做什么操作的，符合 RESTful 风格。

*   **示例**：
    ```java
    @RestController
    @RequestMapping("/api/tasks") // 类级别基础路径
    public class TaskController {

        @GetMapping // 映射到 GET /api/tasks
        public List<Task> getAllTasks() { /* ... */ }

        @GetMapping("/{id}") // 映射到 GET /api/tasks/{id}
        public Task getTask(@PathVariable Long id) { /* ... */ }

        @PostMapping // 映射到 POST /api/tasks
        public Task createTask(@RequestBody Task task) { /* ... */ }

        @PutMapping("/{id}") // 映射到 PUT /api/tasks/{id}
        public Task updateTask(@PathVariable Long id, @RequestBody Task task) { /* ... */ }

        @DeleteMapping("/{id}") // 映射到 DELETE /api/tasks/{id}
        public void deleteTask(@PathVariable Long id) { /* ... */ }
    }
    ```

---

### 三、请求输入注解 (Request Input)

这类注解负责从 HTTP 请求的各个部分提取数据并绑定到方法参数上。

#### 1. `@PathVariable`
*   **核心功能**：从 URL 路径中提取值。常用于 RESTful 风格的 URL，如 `/users/{id}`。
*   **示例**：`@GetMapping("/users/{userId}")` public User getUser(`@PathVariable Long userId`) { ... }
*   **扩展**：如果方法参数名与路径变量名相同，可以省略 `("userId")`。

#### 2. `@RequestParam`
*   **核心功能**：从请求的查询参数（Query Parameter，即 URL 中 `?` 后面的部分）或 form-data 中获取值。
*   **常用属性**：
    *   `name` 或 `value`：参数名。
    *   `required`：是否必需，默认为 `true`。如果为 `true` 且请求中没有该参数，会抛出异常。
    *   `defaultValue`：提供一个默认值，如果设置了默认值，`required` 属性会自动变为 `false`。
*   **示例**：`@GetMapping("/search")` public List`<Product>` search(`@RequestParam String query`, `@RequestParam(required = false, defaultValue = "1") int page`) { ... }

#### 3. `@RequestBody`
*   **核心功能**：将 HTTP 请求的**请求体**（通常是 JSON 或 XML）内容，反序列化并绑定到一个 Java 对象上。
*   **详解**：一个方法最多只能有一个 `@RequestBody` 注解。这是接收复杂数据结构（如创建一个完整的用户对象）的标准方式。
*   **示例**：`@PostMapping("/users")` public User createUser(`@RequestBody User newUser`) { ... }

#### 4. `@RequestHeader`
*   **核心功能**：从请求头（Request Headers）中获取值。
*   **应用场景**：常用于获取认证信息（如 `Authorization` Token）、客户端类型等。
*   **示例**：`public void process(@RequestHeader("Authorization") String token)`

#### 5. `@CookieValue`
*   **核心功能**：从请求的 Cookie 中获取值。
*   **应用场景**：获取 Session ID、用户偏好设置等存储在 Cookie 中的信息。
*   **示例**：`public void whoAmI(@CookieValue("JSESSIONID") String sessionId)`

#### 6. `@RequestAttribute`
*   **核心功能**：获取在请求处理链中（例如在 Filter 或 Interceptor 中）被设置的请求属性值。
*   **应用场景**：在过滤器中进行身份验证后，将用户信息对象存入 `request`，然后在 Controller 中通过此注解获取。
*   **示例**：
    *   *In Filter:* `request.setAttribute("currentUser", userObject);`
    *   *In Controller:* `public void welcome(@RequestAttribute("currentUser") User user)`

#### 7. `@ModelAttribute`
*   **核心功能**：这是个多功能注解，主要有两种用法：
    1.  **绑定非 JSON 的表单数据到对象**：当请求的 `Content-Type` 是 `application/x-www-form-urlencoded` 时，Spring 会将请求参数按名称匹配到对象的字段上。这与 `@RequestBody` 形成对比。
    2.  **方法级别注解**：在 `@RequestMapping` 方法执行前，预先执行被 `@ModelAttribute` 标记的方法，并将其返回值放入 Model 中，供后续方法使用。
---

### 四、响应输出注解 (Response Output)

这类注解用于定制方法的返回值如何被处理成最终的 HTTP 响应。

#### 1. `@ResponseBody`
*   **核心功能**：告诉 Spring，方法的返回值是**响应体数据**，而不是视图名。Spring 会使用 `HttpMessageConverter` 将其序列化。
*   **详解**：如前所述，`@RestController` 已经包含了此功能，所以在 `@RestController` 标记的类中，方法上无需再写 `@ResponseBody`。但在 `@Controller` 类中，如果想返回数据，就必须加它。

#### 2. `@ResponseStatus`
*   **核心功能**：指定响应的 HTTP 状态码。
*   **应用场景**：
    *   默认成功是 200 OK。当创建资源成功时，可以返回 201 Created。`@ResponseStatus(HttpStatus.CREATED)`
    *   可以用在方法上，也可以用在自定义异常类上，当抛出该异常时自动返回指定的状态码。
*   **示例**：
    ```java
    @PostMapping("/users")
    @ResponseStatus(HttpStatus.CREATED) // 响应状态码为 201
    public User createUser(@RequestBody User user) {
        return userService.create(user);
    }
    ```

#### 3. `ResponseEntity<T>` (作为返回类型)
*   **核心功能**：这不是一个注解，而是一个返回类型，但它是响应处理的**终极武器**。它允许你完全控制整个 HTTP 响应，包括**响应体、状态码和响应头**。
*   **最佳实践**：当你需要动态地决定状态码，或者需要自定义响应头时，`ResponseEntity` 是最佳选择。
*   **示例**：
    ```java
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        Optional<User> userOptional = userService.findById(id);
        if (userOptional.isPresent()) {
            return ResponseEntity.ok(userOptional.get()); // 状态码 200 + user 数据
        } else {
            return ResponseEntity.notFound().build(); // 状态码 404，无响应体
        }
    }
    ```

---

### 五、功能增强注解 (Functional Enhancement)

这些注解处理一些横切性的功能。

#### 1. `@ExceptionHandler`
*   **核心功能**：在 Controller 内部定义一个**局部**的异常处理器。当该 Controller 中的方法抛出指定类型的异常时，会由被此注解标记的方法来处理。
*   **示例**：
    ```java
    @ExceptionHandler(UserNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleUserNotFound(UserNotFoundException ex) {
        return new ErrorResponse(ex.getMessage());
    }
    ```

#### 2. `@RestControllerAdvice` (或 `@ControllerAdvice`)
*   **核心功能**：**全局**异常处理、全局数据绑定、全局数据预处理。它是一个切面，可以应用到所有（或指定的）Controller。
*   **最佳实践**：**强烈推荐使用 `@RestControllerAdvice` 来做全局统一异常处理**，而不是在每个 Controller 中都写 `@ExceptionHandler`。这让代码更干净，逻辑更集中。
*   **示例**：
    ```java
    @RestControllerAdvice
    public class GlobalExceptionHandler {
        @ExceptionHandler(Exception.class)
        @Response-Status(HttpStatus.INTERNAL_SERVER_ERROR)
        public ErrorResponse handleAllExceptions(Exception ex) {
            return new ErrorResponse("服务器内部错误");
        }
    }
    ```

#### 3. `@CrossOrigin`
*   **核心功能**：为 Controller 或特定方法开启跨域资源共享（CORS）。
*   **应用场景**：当前后端分离部署在不同域名或端口时，浏览器会阻止前端 JS 的跨域请求，此注解可以允许来自指定源的请求。
*   **示例**：`@CrossOrigin(origins = "http://localhost:4200")`

#### 4. `@Valid` / `@Validated`
*   **核心功能**：触发对方法参数（尤其是 `@RequestBody` 绑定的对象）的数据校验。
*   **详解**：
    *   在需要校验的参数前加上 `@Valid` 或 `@Validated`。
    *   在要校验的对象的字段上使用 JSR-303/JSR-380（Bean Validation）的注解，如 `@NotNull`, `@Size`, `@Email` 等。
    *   如果校验失败，Spring 会抛出 `MethodArgumentNotValidException`，你可以通过全局异常处理器捕获它并返回友好的错误信息。
*   **示例**：
    ```java
    public ResponseEntity<User> createUser(@Valid @RequestBody UserDto userDto) {
        // ...
    }
    // 在 UserDto 类中
    public class UserDto {
        @NotBlank(message = "用户名不能为空")
        private String username;

        @Email(message = "邮箱格式不正确")
        private String email;
    }
    ```

---

### 总结与现代实践回顾

1.  **API 开发**：使用 `@RestController` 作为起点，使用 `@GetMapping`, `@PostMapping` 等快捷注解定义端点。
2.  **数据接收**：路径参数用 `@PathVariable`，查询参数用 `@RequestParam`，JSON 请求体用 `@RequestBody`。
3.  **数据校验**：在 `@RequestBody` 参数前加上 `@Valid`，并结合全局异常处理 `@RestControllerAdvice` 返回结构化的校验错误信息。
4.  **响应控制**：
    *   简单场景：直接返回对象，让 `@RestController` 自动处理。
    *   需要指定成功状态码：在方法上加 `@ResponseStatus`。
    *   复杂场景（动态状态码/自定义头）：方法返回 `ResponseEntity`。
5.  **异常处理**：使用 `@RestControllerAdvice` 建立统一的、全局的异常处理机制。
6.  **跨域**：在 Controller 或启动类中进行统一的 CORS 配置，需要精细控制时才在方法或类上用 `@CrossOrigin`。