# Spring AI 基本架构和核心概念

## 一、Spring AI 概述

Spring AI 是 Spring 团队在 2023 年推出的框架，专门用于简化 AI 应用开发。它遵循 Spring 的设计哲学：**简化复杂性、提供抽象层、支持多种实现**。

## 二、核心架构设计

### 2.1 分层架构

```
应用层 (Application Layer)
    ↓
抽象层 (Abstraction Layer) - Spring AI Core
    ↓
适配器层 (Adapter Layer) - 各种 AI 服务实现
    ↓
AI 服务层 (AI Services) - OpenAI、Azure、Ollama 等
```

### 2.2 核心模块划分

**spring-ai-core**: 核心抽象和接口 **spring-ai-spring-boot-autoconfigure**: 自动配置 **spring-ai-openai**: OpenAI 集成 **spring-ai-azure-openai**: Azure OpenAI 集成 **spring-ai-ollama**: 本地模型支持 **spring-ai-vectordbs**: 向量数据库集成

## 三、核心概念详解

### 3.1 ChatClient - 对话客户端

这是最核心的抽象，统一了所有 AI 模型的对话接口：

```java
// 基本用法
ChatResponse response = chatClient.call(
    new Prompt("解释什么是 Spring AI")
);

// 流式响应
Flux<ChatResponse> stream = chatClient.stream(
    new Prompt("写一首关于春天的诗")
);
```

**设计优势**：

- 统一接口，切换模型只需改配置
- 支持同步和异步调用
- 内置重试和错误处理

### 3.2 Prompt Template - 提示词模板

类似于 Spring 的 JdbcTemplate，提供模板化的提示词构建：

```java
@Component
public class TranslationService {
    
    private final PromptTemplate promptTemplate = new PromptTemplate(
        "将以下{sourceLanguage}文本翻译成{targetLanguage}：{text}"
    );
    
    public String translate(String text, String from, String to) {
        Map<String, Object> variables = Map.of(
            "sourceLanguage", from,
            "targetLanguage", to,
            "text", text
        );
        
        Prompt prompt = promptTemplate.create(variables);
        return chatClient.call(prompt).getResult().getOutput().getContent();
    }
}
```

### 3.3 VectorStore - 向量存储抽象

为 RAG 应用提供统一的向量数据库接口：

```java
public interface VectorStore {
    void add(List<Document> documents);
    List<Document> similaritySearch(String query);
    List<Document> similaritySearch(SearchRequest request);
    void delete(List<String> idList);
}
```

**支持的向量数据库**：

- Chroma
- Pinecone
- Weaviate
- Redis
- PostgreSQL (pgvector)

### 3.4 Document - 文档抽象

标准化的文档表示，包含内容和元数据：

```java
public class Document {
    private String content;          // 文档内容
    private Map<String, Object> metadata;  // 元数据
    private List<Double> embedding;  // 向量表示
    
    // 构造和访问方法
}
```

### 3.5 EmbeddingClient - 嵌入向量客户端

专门处理文本向量化：

```java
@Service
public class DocumentService {
    
    @Autowired
    private EmbeddingClient embeddingClient;
    
    public List<Double> getEmbedding(String text) {
        EmbeddingResponse response = embeddingClient.embedForResponse(
            List.of(text)
        );
        return response.getResults().get(0).getOutput();
    }
}
```

## 四、设计模式和原则

### 4.1 策略模式

不同的 AI 服务提供商通过策略模式实现：

```java
// 可以无缝切换
ChatClient openAiClient = new OpenAiChatClient();
ChatClient azureClient = new AzureOpenAiChatClient();
ChatClient ollamaClient = new OllamaChatClient();
```

### 4.2 模板方法模式

PromptTemplate 使用模板方法模式，标准化提示词构建流程。

### 4.3 观察者模式

支持回调和监听器，用于监控 AI 调用：

```java
chatClient.call(prompt, 
    ChatOptions.builder()
        .withResponseCallback(response -> {
            // 处理响应回调
        })
        .build()
);
```

## 五、关键特性

### 5.1 自动配置

利用 Spring Boot 的自动配置机制：

```properties
# application.properties
spring.ai.openai.api-key=your-api-key
spring.ai.openai.base-url=https://api.openai.com
spring.ai.vectorstore.chroma.initialize-schema=true
```

### 5.2 类型安全

通过泛型和强类型确保编译时安全：

```java
public class TypedChatService {
    
    public <T> T callWithType(String prompt, Class<T> responseType) {
        // 类型安全的响应处理
        return chatClient.call(prompt, responseType);
    }
}
```

### 5.3 可观测性

集成 Spring Boot Actuator，提供监控指标：

- AI 调用次数
- 响应时间
- 成功/失败率
- Token 使用量

## 六、架构优势

### 6.1 厂商中立

通过抽象层隔离具体实现，避免厂商锁定。

### 6.2 Spring 生态集成

无缝集成 Spring Security、Spring Boot、Spring Cloud 等。

### 6.3 企业级特性

- 连接池管理
- 重试机制
- 熔断器支持
- 缓存集成

### 6.4 扩展性

清晰的接口设计，便于添加新的 AI 服务提供商。

这个架构设计体现了 Spring 框架一贯的设计理念：**简化复杂性的同时保持灵活性和扩展性**。通过这种设计，开发者可以专注于业务逻辑，而不必关心底层 AI 服务的复杂性。