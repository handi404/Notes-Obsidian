# Prompt 和 PromptTemplate 深入讲解

## 一、Prompt 核心概念

### 1.1 Prompt 的本质

Prompt 是 Spring AI 中代表**完整AI请求**的核心数据结构。它不仅包含用户的输入文本，还包含了控制AI行为的各种参数和上下文信息。

```java
public class Prompt {
    private final List<Message> instructions;    // 消息列表
    private final ChatOptions chatOptions;       // 聊天选项
    
    // 构造方法
    public Prompt(String contents);
    public Prompt(String contents, ChatOptions chatOptions);
    public Prompt(List<Message> instructions);
    public Prompt(List<Message> instructions, ChatOptions chatOptions);
}
```

### 1.2 Prompt 的组成要素

#### Message 消息体系

```java
// 消息层次结构
public abstract class Message {
    protected String content;
    protected Map<String, Object> properties;
    protected MessageType messageType;
}

// 具体消息类型
public class SystemMessage extends Message {
    // 系统指令，定义AI的行为和角色
}

public class UserMessage extends Message {
    // 用户输入消息
}

public class AssistantMessage extends Message {
    // AI助手的回复消息
}

public class FunctionMessage extends Message {
    // 函数调用结果消息
}
```

#### 实际应用示例

```java
@Service
public class PromptConstructionService {
    
    // 1. 简单文本Prompt
    public Prompt createSimplePrompt(String userInput) {
        return new Prompt(userInput);
    }
    
    // 2. 多角色对话Prompt
    public Prompt createRoleBasedPrompt(String expertise, String question) {
        List<Message> messages = List.of(
            new SystemMessage("你是一位" + expertise + "专家，请用专业且通俗易懂的方式回答问题。"),
            new UserMessage(question)
        );
        return new Prompt(messages);
    }
    
    // 3. 带选项的复杂Prompt
    public Prompt createAdvancedPrompt(String userInput, String model) {
        ChatOptions options = ChatOptionsBuilder.builder()
            .withModel(model)
            .withTemperature(0.7f)
            .withMaxTokens(2000)
            .build();
            
        return new Prompt(userInput, options);
    }
    
    // 4. 多轮对话Prompt
    public Prompt createConversationPrompt(List<String> conversationHistory, String newMessage) {
        List<Message> messages = new ArrayList<>();
        
        // 添加对话历史
        for (int i = 0; i < conversationHistory.size(); i++) {
            if (i % 2 == 0) {
                messages.add(new UserMessage(conversationHistory.get(i)));
            } else {
                messages.add(new AssistantMessage(conversationHistory.get(i)));
            }
        }
        
        // 添加新消息
        messages.add(new UserMessage(newMessage));
        
        return new Prompt(messages);
    }
}
```

## 二、PromptTemplate 深入解析

### 2.1 PromptTemplate 设计理念

PromptTemplate 借鉴了 Spring 的 Template 设计模式（如 JdbcTemplate、RestTemplate），提供了**模板化、参数化、可复用**的Prompt构建方案。

```java
public class PromptTemplate {
    private final String template;                    // 模板内容
    private final Set<String> templateVariables;     // 模板变量
    private final Parser parser;                      // 解析器
    
    public PromptTemplate(String template);
    public PromptTemplate(Resource templateResource);
    public Prompt create(Map<String, Object> model);
}
```

### 2.2 模板语法详解

#### 基础变量替换

```java
@Component
public class BasicTemplateService {
    
    public void demonstrateBasicSyntax() {
        // 1. 简单变量替换
        PromptTemplate template = new PromptTemplate(
            "请将以下{language}代码进行优化：\n{code}"
        );
        
        Map<String, Object> variables = Map.of(
            "language", "Java",
            "code", "public class Test { public static void main(String[] args) { System.out.println(\"Hello\"); } }"
        );
        
        Prompt prompt = template.create(variables);
        // 结果：请将以下Java代码进行优化：
        // public class Test { public static void main(String[] args) { System.out.println("Hello"); } }
    }
}
```

#### 条件渲染和循环

```java
@Service
public class AdvancedTemplateService {
    
    public Prompt createCodeReviewPrompt(CodeReviewRequest request) {
        String templateString = """
            你是一位资深的{language}开发专家，请对以下代码进行review：
            
            代码文件：{filename}
            {#if description}
            代码描述：{description}
            {/if}
            
            代码内容：
            ```{language}
            {code}
            ```
            
            请从以下方面进行分析：
            {#list aspects}
            - {.}
            {/list}
            
            {#if includeImprovement}
            请提供改进建议和优化后的代码。
            {/if}
            """;
            
        PromptTemplate template = new PromptTemplate(templateString);
        
        Map<String, Object> variables = Map.of(
            "language", request.getLanguage(),
            "filename", request.getFilename(),
            "description", request.getDescription(),
            "code", request.getCode(),
            "aspects", List.of("代码质量", "性能优化", "安全性", "可维护性"),
            "includeImprovement", request.isIncludeImprovement()
        );
        
        return template.create(variables);
    }
}
```

### 2.3 模板资源管理

#### 外部模板文件

```java
@Configuration
public class TemplateConfiguration {
    
    // 1. 从classpath加载模板
    @Bean("translationTemplate")
    public PromptTemplate translationTemplate() {
        Resource resource = new ClassPathResource("prompts/translation.st");
        return new PromptTemplate(resource);
    }
    
    // 2. 从文件系统加载模板
    @Bean("codeAnalysisTemplate") 
    public PromptTemplate codeAnalysisTemplate() {
        Resource resource = new FileSystemResource("templates/code-analysis.st");
        return new PromptTemplate(resource);
    }
}

// templates/translation.st 文件内容
/*
你是一位专业的翻译专家，具有{sourceLanguage}到{targetLanguage}的深厚造诣。

请翻译以下内容：
{content}

翻译要求：
{#if preserveStyle}
- 保持原文的写作风格和语调
{/if}
{#if technicalTerms}
- 准确翻译技术术语
{/if}
{#if contextInfo}
- 考虑以下上下文信息：{contextInfo}
{/if}

请提供准确、流畅、地道的翻译。
*/
```

#### 模板服务封装

```java
@Service
public class TemplateService {
    
    @Autowired
    @Qualifier("translationTemplate")
    private PromptTemplate translationTemplate;
    
    @Autowired
    @Qualifier("codeAnalysisTemplate")
    private PromptTemplate codeAnalysisTemplate;
    
    public Prompt createTranslationPrompt(TranslationRequest request) {
        Map<String, Object> variables = Map.of(
            "sourceLanguage", request.getSourceLanguage(),
            "targetLanguage", request.getTargetLanguage(),
            "content", request.getContent(),
            "preserveStyle", request.isPreserveStyle(),
            "technicalTerms", request.hasTechnicalTerms(),
            "contextInfo", request.getContextInfo()
        );
        
        return translationTemplate.create(variables);
    }
    
    public Prompt createCodeAnalysisPrompt(String code, String language, List<String> focusAreas) {
        Map<String, Object> variables = Map.of(
            "code", code,
            "language", language,
            "focusAreas", focusAreas,
            "timestamp", LocalDateTime.now().toString()
        );
        
        return codeAnalysisTemplate.create(variables);
    }
}
```

## 三、Prompt 与 PromptTemplate 关系深度解析

### 3.1 设计模式关系

#### 工厂模式体现

```java
// PromptTemplate 作为 Prompt 的工厂
public class PromptTemplate {
    
    // 工厂方法：根据参数创建具体的Prompt实例
    public Prompt create(Map<String, Object> model) {
        String resolvedContent = resolveTemplate(model);
        return new Prompt(resolvedContent);
    }
    
    public Prompt create(Map<String, Object> model, ChatOptions options) {
        String resolvedContent = resolveTemplate(model);
        return new Prompt(resolvedContent, options);
    }
}
```

#### 建造者模式结合

```java
@Component
public class ComplexPromptBuilder {
    
    public Prompt buildComplexPrompt(ComplexPromptRequest request) {
        // 1. 使用PromptTemplate构建基础内容
        PromptTemplate baseTemplate = new PromptTemplate(request.getTemplate());
        String baseContent = baseTemplate.create(request.getVariables()).getContents();
        
        // 2. 构建消息列表
        List<Message> messages = new ArrayList<>();
        
        // 添加系统消息
        if (request.hasSystemMessage()) {
            messages.add(new SystemMessage(request.getSystemMessage()));
        }
        
        // 添加上下文消息
        request.getContextMessages().forEach(msg -> {
            messages.add(new UserMessage(msg));
        });
        
        // 添加主要内容
        messages.add(new UserMessage(baseContent));
        
        // 3. 构建选项
        ChatOptions options = ChatOptionsBuilder.builder()
            .withModel(request.getModel())
            .withTemperature(request.getTemperature())
            .withMaxTokens(request.getMaxTokens())
            .build();
        
        return new Prompt(messages, options);
    }
}
```

### 3.2 生命周期关系

#### 模板 → 实例化 → 执行

```java
@Service
public class PromptLifecycleService {
    
    private final ChatClient chatClient;
    private final PromptTemplate documentAnalysisTemplate;
    
    public PromptLifecycleService(ChatClient chatClient) {
        this.chatClient = chatClient;
        this.documentAnalysisTemplate = new PromptTemplate("""
            请分析以下{documentType}文档：
            
            文档标题：{title}
            文档内容：
            {content}
            
            分析要求：
            {#list requirements}
            {index}. {description}
            {/list}
            
            请提供详细的分析报告。
            """);
    }
    
    public DocumentAnalysisResult analyzeDocument(DocumentAnalysisRequest request) {
        // 阶段1：模板准备（Template阶段）
        Map<String, Object> templateVariables = prepareTemplateVariables(request);
        
        // 阶段2：Prompt实例化（Template → Prompt）
        Prompt prompt = documentAnalysisTemplate.create(templateVariables);
        
        // 阶段3：执行阶段（Prompt → Response）
        ChatResponse response = chatClient.call(prompt);
        
        // 阶段4：结果处理
        return parseAnalysisResult(response);
    }
    
    private Map<String, Object> prepareTemplateVariables(DocumentAnalysisRequest request) {
        List<Map<String, Object>> requirements = request.getRequirements().stream()
            .map((req, index) -> Map.of(
                "index", index + 1,
                "description", req
            ))
            .collect(Collectors.toList());
            
        return Map.of(
            "documentType", request.getDocumentType(),
            "title", request.getTitle(),
            "content", request.getContent(),
            "requirements", requirements
        );
    }
}
```

### 3.3 组合使用模式

#### 链式模板处理

```java
@Service
public class ChainedTemplateService {
    
    private final PromptTemplate preprocessTemplate;
    private final PromptTemplate mainTemplate;
    private final PromptTemplate postprocessTemplate;
    
    public ChainedTemplateService() {
        this.preprocessTemplate = new PromptTemplate(
            "请对以下内容进行预处理，提取关键信息：{rawContent}"
        );
        
        this.mainTemplate = new PromptTemplate("""
            基于预处理结果：{preprocessedContent}
            
            请执行主要任务：{mainTask}
            
            附加要求：{additionalRequirements}
            """);
            
        this.postprocessTemplate = new PromptTemplate(
            "请对以下结果进行后处理和格式化：{mainResult}"
        );
    }
    
    public String processWithChain(ChainProcessRequest request) {
        // 第一阶段：预处理
        Prompt preprocessPrompt = preprocessTemplate.create(Map.of(
            "rawContent", request.getRawContent()
        ));
        String preprocessResult = chatClient.call(preprocessPrompt)
            .getResult().getOutput().getContent();
        
        // 第二阶段：主处理
        Prompt mainPrompt = mainTemplate.create(Map.of(
            "preprocessedContent", preprocessResult,
            "mainTask", request.getMainTask(),
            "additionalRequirements", request.getAdditionalRequirements()
        ));
        String mainResult = chatClient.call(mainPrompt)
            .getResult().getOutput().getContent();
        
        // 第三阶段：后处理
        Prompt postprocessPrompt = postprocessTemplate.create(Map.of(
            "mainResult", mainResult
        ));
        return chatClient.call(postprocessPrompt)
            .getResult().getOutput().getContent();
    }
}
```

## 四、高级应用场景

### 4.1 动态模板生成

```java
@Service
public class DynamicTemplateService {
    
    public PromptTemplate createDynamicTemplate(TemplateConfig config) {
        StringBuilder templateBuilder = new StringBuilder();
        
        // 动态构建系统消息部分
        if (config.hasSystemRole()) {
            templateBuilder.append("你是一位{role}，");
        }
        
        // 动态构建任务描述
        templateBuilder.append("请{action}以下内容：\n{content}\n\n");
        
        // 动态构建约束条件
        if (config.hasConstraints()) {
            templateBuilder.append("约束条件：\n");
            config.getConstraints().forEach(constraint -> {
                templateBuilder.append("- {").append(constraint).append("}\n");
            });
        }
        
        // 动态构建输出格式要求
        if (config.hasOutputFormat()) {
            templateBuilder.append("\n请按照{outputFormat}格式输出结果。");
        }
        
        return new PromptTemplate(templateBuilder.toString());
    }
    
    public Prompt createDynamicPrompt(DynamicPromptRequest request) {
        PromptTemplate template = createDynamicTemplate(request.getConfig());
        
        Map<String, Object> variables = new HashMap<>();
        variables.put("content", request.getContent());
        variables.put("action", request.getAction());
        
        if (request.getConfig().hasSystemRole()) {
            variables.put("role", request.getConfig().getRole());
        }
        
        if (request.getConfig().hasOutputFormat()) {
            variables.put("outputFormat", request.getConfig().getOutputFormat());
        }
        
        // 添加约束条件变量
        request.getConfig().getConstraints().forEach(constraint -> {
            variables.put(constraint, request.getConstraintValue(constraint));
        });
        
        return template.create(variables);
    }
}
```

### 4.2 模板继承和组合

```java
@Component
public class TemplateInheritanceService {
    
    private final PromptTemplate baseTemplate;
    private final Map<String, PromptTemplate> specializedTemplates;
    
    public TemplateInheritanceService() {
        // 基础模板
        this.baseTemplate = new PromptTemplate("""
            {#if systemRole}
            你是一位{systemRole}。
            {/if}
            
            任务：{task}
            
            {#if context}
            上下文信息：{context}
            {/if}
            
            内容：
            {content}
            
            {baseRequirements}
            """);
        
        // 专业化模板
        this.specializedTemplates = Map.of(
            "code_review", new PromptTemplate("""
                请从以下角度进行代码review：
                - 代码质量和规范
                - 性能优化建议  
                - 安全性考虑
                - 可维护性评估
                
                {#if includeFix}
                请提供修改建议和优化后的代码。
                {/if}
                """),
                
            "document_analysis", new PromptTemplate("""
                请进行文档分析，包括：
                - 主要内容摘要
                - 关键观点提取
                - 逻辑结构分析
                
                {#if generateOutline}
                请生成详细的文档大纲。
                {/if}
                """)
        );
    }
    
    public Prompt createInheritedPrompt(String templateType, InheritedPromptRequest request) {
        // 组合基础模板和专业模板
        String baseContent = baseTemplate.create(request.getBaseVariables()).getContents();
        String specializedContent = specializedTemplates.get(templateType)
            .create(request.getSpecializedVariables()).getContents();
        
        // 创建最终的组合模板
        PromptTemplate combinedTemplate = new PromptTemplate(baseContent + "\n\n" + specializedContent);
        
        Map<String, Object> allVariables = new HashMap<>();
        allVariables.putAll(request.getBaseVariables());
        allVariables.putAll(request.getSpecializedVariables());
        
        return combinedTemplate.create(allVariables);
    }
}
```

### 4.3 国际化模板支持

```java
@Configuration
public class I18nTemplateConfiguration {
    
    @Bean
    public LocalizedTemplateManager localizedTemplateManager() {
        return new LocalizedTemplateManager();
    }
    
    @Component
    public static class LocalizedTemplateManager {
        
        private final Map<Locale, Map<String, PromptTemplate>> templates;
        
        public LocalizedTemplateManager() {
            this.templates = initializeTemplates();
        }
        
        private Map<Locale, Map<String, PromptTemplate>> initializeTemplates() {
            Map<Locale, Map<String, PromptTemplate>> templates = new HashMap<>();
            
            // 中文模板
            Map<String, PromptTemplate> cnTemplates = Map.of(
                "translation", new PromptTemplate("请将以下{sourceLanguage}内容翻译成{targetLanguage}：\n{content}"),
                "summary", new PromptTemplate("请对以下内容进行总结：\n{content}\n\n要求：{requirements}")
            );
            templates.put(Locale.CHINESE, cnTemplates);
            
            // 英文模板
            Map<String, PromptTemplate> enTemplates = Map.of(
                "translation", new PromptTemplate("Please translate the following {sourceLanguage} content to {targetLanguage}:\n{content}"),
                "summary", new PromptTemplate("Please summarize the following content:\n{content}\n\nRequirements: {requirements}")
            );
            templates.put(Locale.ENGLISH, enTemplates);
            
            return templates;
        }
        
        public Prompt createLocalizedPrompt(String templateName, Locale locale, Map<String, Object> variables) {
            PromptTemplate template = templates.get(locale).get(templateName);
            if (template == null) {
                // 回退到默认语言
                template = templates.get(Locale.CHINESE).get(templateName);
            }
            return template.create(variables);
        }
    }
}
```

## 五、性能优化和最佳实践

### 5.1 模板缓存策略

```java
@Configuration
@EnableCaching
public class TemplateCacheConfiguration {
    
    @Bean
    public CacheManager templateCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(100)
            .expireAfterWrite(Duration.ofHours(1))
            .recordStats());
        return cacheManager;
    }
}

@Service
public class CachedTemplateService {
    
    @Cacheable(value = "promptTemplates", key = "#templateContent.hashCode()")
    public PromptTemplate createTemplate(String templateContent) {
        return new PromptTemplate(templateContent);
    }
    
    @Cacheable(value = "renderedPrompts", key = "#template.hashCode() + '_' + #variables.hashCode()")
    public Prompt renderTemplate(PromptTemplate template, Map<String, Object> variables) {
        return template.create(variables);
    }
}
```

### 5.2 模板验证和测试

```java
@Component
public class TemplateValidator {
    
    public ValidationResult validateTemplate(PromptTemplate template, Map<String, Object> testVariables) {
        ValidationResult result = new ValidationResult();
        
        try {
            // 1. 语法验证
            Set<String> templateVariables = template.getTemplateVariables();
            Set<String> providedVariables = testVariables.keySet();
            
            // 检查缺失变量
            Set<String> missingVariables = new HashSet<>(templateVariables);
            missingVariables.removeAll(providedVariables);
            
            if (!missingVariables.isEmpty()) {
                result.addError("缺失模板变量: " + missingVariables);
            }
            
            // 检查多余变量
            Set<String> extraVariables = new HashSet<>(providedVariables);
            extraVariables.removeAll(templateVariables);
            
            if (!extraVariables.isEmpty()) {
                result.addWarning("多余的变量: " + extraVariables);
            }
            
            // 2. 渲染测试
            Prompt testPrompt = template.create(testVariables);
            String renderedContent = testPrompt.getContents();
            
            // 检查渲染结果
            if (renderedContent.contains("{") && renderedContent.contains("}")) {
                result.addWarning("可能存在未替换的变量");
            }
            
            result.setValid(result.getErrors().isEmpty());
            
        } catch (Exception e) {
            result.addError("模板验证失败: " + e.getMessage());
            result.setValid(false);
        }
        
        return result;
    }
}
```

## 六、总结

### 核心关系图

```
PromptTemplate (模板层)
    ↓ create(variables)
Prompt (实例层)  
    ↓ chatClient.call()
ChatResponse (响应层)
```

### 关键设计原则

1. **分离关注点**：PromptTemplate 负责结构，Prompt 负责实例
2. **可复用性**：模板可以多次使用，生成不同的Prompt实例
3. **类型安全**：通过强类型保证变量替换的正确性
4. **扩展性**：支持复杂的模板语法和自定义解析器

### 使用建议

1. **简单场景**：直接使用 Prompt
2. **重复场景**：使用 PromptTemplate
3. **复杂场景**：组合使用，配合缓存和验证
4. **团队协作**：建立模板库和标准化流程

Prompt 和 PromptTemplate 是 Spring AI 中最基础也是最重要的概念，掌握它们的深层原理和使用技巧，对于构建高质量的 AI 应用至关重要。