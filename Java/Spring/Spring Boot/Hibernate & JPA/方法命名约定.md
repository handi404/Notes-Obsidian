
### Hibernate & JPA 通过方法命名约定自动实现 CRUD 方法详解

在 Spring Data JPA 中，**方法命名约定（Query Derivation）** 是一种通过定义符合特定命名规则的方法接口，自动生成 SQL 查询的机制。开发者无需编写 SQL 或 JPQL，只需遵循命名规则定义方法，即可实现常见 CRUD 操作，极大简化代码。

---

#### 一、核心规则与语法

Spring Data JPA 的方法命名由 **关键字 + 属性名 + 条件** 组成，支持以下核心语法：

| 关键字                       | 示例方法名                         | 生成的 JPQL 条件                              |
| ------------------------- | ----------------------------- | ---------------------------------------- |
| `findBy`, `readBy`        | `findByName`                  | `WHERE name = ?1`                        |
| `countBy`                 | `countByStatus`               | `SELECT COUNT(*) WHERE status = ?1`      |
| `existsBy`                | `existsByEmail`               | `EXISTS (SELECT ... WHERE email = ?1)`   |
| `deleteBy`, `removeBy`    | `deleteByAgeLessThan`         | `DELETE WHERE age < ?1`                  |
| `Distinct`                | `findDistinctByAge`           | `SELECT DISTINCT ...`                    |
| `And`, `Or`               | `findByNameOrEmail`           | `WHERE name = ?1 OR email = ?2`          |
| `Is`, `Equals`            | `findByStatusIs`              | `WHERE status = ?1` (等价于 `findByStatus`) |
| `Between`                 | `findByAgeBetween`            | `WHERE age BETWEEN ?1 AND ?2`            |
| `LessThan`, `GreaterThan` | `findByAgeLessThan`           | `WHERE age < ?1`                         |
| `Like`, `Containing`      | `findByNameLike`              | `WHERE name LIKE ?1`                     |
| `OrderBy`                 | `findByStatusOrderByNameDesc` | `ORDER BY name DESC`                     |

---

#### 二、代码实现与示例

##### 1. 定义实体类（`domain/User.java`）
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
    private Integer age;
    @Enumerated(EnumType.STRING)
    private UserStatus status;
    // Getters & Setters
}
```

##### 2. Repository 接口（`repository/UserRepository.java`）
```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 精确匹配
    List<User> findByName(String name);
    
    // 多条件组合
    List<User> findByNameOrEmail(String name, String email);
    
    // 范围查询
    List<User> findByAgeBetween(int minAge, int maxAge);
    
    // 模糊查询 + 排序
    List<User> findByEmailContainingOrderByNameAsc(String domain);
    
    // 统计查询
    Long countByStatus(UserStatus status);
    
    // 删除操作
    @Transactional
    @Modifying
    void deleteByStatus(UserStatus status);
    
    // 分页查询
    Page<User> findByAgeGreaterThan(int minAge, Pageable pageable);
}
```

---

#### 三、方法命名解析流程

Spring Data JPA 通过以下步骤解析方法名生成查询：

1. **解析方法前缀**：如 `findBy`、`countBy` 确定操作类型。
2. **拆分属性链**：解析方法名中的属性名（如 `name`、`status`），需与实体字段严格一致。
3. **处理条件关键字**：识别 `And`、`Or`、`LessThan` 等条件组合。
4. **生成 JPQL**：转换为 `SELECT ... WHERE ...` 结构。
5. **映射参数**：按方法参数顺序绑定到查询条件。

---

#### 四、高级用法

##### 1. 分页与排序
```java
// Service 层调用分页
public Page<User> getUsersByAge(int minAge, int page, int size) {
    Pageable pageable = PageRequest.of(page, size, Sort.by("name").descending());
    return userRepository.findByAgeGreaterThan(minAge, pageable);
}
```

##### 2. 嵌套属性查询
若实体有关联对象（如 `User` 有 `Address address` 字段）：
```java
List<User> findByAddressCity(String city); // 查询 address.city 字段
```

##### 3. 集合条件查询
若实体有集合字段（如 `List<String> tags`）：
```java
List<User> findByTagsContains(String tag); // WHERE :tag MEMBER OF tags
```

---

#### 五、依赖与配置

确保 `pom.xml` 包含 Spring Data JPA 依赖：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

无需额外配置，但需注意：
- 实体类必须标注 `@Entity`
- Repository 接口需继承 `JpaRepository`

---

#### 六、最佳实践与陷阱

1. **属性名严格匹配**：
   - 方法中的属性名（如 `findByName` 中的 `Name`）必须与实体字段名（`name`）完全一致，**区分大小写**。

2. **避免过度复杂**：
   - 方法名过长时（如 `findByAAndBOrCAndD`）应改用 `@Query` 或 `Specification` 提高可读性。

3. **事务管理**：
   - 删除操作（`deleteBy`）需添加 `@Transactional` 和 `@Modifying`。

4. **性能优化**：
   - 分页查询优先返回 `Page` 而非 `List`，避免加载全部数据。

---

#### 七、方法命名 vs 其他查询方式

| 场景                  | 方法命名约定          | `@Query` JPQL        | Criteria API       |
|-----------------------|-----------------------|-----------------------|-----------------------|
| **简单条件查询**       | ✅ 高效简洁           | ⚠️ 冗余              | ⚠️ 冗余              |
| **多表关联查询**       | ⚠️ 仅支持单表        | ✅ 灵活              | ✅ 灵活              |
| **动态条件组合**       | ❌ 无法动态拼接       | ❌ 固定条件           | ✅ 完美支持          |
| **复杂聚合操作**       | ❌ 不支持            | ✅ 支持              | ✅ 支持              |

---

#### 八、总结

通过方法命名约定，开发者可以快速实现以下功能：

- **零编码 CRUD**：基础查询无需写实现代码
- **条件自由组合**：通过 `And` / `Or` 连接多个字段
- **分页排序集成**：天然支持 `Pageable` 参数
- **类型安全验证**：编译时检查属性名合法性

**适用场景**：单表简单查询、快速原型开发、标准化条件筛选。  
**规避场景**：多表联合查询、动态条件、复杂聚合操作。

##  [[复杂的多表查询]]

**JPQL**
**Criteria API**
**Native SQL**