讲解 JPA 中所有与“继承”相关的注解。这是一个非常重要但又容易混淆的主题，我会为你彻底梳理清楚。

在 JPA 中，“继承”这个词有两个截然不同的含义和实现方式，这也是最关键的区分点：

1.  **代码层面的继承 (Code Reusability):** 为了复用代码，将通用属性（如 `id`, `createdAt`）抽取到父类中。子类实体在数据库层面是完全独立的。这通过 `@MappedSuperclass` 实现。
2.  **数据模型层面的继承 (Polymorphic Association):** 建立一个真正的“is-a”关系（例如，“信用卡”是一种“支付方式”）。这会影响数据库的表结构，并支持多态查询。这通过 `@Inheritance` 注解及其相关策略实现。

我们逐一深入剖析。

---

### 一、`@MappedSuperclass`：代码复用的利器

这个详细讲过：[[@MappedSuperclass]]，这里做一个精炼的总结和对比。

*   **核心注解**: `@MappedSuperclass`
*   **核心思想**: **共享代码，不共享数据模型。** 它是一个“属性模板”，不是实体。
*   **数据库表现**: 父类不会创建表。每个子类实体都会创建自己独立的表，并包含从父类继承来的字段。
*   **多态查询**: **不支持**。你不能查询 `BaseEntity` 来获取所有的 `Product` 和 `User`。
*   **何时使用**: 当多个实体有相同的、与业务无关的通用属性时（如 ID、审计信息、版本号、软删除标记）。这是绝大多数项目中都会用到的模式。

**示例回顾:**

```java
@MappedSuperclass
public abstract class BaseEntity {
    @Id private Long id;
    @CreatedDate private LocalDateTime createdAt;
    // ...
}

@Entity
public class Product extends BaseEntity {
    private String name;
}

@Entity
public class User extends BaseEntity {
    private String username;
}
```

数据库会生成 `product` 表和 `user` 表，它们都有 `id` 和 `created_at` 字段，但两张表之间没有任何关联。

---

### 二、`@Inheritance`：真正的实体继承与多态

当你的业务模型中存在明确的父子层级关系时（`Cat` is an `Animal`, `CreditCard` is a `PaymentMethod`），就该使用 `@Inheritance` 了。这允许你对父类进行查询，并能得到其所有子类的实例。

`@Inheritance` 注解必须放在继承体系的根实体类上，它通过 `strategy` 属性来决定数据库如何存储这种继承关系。共有三种策略，每种都有其鲜明的优缺点。

**核心配套注解:**

*   `@Inheritance(strategy = ...)`: 放在父实体上，定义继承策略。
*   `@DiscriminatorColumn(...)`: **（主要用于 SINGLE_TABLE）** 在单表中增加一个“鉴别器列”，用来区分这一行数据到底属于哪个子类。
*   `@DiscriminatorValue(...)`: 放在子实体上，定义在该子类对应的行中，“鉴别器列”应该存什么值。

让我们用一个支付方式的例子 (`PaymentMethod` -> `CreditCard`, `PayPal`) 来贯穿讲解这三种策略。

**父类和子类定义:**

```java
// 父类 (根实体)
@Entity
@Inheritance(strategy = ...) // <-- 策略将在这里改变
public abstract class PaymentMethod {
    @Id @GeneratedValue
    private Long id;
    private String owner;
}

// 子类1
@Entity
public class CreditCard extends PaymentMethod {
    private String cardNumber;
    private String expiryMonth;
    private String expiryYear;
}

// 子类2
@Entity
public class PayPal extends PaymentMethod {
    private String emailAddress;
}
```

#### 策略 1: `InheritanceType.SINGLE_TABLE` (单表策略)

这是 `@Inheritance` 的**默认策略**。

*   **核心思想**: **用一张表存储整个继承体系的所有类。**
*   **注解使用**:
    ```java
    @Entity
    @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
    @DiscriminatorColumn(name = "payment_type", discriminatorType = DiscriminatorType.STRING) // 强烈推荐显式定义
    public abstract class PaymentMethod { ... }

    @Entity
    @DiscriminatorValue("CREDIT_CARD") // 当 payment_type = 'CREDIT_CARD' 时，是信用卡
    public class CreditCard extends PaymentMethod { ... }

    @Entity
    @DiscriminatorValue("PAYPAL") // 当 payment_type = 'PAYPAL' 时，是 PayPal
    public class PayPal extends PaymentMethod { ... }
    ```
*   **数据库表现**: 只会生成一张 `payment_method` 表。
    ```sql
    CREATE TABLE payment_method (
        id BIGINT NOT NULL,
        payment_type VARCHAR(31) NOT NULL, -- 鉴别器列 (DTYPE 是默认名)
        owner VARCHAR(255),
        -- CreditCard fields
        card_number VARCHAR(255),
        expiry_month VARCHAR(255),
        expiry_year VARCHAR(255),
        -- PayPal fields
        email_address VARCHAR(255),
        PRIMARY KEY (id)
    );
    ```
*   **优点**:
    *   **性能最高**: 多态查询（如 `findAll` 支付方式）极其高效，因为它只需要扫描一张表，无需任何 JOIN 操作。
*   **缺点**:
    *   **数据冗余/浪费空间**: 子类特有的字段在其他子类的行中必须为 `NULL`。如果子类很多或特有字段很多，会造成大量空间浪费。
    *   **无法设置非空约束**: 不能在数据库层面为子类的特有字段（如 `cardNumber`）设置 `NOT NULL` 约束，因为对于 PayPal 记录，它必须为 `NULL`。

*   **适用场景**:
    *   继承体系简单，子类特有字段少。
    *   性能是首要考虑因素，多态查询非常频繁。

#### 策略 2: `InheritanceType.JOINED` (连接表策略)

*   **核心思想**: **父类一张表，每个子类也各有一张表。** 子类表通过外键关联到父类表的主键。
*   **注解使用**:
    ```java
    @Entity
    @Inheritance(strategy = InheritanceType.JOINED)
    public abstract class PaymentMethod { ... }

    @Entity // 子类注解保持不变
    public class CreditCard extends PaymentMethod { ... }

    @Entity
    public class PayPal extends PaymentMethod { ... }
    ```
    *注意: `@DiscriminatorColumn` 在此策略下是可选的，但如果加上，父表中会多一个字段，有助于调试和理解数据。*
*   **数据库表现**: 会生成三张表。
    ```sql
    -- 父类表
    CREATE TABLE payment_method (
        id BIGINT NOT NULL,
        owner VARCHAR(255),
        PRIMARY KEY (id)
    );
    -- 子类表1
    CREATE TABLE credit_card (
        id BIGINT NOT NULL, -- 同时是主键和外键
        card_number VARCHAR(255),
        expiry_month VARCHAR(255),
        expiry_year VARCHAR(255),
        PRIMARY KEY (id),
        FOREIGN KEY (id) REFERENCES payment_method (id)
    );
    -- 子类表2
    CREATE TABLE pay_pal (
        id BIGINT NOT NULL,
        email_address VARCHAR(255),
        PRIMARY KEY (id),
        FOREIGN KEY (id) REFERENCES payment_method (id)
    );
    ```
*   **优点**:
    *   **数据模型最规范**: 数据库设计符合范式，没有数据冗余，没有 `NULL` 字段浪费。
    *   **支持数据库约束**: 可以在子类表上（如 `credit_card`）为 `card_number` 添加 `NOT NULL` 约束。
*   **缺点**:
    *   **查询性能稍低**: 多态查询需要通过 `LEFT JOIN` 将父表和所有子表连接起来。获取一个子类实例（如 `CreditCard`）也需要 `JOIN` 操作。
    *   **插入/更新复杂**: 可能需要操作多张表。

*   **适用场景**:
    *   **大部分场景下的首选和推荐策略**。它提供了最平衡、最健壮的设计。
    *   当数据模型的清晰度和完整性比微小的查询性能差异更重要时。

#### 策略 3: `InheritanceType.TABLE_PER_CLASS` (每个类一张表策略)

*   **核心思想**: **每个具体（非抽象）的子类都映射到一张完整的表，这张表包含从父类继承的所有字段。**
*   **注解使用**:
    ```java
    @Entity
    @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
    public abstract class PaymentMethod { ... }

    @Entity // 子类注解保持不变
    public class CreditCard extends PaymentMethod { ... }

    @Entity
    public class PayPal extends PaymentMethod { ... }
    ```
*   **数据库表现**: `PaymentMethod` 作为抽象类，不会生成表。会生成两张独立的表。
    ```sql
    -- 子类表1 (包含父类字段)
    CREATE TABLE credit_card (
        id BIGINT NOT NULL,
        owner VARCHAR(255),
        card_number VARCHAR(255),
        expiry_month VARCHAR(255),
        expiry_year VARCHAR(255),
        PRIMARY KEY (id)
    );
    -- 子类表2 (包含父类字段)
    CREATE TABLE pay_pal (
        id BIGINT NOT NULL,
        owner VARCHAR(255),
        email_address VARCHAR(255),
        PRIMARY KEY (id)
    );
    ```
*   **优点**:
    *   查询具体子类时（如只查 `CreditCard`），性能好，因为是单表查询。
*   **缺点**:
    *   **多态查询性能极差**: 查询所有 `PaymentMethod` 需要对所有子类表执行 `UNION` 操作，这在数据库中通常是昂贵且难以优化的。
    *   **外键约束问题**: 父类 `PaymentMethod` 没有对应的表，导致无法直接建立指向 `PaymentMethod` 的外键关联。
    *   **主键生成策略限制**: 不能使用 `IDENTITY` 策略，因为多个表的主键需要协调。通常需要使用 `TABLE` 或 `SEQUENCE`。

*   **适用场景**:
    *   **极少使用，通常应避免**。JPA 规范本身也指出它存在很多问题。只有在你几乎从不进行多态查询，并且不关心父类关联时，才可能考虑。

---

### 三、总结与高级工程师的建议

| 特性 | `@MappedSuperclass` (代码继承) | `SINGLE_TABLE` | `JOINED` (推荐) | `TABLE_PER_CLASS` (不推荐) |
| :--- | :--- | :--- | :--- | :--- |
| **核心目的** | 代码复用 | 实体继承 | 实体继承 | 实体继承 |
| **父类映射** | 无表 | 有（作为唯一表） | 有（基础信息表） | 无表（如果为抽象类） |
| **多态查询** | ❌ 不支持 | ✅ **性能最佳** (单表扫描) | ✅ **性能良好** (JOINs) | ✅ **性能最差** (UNIONs) |
| **数据冗余** | 无 | 高（大量 NULLs） | 无（最规范） | 中（父类字段在各表重复） |
| **数据库约束** | 子类独立 | 弱（无法对子类字段加 NOT NULL） | 强（子类表可加任何约束） | 强 |
| **推荐度** | ⭐⭐⭐⭐⭐ (用于通用属性) | ⭐⭐⭐ (简单场景) | ⭐⭐⭐⭐⭐ (通用首选) | ⭐ (尽量避免) |

**我的建议:**

1.  **明确你的意图**:
    *   如果你只是想抽取 `id`, `createdAt`, `version` 等公共字段，**毫不犹豫地使用 `@MappedSuperclass`**。这是 90%场景下的正确选择。
    *   如果你在业务上确实存在 "is-a" 关系，并且需要对父类进行查询（`List<PaymentMethod> methods = repo.findAll();`），才考虑使用 `@Inheritance`。

2.  **在 `@Inheritance` 中做选择**:
    *   **默认选择 `JOINED` 策略**。它提供了最健康、最符合数据库设计原则的模型。现代数据库的 JOIN 性能已经非常好，对于大多数应用来说，这点性能开销完全可以接受，换来的是数据模型的清晰和健壮性。
    *   只有当你的继承体系非常简单（例如，一个父类，两个子类，每个子类只有一两个特有字段），且多态查询的性能要求极为苛刻时，可以考虑 `SINGLE_TABLE`。
    *   **坚决避免 `TABLE_PER_CLASS`**，除非你完全理解其所有缺点，并且有充分的理由。它带来的麻烦远大于好处。