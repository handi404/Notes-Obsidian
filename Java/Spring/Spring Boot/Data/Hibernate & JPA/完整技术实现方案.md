以下是基于 Spring Boot 的完整技术实现方案，包含 **实体类定义**、**DTO 映射**、**复杂查询操作**及 **高级特性**，并明确代码位置和依赖要求：

---

### 一、项目结构 & 依赖
```bash
src/main/java
├── com/example/demo
│   ├── config          # 配置类
│   ├── domain          # JPA 实体类
│   ├── dto             # DTO 对象
│   ├── repository      # JPA Repository
│   └── service         # 业务逻辑层
```

#### 关键依赖 (`pom.xml`)
```xml
<!-- 基础依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- 高级查询依赖 -->
<dependency>
    <groupId>com.querydsl</groupId>
    <artifactId>querydsl-jpa</artifactId>
    <version>5.0.0</version>
</dependency>
<dependency>
    <groupId>com.querydsl</groupId>
    <artifactId>querydsl-apt</artifactId>
    <version>5.0.0</version>
    <scope>provided</scope>
</dependency>

<!-- DTO 映射工具 -->
<dependency>
    <groupId>org.modelmapper</groupId>
    <artifactId>modelmapper</artifactId>
    <version>3.1.1</version>
</dependency>
```

---

### 二、实体类与 DTO 定义
#### 1. 实体类 (`domain/User.java`)
```java
@Entity
@DynamicUpdate  // 仅更新变化的字段
@Where(clause = "is_deleted = false")  // 自动过滤软删除记录
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private Integer age;
    private String email;
    
    @Enumerated(EnumType.STRING)
    private UserStatus status;
    
    @Column(name = "is_deleted")
    private Boolean isDeleted = false;
    
    // Getters & Setters
}

public enum UserStatus { ACTIVE, INACTIVE, PENDING }
```

#### 2. DTO 类 (`dto/UserDTO.java`)
```java
// 查询结果投影
public record UserDTO(String name, String email) {}

// 更新专用 DTO
@Data
public class UserUpdateDTO {
    @NotBlank
    private String name;
    
    @Email
    private String email;
}
```

---

### 三、复杂查询实现
#### 1. 条件查询 (`repository/UserRepository.java`)
```java
public interface UserRepository extends JpaRepository<User, Long>, 
                                       JpaSpecificationExecutor<User>,
                                       QuerydslPredicateExecutor<User> {
    
    // 方法名派生查询（简单条件）
    List<User> findByStatusAndAgeGreaterThan(UserStatus status, int age);
    
    // JPQL 自定义查询
    @Query("SELECT u FROM User u WHERE u.email LIKE %:domain")
    List<User> findByEmailDomain(@Param("domain") String domain);
    
    // DTO 投影查询
    @Query("SELECT new com.example.demo.dto.UserDTO(u.name, u.email) FROM User u WHERE u.age >= :age")
    List<UserDTO> findUsersByMinAge(@Param("age") int age);
}
```

#### 2. 动态条件构造器 (`service/UserService.java`)
```java
// 使用 Specification 构建动态查询
public Page<UserDTO> searchUsers(String keyword, int minAge, Pageable pageable) {
    Specification<User> spec = (root, query, cb) -> {
        List<Predicate> predicates = new ArrayList<>();
        
        if (keyword != null) {
            predicates.add(cb.or(
                cb.like(root.get("name"), "%" + keyword + "%"),
                cb.like(root.get("email"), "%" + keyword + "%")
            ));
        }
        
        if (minAge > 0) {
            predicates.add(cb.ge(root.get("age"), minAge));
        }
        
        return cb.and(predicates.toArray(new Predicate[0]));
    };
    
    // 转换为 DTO
    return userRepository.findAll(spec, pageable)
            .map(user -> new UserDTO(user.getName(), user.getEmail()));
}
```

---

### 四、更新与删除操作
#### 1. 批量更新 (`service/UserService.java`)
```java
@Transactional
public int bulkUpdateStatus(UserStatus oldStatus, UserStatus newStatus) {
    return userRepository.updateUserStatus(oldStatus, newStatus);
}

// Repository 层实现
public interface UserRepository ... {
    @Modifying(clearAutomatically = true)
    @Query("UPDATE User u SET u.status = :newStatus WHERE u.status = :oldStatus")
    int updateUserStatus(@Param("oldStatus") UserStatus oldStatus, 
                        @Param("newStatus") UserStatus newStatus);
}
```

#### 2. 软删除实现
```java
// 自定义删除方法
@Transactional
public void softDelete(Long userId) {
    userRepository.findById(userId).ifPresent(user -> {
        user.setIsDeleted(true);
        userRepository.save(user);
    });
}
```

---

### 五、分页与排序
#### 1. 分页查询控制层 (`controller/UserController.java`)
```java
@GetMapping("/users")
public ResponseEntity<Page<UserDTO>> getUsers(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "10") int size,
    @RequestParam(defaultValue = "name,asc") String[] sort) {
    
    // 解析排序参数
    Sort sorting = Sort.by(sort[0].split(",")[0])
        .with(Sort.Direction.fromString(sort[0].split(",")[1]));
    
    Pageable pageable = PageRequest.of(page, size, sorting);
    return ResponseEntity.ok(userService.searchUsers(null, 0, pageable));
}
```

---

### 六、高级特性实现
#### 1. Querydsl 动态查询 (`service/UserService.java`)
```java
public List<UserDTO> querydslAdvancedSearch(String namePattern, UserStatus status) {
    QUser user = QUser.user;
    BooleanExpression predicate = user.name.containsIgnoreCase(namePattern)
        .and(user.status.eq(status))
        .and(user.isDeleted.isFalse());
    
    return userRepository.findAll(predicate).stream()
            .map(u -> new UserDTO(u.getName(), u.getEmail()))
            .collect(Collectors.toList());
}
```

#### 2. DTO 映射工具集成 (`config/MapperConfig.java`)
```java
@Configuration
public class MapperConfig {
    @Bean
    public ModelMapper modelMapper() {
        ModelMapper mapper = new ModelMapper();
        mapper.getConfiguration()
            .setSkipNullEnabled(true)
            .setMatchingStrategy(MatchingStrategies.STRICT);
        return mapper;
    }
}

// Service 层使用
public UserDTO getUserDetails(Long id) {
    User user = userRepository.findById(id).orElseThrow();
    return modelMapper.map(user, UserDTO.class);
}
```

---

### 七、关键要点说明
1. **代码位置**：
   - 实体类：`domain` 包
   - DTO：`dto` 包
   - Repository：`repository` 包
   - 业务逻辑：`service` 包
   - 配置类：`config` 包

2. **依赖要求**：
   - Querydsl 依赖必须添加
   - ModelMapper 可选（根据项目需求）
   - 需配置 Querydsl APT 插件生成 `Q` 类

3. **最佳实践**：
   - 使用 `@DynamicUpdate` 优化更新性能
   - 分页查询始终返回 `Page` 对象保持数据一致性
   - DTO 投影优先于直接返回实体对象（安全性和性能优化）

4. **事务管理**：
   - 所有写操作必须添加 `@Transactional`
   - 批量操作使用 `@Modifying(clearAutomatically = true)`

---

该方案实现了以下核心功能：
- 类型安全的动态条件查询（Specification/Querydsl）
- 高性能批量操作
- 自动化的 DTO 映射
- 可扩展的分页排序系统
- 企业级软删除实现

通过分层设计和合理使用 JPA/Hibernate 特性，可满足复杂业务场景的需求，同时保持代码的整洁性和可维护性。