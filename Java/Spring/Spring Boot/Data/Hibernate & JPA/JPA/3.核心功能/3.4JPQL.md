探讨 **JPQL (Java Persistence Query Language / Jakarta Persistence Query Language)**。JPQL 是 JPA 规范中定义的一种强大的、面向对象的查询语言，它允许开发者以独立于特定数据库 SQL 方言的方式来查询持久化实体。

---

#### 3.4 JPQL (Java Persistence Query Language)

**核心特点：**

1.  **面向对象**: JPQL 操作的是**实体 (Entity) 的名称及其持久化属性 (persistent fields/properties)**，而不是直接操作数据库的表名和列名。这使得查询更贴近应用的领域模型。
2.  **数据库无关性**: JPQL 查询由 JPA 提供者 (如 Hibernate) 转换为底层数据库支持的特定 SQL 方言。理论上，同一条 JPQL 语句可以在不同的数据库上执行。
3.  **语法类似 SQL**: JPQL 的基本语法结构 (如 `SELECT`, `FROM`, `WHERE`, `GROUP BY`, `ORDER BY`) 与 SQL 非常相似，熟悉 SQL 的开发者可以较快上手。
4.  **类型安全 (一定程度上)**: 虽然 JPQL 本身是字符串，但 JPA 提供者在解析时会检查实体名和属性名的有效性。结合 `TypedQuery` 可以获得编译时的返回类型检查。
5.  **支持丰富的查询功能**: 包括连接 (JOINs)、聚合函数、子查询、更新和删除操作等。

**如何执行 JPQL 查询：**

通过 `EntityManager` 实例创建 `Query` 或 `TypedQuery` 对象来执行 JPQL。

```java
// 获取 EntityManager (假设已注入或创建)
// EntityManager entityManager = ...;

// 1. 创建 TypedQuery (如果知道查询结果的类型)
String jpqlString = "SELECT e FROM Employee e WHERE e.department.name = :deptName AND e.salary > :minSalary";
TypedQuery<Employee> query = entityManager.createQuery(jpqlString, Employee.class); // 第二个参数指定结果类型
query.setParameter("deptName", "IT");
query.setParameter("minSalary", 60000.0);
List<Employee> employees = query.getResultList(); // 获取结果列表
// Employee singleEmployee = query.getSingleResult(); // 如果确定只有一条结果，否则可能抛异常

// 2. 创建 Query (如果结果类型不确定，或者查询的是多个值/聚合值)
String countJpql = "SELECT COUNT(e) FROM Employee e WHERE e.status = :status";
Query countQuery = entityManager.createQuery(countJpql);
countQuery.setParameter("status", "ACTIVE");
Long count = (Long) countQuery.getSingleResult(); // 需要类型转换

// 在 Spring Data JPA Repository 中使用 @Query 注解是更常见的方式
// @Query("SELECT e FROM Employee e WHERE e.department.name = :deptName")
// List<Employee> findByDepartmentName(@Param("deptName") String deptName);
```

##### 3.4.1 `SELECT` 语句

`SELECT` 语句用于从数据库中检索数据并将其映射为实体对象或投影。

**基本语法：**
`SELECT select_expression FROM from_clause [WHERE where_clause] [GROUP BY groupby_clause] [HAVING having_clause] [ORDER BY orderby_clause]`

*   **`select_expression`**: 指定要查询的内容。
    *   **查询整个实体**: `SELECT e FROM Employee e` (这里的 `e` 是一个范围变量，代表 `Employee` 实体)。返回 `Employee` 对象列表。
    *   **查询实体的特定属性 (投影)**: `SELECT e.name, e.salary FROM Employee e`。返回 `Object[]` 列表，每个数组元素对应一个属性。
    *   **使用构造函数表达式创建 DTO (推荐的投影方式)**:
        ```jpql
        SELECT new com.example.dto.EmployeeSummaryDTO(e.id, e.name, e.department.name)
        FROM Employee e
        WHERE e.status = 'ACTIVE'
        ```
        这会直接将查询结果封装到 `EmployeeSummaryDTO` 对象中 (DTO 需要有匹配参数的构造函数)。
    *   **聚合函数**: `SELECT COUNT(e) FROM Employee e`, `SELECT AVG(e.salary) FROM Employee e`, `SELECT MAX(e.department.id), d.name FROM Employee e JOIN e.department d GROUP BY d.name`。
    *   **`DISTINCT`**: `SELECT DISTINCT e.department FROM Employee e` (查询所有不重复的部门)。

*   **`FROM from_clause`**:
    *   指定查询的实体。必须至少有一个实体。
    *   **范围变量 (Identification Variable / Alias)**: 每个实体都需要一个范围变量，如 `Employee e`。
    *   可以查询多个不相关的实体 (笛卡尔积，不推荐): `FROM Employee e, Department d`。

##### 3.4.2 `UPDATE` 语句 (Bulk Update)

JPQL 支持批量更新操作，直接在数据库层面执行，**绕过持久化上下文 (一级缓存)**。

**基本语法：**
`UPDATE entity_name [[AS] identification_variable] SET update_item {, update_item}* [WHERE where_clause]`

*   `entity_name`: 要更新的实体名称。
*   `update_item`: `identification_variable.attribute_name = new_value`。
*   `new_value`: 可以是字面量、参数、或另一个属性/表达式。

**示例：**
```java
// EntityManager em = ...;
String jpqlUpdate = "UPDATE Employee e SET e.salary = e.salary * 1.10 WHERE e.department.name = :deptName";
Query query = em.createQuery(jpqlUpdate);
query.setParameter("deptName", "Sales");

// 执行更新操作需要在事务中
// em.getTransaction().begin(); // (如果不是容器管理的事务)
int updatedCount = query.executeUpdate(); // 返回受影响的行数
// em.getTransaction().commit();
```
**重要注意事项：**
1.  **绕过一级缓存**: 批量 `UPDATE` 直接操作数据库。执行后，持久化上下文中**已加载的、符合更新条件的实体实例的状态将不会自动更新**。它们与数据库中的数据会变得不一致。
2.  **处理缓存不一致**:
    *   在执行批量更新后，如果需要操作这些实体，最好**清空持久化上下文** (`entityManager.clear()`) 或**刷新特定实体** (`entityManager.refresh(entity)`)，以确保从数据库加载最新数据。
    *   在 Spring Data JPA 中，可以在 `@Modifying` 注解上设置 `clearAutomatically = true`。
3.  **版本号 (`@Version`)**: 批量 `UPDATE` **不会自动更新实体版本号**，因此乐观锁机制对这些操作无效。
4.  **生命周期回调**: 批量 `UPDATE` **不会触发 JPA 的生命周期回调方法** (如 `@PreUpdate`, `@PostUpdate`)。

##### 3.4.3 `DELETE` 语句 (Bulk Delete)

JPQL 支持批量删除操作，与批量更新类似，也是直接操作数据库。

**基本语法：**
`DELETE FROM entity_name [[AS] identification_variable] [WHERE where_clause]`

**示例：**
```java
// EntityManager em = ...;
String jpqlDelete = "DELETE FROM Employee e WHERE e.status = :status AND e.lastLoginDate < :cutoffDate";
Query query = em.createQuery(jpqlDelete);
query.setParameter("status", "INACTIVE");
query.setParameter("cutoffDate", LocalDate.now().minusYears(1));

// em.getTransaction().begin();
int deletedCount = query.executeUpdate();
// em.getTransaction().commit();
```
**重要注意事项 (与批量 `UPDATE` 类似)：**
1.  **绕过一级缓存**: 持久化上下文中已加载的、被删除的实体实例仍然存在，但数据库中对应的记录已消失。
2.  **处理缓存不一致**: 清空上下文或刷新。
3.  **级联删除 (`CascadeType.REMOVE`)**: 批量 `DELETE` **通常不会触发 JPA 定义的级联删除**。如果需要级联删除，你需要手动编写额外的 `DELETE` 语句，或者先加载实体再逐个 `remove()` (这会失去批量操作的性能优势)。
4.  **生命周期回调**: 不会触发 `@PreRemove`, `@PostRemove`。

##### 3.4.4 `WHERE` 子句

用于指定查询、更新或删除的条件。

*   **操作符**:
    *   比较操作符: `=`, `<>`, `<`, `<=`, `>`, `>=`
    *   逻辑操作符: `AND`, `OR`, `NOT`
    *   范围操作符: `BETWEEN ... AND ...`, `NOT BETWEEN ... AND ...`
    *   `LIKE`, `NOT LIKE` (通配符: `%` 匹配任意字符序列, `_` 匹配单个字符)。可以使用 `ESCAPE` 关键字指定转义字符。
    *   `IN (...)`, `NOT IN (...)`
    *   `IS NULL`, `IS NOT NULL`
    *   `IS EMPTY`, `IS NOT EMPTY` (用于集合类型的关联属性)
    *   `MEMBER OF`, `NOT MEMBER OF` (判断一个元素是否属于一个集合关联属性)
*   **路径表达式 (Path Expressions)**: 用于导航实体及其属性。
    *   单值路径: `e.name`, `e.department.location.city` (导航到关联对象的属性)。
    *   集合值路径: `e.projects` (如果 `projects` 是一个集合关联)。
*   **参数**: 使用命名参数 (`:paramName`) 或位置参数 (`?index`)。
*   **子查询 (Subqueries)**: `WHERE` 子句中可以使用子查询，通常与 `EXISTS`, `NOT EXISTS`, `IN`, `NOT IN`, `ALL`, `ANY`, `SOME` 结合使用。
    ```jpql
    SELECT e FROM Employee e
    WHERE e.salary > (SELECT AVG(emp.salary) FROM Employee emp WHERE emp.department = e.department)
    ```
*   **函数**: JPQL 支持一些内置函数 (如 `LOWER()`, `UPPER()`, `SUBSTRING()`, `TRIM()`, `LENGTH()`, `ABS()`, `SQRT()`, `MOD()`, `CURRENT_DATE`, `CURRENT_TIME`, `CURRENT_TIMESTAMP`, `SIZE()` (用于集合大小)) 以及数据库特定的函数 (通过 `FUNCTION('db_func_name', args)` 调用，但这会降低可移植性)。

##### 3.4.5 `GROUP BY` 和 `HAVING` 子句

*   **`GROUP BY`**: 用于将结果集按一个或多个属性分组，通常与聚合函数 (`COUNT`, `SUM`, `AVG`, `MAX`, `MIN`) 一起使用。
    ```jpql
    SELECT e.department.name, COUNT(e)
    FROM Employee e
    GROUP BY e.department.name
    ```
*   **`HAVING`**: 用于在 `GROUP BY` 分组后对分组结果进行过滤。
    ```jpql
    SELECT e.department.name, AVG(e.salary) as avgSalary
    FROM Employee e
    GROUP BY e.department.name
    HAVING AVG(e.salary) > 50000
    ```

##### 3.4.6 `ORDER BY` 子句

用于对查询结果进行排序。

*   可以按实体的持久化属性排序。
*   可以按多个属性排序，并指定 `ASC` (升序，默认) 或 `DESC` (降序)。
    ```jpql
    SELECT e FROM Employee e
    WHERE e.status = 'ACTIVE'
    ORDER BY e.lastName ASC, e.firstName DESC
    ```
*   **`NULLS FIRST` / `NULLS LAST`**: (JPA 2.0+) 可以指定 `NULL` 值的排序位置。

##### 3.4.7 `JOIN` (连接)

JPQL 支持多种类型的连接操作，用于查询跨多个关联实体的数据。

*   **`[INNER] JOIN` / `JOIN`**: 内连接。只返回在连接条件中匹配的实体。
    ```jpql
    SELECT e FROM Employee e JOIN e.department d WHERE d.location.city = 'New York'
    -- 等同于: SELECT e FROM Employee e, IN(e.department) d WHERE d.location.city = 'New York' (早期语法)
    ```
*   **`LEFT [OUTER] JOIN` / `LEFT JOIN`**: 左外连接。返回左边实体的所有记录，以及右边实体中匹配的记录。如果右边没有匹配，则右边实体的属性为 `NULL`。
    ```jpql
    SELECT e, d.name FROM Employee e LEFT JOIN e.department d
    ```
*   **`FETCH JOIN` (非常重要，用于解决 N+1 问题)**:
    *   `FETCH JOIN` 是一种特殊的连接，它不仅在 `WHERE` 子句中用于条件过滤，还会**在一次查询中将关联的实体或集合一同加载到持久化上下文中**，从而避免了后续访问关联对象时触发额外的懒加载查询 (N+1 问题)。
    *   **语法**: `JOIN FETCH association_path` 或 `LEFT JOIN FETCH association_path`。
    *   **对于集合关联 (如 `@OneToMany`)**: 使用 `FETCH JOIN` 时，如果主实体可能有多条记录对应同一个集合（例如，一个 `Employee` 对应多个 `Project`），主查询返回的 `Employee` 对象可能会重复。通常需要配合 `SELECT DISTINCT e` 来去重主实体。
    ```jpql
    // 加载 Employee 及其关联的 Department (避免访问 e.getDepartment() 时再次查询)
    SELECT e FROM Employee e JOIN FETCH e.department d WHERE e.id = :id

    // 加载 Department 及其所有关联的 Employees (避免访问 d.getEmployees() 时再次查询)
    // 注意：这可能导致 Department 重复，如果一个 Department 有多个 Employee
    SELECT DISTINCT d FROM Department d LEFT JOIN FETCH d.employees e WHERE d.name = 'Sales'
    ```
    *   **限制**:
        *   `FETCH JOIN` 的目标关联路径不能在 `WHERE`, `GROUP BY`, `HAVING` 子句中再次使用别名进行引用 (某些 JPA 提供者可能有扩展支持)。
        *   通常不建议在一个查询中使用多个 `FETCH JOIN` 来加载集合类型的关联 (如 `JOIN FETCH e.projects JOIN FETCH e.tasks`)，因为这可能导致非常复杂的笛卡尔积，性能低下。可以分多次查询或使用 Entity Graphs (JPA 2.1+)。
        *   `FETCH JOIN` 与分页 (`setFirstResult`, `setMaxResults`) 一起使用时，其行为可能因 JPA 提供者而异，尤其是在 `FETCH JOIN` 集合关联时，分页可能在内存中进行，而不是在数据库层面。Hibernate 对此有特定处理。

*   **`RIGHT [OUTER] JOIN`**: 右外连接。JPA 规范中定义，但并非所有数据库都高效支持，也不如左连接常用。
*   **`ON` 子句 (JPA 2.1+)**: 允许在 `JOIN` (特别是 `LEFT JOIN`) 中定义更复杂的连接条件，而不仅仅是基于 JPA 实体模型中已定义的关联。
    ```jpql
    SELECT e, m FROM Employee e LEFT JOIN e.directManager m ON m.status = 'ACTIVE'
    -- 这里 m.status = 'ACTIVE' 是额外的连接条件，即使 e.directManager 存在但 status 不是 ACTIVE，m 也会为 null
    ```
*   **Theta-style Joins (笛卡尔积后用 WHERE 过滤，不推荐)**:
    `SELECT e, d FROM Employee e, Department d WHERE e.department.id = d.id` (效果类似 INNER JOIN，但可读性和性能可能较差)。

##### 3.4.8 参数绑定

*   **命名参数 (Named Parameters)**: `:paramName`
    *   在 JPQL 中使用 `:paramName` 作为占位符。
    *   通过 `query.setParameter("paramName", value)` 绑定值。
    *   **推荐使用**，因为更易读且不易因参数顺序改变而出错。
*   **位置参数 (Positional Parameters)**: `?index` (index 从 1 开始)
    *   在 JPQL 中使用 `?1`, `?2` 等作为占位符。
    *   通过 `query.setParameter(index, value)` 绑定值。
    *   当参数较多或顺序可能调整时，容易出错。

##### 3.4.9 投影 (Projections)

投影是指查询并返回实体的部分属性，而不是整个实体对象。这对于性能优化、减少数据传输量、或直接获取 DTO 非常有用。

1.  **查询部分属性 (返回 `Object[]` 或 `List<Object[]>`):**
    ```jpql
    SELECT e.name, e.salary FROM Employee e WHERE e.department.id = :deptId
    ```
    `query.getResultList()` 会返回 `List<Object[]>`，每个 `Object[]` 包含 `name` 和 `salary`。

2.  **使用构造函数表达式 (Constructor Expressions - 推荐的 DTO 投影方式):**
    在 `SELECT` 子句中使用 `NEW` 关键字和 DTO 类的全限定名以及匹配的构造函数参数。
    ```java
    // DTO 类
    package com.example.dto;
    public class EmployeeBriefDTO {
        private Long id;
        private String name;
        public EmployeeBriefDTO(Long id, String name) {
            this.id = id;
            this.name = name;
        }
        // getters
    }

    // JPQL
    String jpql = "SELECT NEW com.example.dto.EmployeeBriefDTO(e.id, e.name) FROM Employee e WHERE e.salary > :minSalary";
    TypedQuery<EmployeeBriefDTO> query = entityManager.createQuery(jpql, EmployeeBriefDTO.class);
    query.setParameter("minSalary", 70000.0);
    List<EmployeeBriefDTO> results = query.getResultList();
    ```
    *   DTO 类必须有一个公开的构造函数，其参数类型和顺序与 `SELECT NEW ...` 中列出的属性匹配。
    *   这是将查询结果直接映射到自定义 DTO 的最清晰和类型安全的方式。

3.  **使用元组 (Tuples - JPA 2.0+)**:
    如果不想创建专门的 DTO 类，可以使用 `Tuple` 接口来接收投影结果。
    ```jpql
    SELECT e.name AS empName, e.salary AS empSalary FROM Employee e
    ```
    ```java
    TypedQuery<Tuple> q = em.createQuery(
        "SELECT e.name AS empName, e.salary AS empSalary FROM Employee e", Tuple.class);
    List<Tuple> results = q.getResultList();
    for (Tuple t : results) {
       String name = t.get("empName", String.class); // 通过别名获取
       Double salary = (Double) t.get("empSalary"); // 通过别名获取，需要强转
       // 或者通过索引: t.get(0, String.class), t.get(1, Double.class)
    }
    ```
    *   需要在 `SELECT` 子句中为投影的属性指定别名 (AS aliasName)，然后通过别名从 `Tuple` 中获取值。

4.  **Spring Data JPA 中的接口投影 (Interface-based Projections) 和类投影 (Class-based Projections/DTOs)**:
    Spring Data JPA 提供了更便捷的投影方式，允许你定义一个接口或 DTO 类，并在 Repository 方法的返回类型中使用它，Spring Data JPA 会自动处理投影逻辑 (无论是通过构造函数表达式还是其他机制)。
    ```java
    // 接口投影
    public interface UserNameOnly {
        String getUsername(); // getter 方法名对应实体属性名
        // String getFullName(); // (可选) @Value("#{target.firstName + ' ' + target.lastName}") SpEL 表达式
    }
    // Repository 方法
    // List<UserNameOnly> findByStatus(String status);

    // DTO 类投影 (DTO 需要有匹配的构造函数或 setter/getter)
    // public class UserDTO { private String username; private String email; /*构造函数或getter/setter*/ }
    // List<UserDTO> findByAgeGreaterThan(int age);
    ```

---

JPQL 是 JPA 中进行数据查询的核心工具。熟练掌握其语法和特性，特别是 `FETCH JOIN` 和投影，对于编写高效、可维护的 JPA 应用至关重要。