详解 Spring Data JPA 的核心功能。这是 Spring Data JPA 最具魅力和生产力的部分，它极大地简化了数据访问层的开发。

---

### 3. Spring Data JPA 核心功能详解

#### 3.1 Repository 接口

Spring Data JPA 的核心是 **Repository 抽象**。你只需要定义一个接口，并让它继承 Spring Data JPA 提供的特定 Repository 接口 (如 `JpaRepository`)，Spring Data JPA 就会在运行时自动为这个接口生成代理实现类，从而提供丰富的数据库操作能力。

**Repository 接口层级：**

Spring Data JPA 的 Repository 接口有一个继承体系：

1.  **`Repository<T, ID>`**:
    *   最顶层的标记接口。表明该接口是一个 Repository。
    *   `T`: Repository 管理的实体类型。
    *   `ID`: 实体主键的类型。
    *   它本身不提供任何方法，但允许 Spring Data 识别并创建代理。

2.  **`CrudRepository<T, ID>`**:
    *   继承自 `Repository`。
    *   提供了非常基础的 CRUD (Create, Read, Update, Delete) 操作方法。
    *   例如：`save(S entity)`, `saveAll(Iterable<S> entities)`, `findById(ID id)`, `existsById(ID id)`, `findAll()`, `findAllById(Iterable<ID> ids)`, `count()`, `deleteById(ID id)`, `delete(T entity)`, `deleteAllById(Iterable<? extends ID> ids)`, `deleteAll(Iterable<? extends T> entities)`, `deleteAll()`。

3.  **`PagingAndSortingRepository<T, ID>`**:
    *   继承自 `CrudRepository`。
    *   在 CRUD 的基础上，增加了**分页 (Pagination)** 和 **排序 (Sorting)** 的功能。
    *   例如：`findAll(Sort sort)`, `findAll(Pageable pageable)`。

4.  **`JpaRepository<T, ID>`**:
    *   继承自 `PagingAndSortingRepository`。
    *   这是**最常用**的接口，专门为 JPA 设计，提供了更多 JPA 特有的功能。
    *   例如：`findAll()` (返回 `List<T>`), `findAll(Sort sort)` (返回 `List<T>`), `saveAll(Iterable<S> entities)` (返回 `List<S>`), `flush()`, `saveAndFlush(S entity)`, `deleteInBatch(Iterable<T> entities)` (现在是 `deleteAllInBatch`), `getOne(ID id)` (现在是 `getReferenceById`), `exists(Example<S> example)` (QBE 查询)。
    *   它还整合了 `CrudRepository` 和 `PagingAndSortingRepository` 的所有功能。

**创建你的 Repository 接口：**

通常，你会为每个实体类创建一个 Repository 接口。

```java
package com.example.yourproject.repository; // 包路径自定义

import com.example.yourproject.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository; // (可选) 虽然不强制，但加上 @Repository 更明确

import java.util.List;
import java.util.Optional;

@Repository // 标记这是一个 Spring 管理的 Repository Bean
public interface UserRepository extends JpaRepository<User, Long> { // User 是实体类，Long 是主键类型

    // --- 基本 CRUD 操作 (已由 JpaRepository 自动提供) ---
    // User save(User user);
    // Optional<User> findById(Long id);
    // List<User> findAll();
    // void deleteById(Long id);
    // long count();
    // boolean existsById(Long id);

    // --- 下面我们将看到如何定义自定义查询方法 ---
}
```
**关键点：**
*   接口继承 `JpaRepository<EntityType, IdType>`。
*   Spring Boot 会自动扫描 `@Repository` 注解的接口 (或者继承了 Spring Data Repository 接口且位于 `@EnableJpaRepositories` 指定包下的接口)，并为其创建代理实现。在 Spring Boot 中，如果你的 Repository 接口与主应用类在同一个包或其子包下，通常不需要显式配置 `@EnableJpaRepositories`。

#### **基本 CRUD 操作 (自动生成实现)：**

一旦你定义了继承 `JpaRepository` 的接口，你就可以直接注入并使用它提供的 CRUD 方法，无需编写任何实现代码。

```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    @Transactional
    public User createUser(User user) {
        return userRepository.save(user); // 保存实体 (插入或更新)
    }

    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id); // 根据ID查找，返回 Optional<User>
    }

    public List<User> getAllUsers() {
        return userRepository.findAll(); // 查询所有用户
    }

    @Transactional
    public void deleteUser(Long id) {
        userRepository.deleteById(id); // 根据ID删除
    }

    public long countUsers() {
        return userRepository.count(); // 统计用户总数
    }

    // save() 方法：
    // - 如果实体是新的 (主键为 null 或不存在于持久化上下文)，则执行 INSERT。
    // - 如果实体已存在 (主键非 null 且在持久化上下文中)，则执行 UPDATE。
    // - 返回持久化后的实体 (可能包含生成的主键或更新的时间戳)。

    // findById() 返回 Optional<T>:
    // 这是 Java 8 引入的特性，用于优雅地处理可能为 null 的结果，避免空指针异常。
    // 你可以使用 .isPresent(), .orElse(), .orElseThrow() 等方法处理 Optional。
}
```

**查询方法派生 (Query Derivation / Derived Queries)：**

这是 Spring Data JPA 一个非常强大且便捷的特性。你可以**根据特定的方法命名约定，在 Repository 接口中定义查询方法，Spring Data JPA 会自动解析方法名并为你生成相应的 JPQL 查询并执行。**

**命名约定规则：**

*   **前缀**: `find...By`, `read...By`, `query...By`, `count...By`, `get...By`, `exists...By`, `delete...By`, `remove...By`。
    *   `find`, `read`, `query`, `get`: 通常用于返回单个或多个实体。
    *   `count`: 用于返回符合条件的记录数 (通常返回 `long` 或 `int`)。
    *   `exists`: 用于判断是否存在符合条件的记录 (返回 `boolean`)。
    *   `delete`, `remove`: 用于删除符合条件的记录 (需要配合 `@Modifying` 和事务)。
*   **属性名**: 方法名中紧跟在 `By` 之后的部分是实体的属性名 (驼峰命名)。
*   **条件关键字**: 可以使用一系列关键字来连接属性和条件，例如：
    *   `And`: `findByLastnameAndFirstname` -> `WHERE lastname = ? AND firstname = ?`
    *   `Or`: `findByLastnameOrFirstname` -> `WHERE lastname = ? OR firstname = ?`
    *   `Is`, `Equals`: `findByFirstnameIs`, `findByFirstnameEquals` -> `WHERE firstname = ?` (通常 `Is` / `Equals` 可以省略)
    *   `Between`: `findByStartDateBetween` -> `WHERE startDate BETWEEN ? AND ?` (需要两个参数)
    *   `LessThan`, `LessThanEqual`, `GreaterThan`, `GreaterThanEqual`: `findByAgeLessThan` -> `WHERE age < ?`
    *   `IsNull`, `IsNotNull` (或 `NotNull`): `findByAddressIsNull` -> `WHERE address IS NULL` (不需要参数)
    *   `Like`, `NotLike`: `findByNameLike` -> `WHERE name LIKE ?` (参数需要自己加 `%`)
    *   `StartingWith`, `EndingWith`, `Containing`: `findByNameStartingWith` -> `WHERE name LIKE '?%'` (自动加 `%`)
    *   `OrderBy`: `findByLastnameOrderByFirstnameAsc` -> `WHERE lastname = ? ORDER BY firstname ASC`
    *   `Not`: `findByNameNot` -> `WHERE name <> ?`
    *   `In`, `NotIn`: `findByAgeIn(Collection<Integer> ages)` -> `WHERE age IN (...)`
    *   `True`, `False`: `findByActiveTrue()` -> `WHERE active = true`
    *   `IgnoreCase`: `findByNameIgnoreCase` -> `WHERE UPPER(name) = UPPER(?)`
*   **嵌套属性**: 可以通过 `_` 或直接驼峰连接来访问关联实体的属性，例如 `findByAddress_ZipCode(String zipCode)` 或 `findByAddressZipCode(String zipCode)` (如果 `User` 有一个 `Address` 类型的 `address` 属性，`Address` 有 `zipCode` 属性)。
*   **返回类型**:
    *   单个实体: `User findByEmail(String email);`
    *   `Optional<User>`: `Optional<User> findByUsername(String username);` (推荐，更安全)
    *   集合: `List<User> findByStatus(String status);`, `Collection<User> ...`, `Set<User> ...`
    *   `Stream<User>`: (需要 `@Transactional(readOnly=true)`) `Stream<User> findAllByStatus(String status);`
    *   `Page<User>`: (需要 `Pageable` 参数) `Page<User> findByAgeGreaterThan(int age, Pageable pageable);`
    *   `Slice<User>`: (类似 Page，但不含总记录数) `Slice<User> findByStatus(String status, Pageable pageable);`
    *   `long` 或 `int`: `long countByStatus(String status);`
    *   `boolean`: `boolean existsByEmail(String email);`
*   **限制结果集**:
    *   `findFirst...By...` 或 `findTop...By...`: 返回第一个匹配的实体。
    *   `findFirstN...By...` 或 `findTopN...By...`: 返回前 N 个匹配的实体 (如 `findTop5ByOrderByAgeDesc()`)。

**派生查询示例 (`UserRepository.java`)**:
```java
public interface UserRepository extends JpaRepository<User, Long> {

    // 根据用户名查找用户
    Optional<User> findByUsername(String username);

    // 根据邮箱查找用户 (忽略大小写)
    User findByEmailIgnoreCase(String email);

    // 根据状态查找用户列表，并按创建日期降序排序
    List<User> findByStatusOrderByDateCreatedDesc(String status);

    // 查找年龄大于指定值的用户数量
    long countByAgeGreaterThan(int age);

    // 查找用户名包含指定关键字的用户 (参数需要手动加 %)
    List<User> findByUsernameLike(String usernameKeyword);

    // 查找用户名以指定前缀开头的用户
    List<User> findByUsernameStartingWith(String prefix);

    // 查找ID在指定集合中的用户
    List<User> findByIdIn(Collection<Long> ids);

    // 查找创建日期在某个范围内的用户
    List<User> findByDateCreatedBetween(LocalDateTime startDate, LocalDateTime endDate);

    // 查找前10个活跃用户，按最后更新时间降序
    List<User> findTop10ByStatusOrderByLastUpdatedDesc(String status);

    // 检查是否存在指定邮箱的用户
    boolean existsByEmail(String email);

    // 删除所有状态为 PENDING 的用户 (需要 @Modifying 和事务)
    // @Modifying
    // @Transactional
    // void deleteByStatus(String status);
}
```
Spring Data JPA 会在启动时解析这些方法名，如果无法正确解析（例如，方法名不符合约定，或者属性名不存在），应用会启动失败并报错，这有助于早期发现问题。

#### **`@Query` 注解: 使用 JPQL 或原生 SQL 定义查询**

当派生查询无法满足复杂的查询需求，或者你希望对查询有更精细的控制时，可以使用 `@Query` 注解直接编写 JPQL 或原生 SQL。

*   **JPQL (Java Persistence Query Language)**:
    *   面向对象的查询语言，操作的是实体和属性。
    *   更具可移植性。
    ```java
    import org.springframework.data.jpa.repository.Query;
    import org.springframework.data.repository.query.Param;
    // ...
    public interface UserRepository extends JpaRepository<User, Long> {

        // 使用 JPQL 查询，?1, ?2 代表参数位置
        @Query("SELECT u FROM User u WHERE u.status = ?1 AND u.email LIKE %?2%")
        List<User> findUsersByStatusAndEmailKeyword(String status, String emailKeyword);

        // 使用命名参数 (:paramName)，更易读，推荐
        @Query("SELECT u FROM User u WHERE u.username = :uname OR u.email = :uemail")
        Optional<User> findByUsernameOrEmail(@Param("uname") String username, @Param("uemail") String email);

        // JPQL 中的 JOIN FETCH 用于解决 N+1 问题 (后面会详述)
        @Query("SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.roles WHERE u.id = :id")
        Optional<User> findByIdWithRoles(@Param("id") Long id);

        // JPQL 支持构造函数表达式，将查询结果直接映射到 DTO
        @Query("SELECT new com.example.yourproject.dto.UserSummaryDTO(u.id, u.username, u.email) FROM User u WHERE u.status = :status")
        List<UserSummaryDTO> findUserSummariesByStatus(@Param("status") String status);
    }
    ```

*   **原生 SQL (Native Query)**:
    *   当你需要使用特定数据库的函数、特性，或者 JPQL 难以表达的复杂 SQL 时使用。
    *   需要设置 `nativeQuery = true`。
    *   **结果映射**:
        *   如果查询返回的列能自动映射到实体属性，JPA 可以尝试自动映射。
        *   对于复杂映射或非实体结果，可能需要使用 `@SqlResultSetMapping` 或投影接口/类。
    ```java
    public interface UserRepository extends JpaRepository<User, Long> {

        @Query(value = "SELECT * FROM user_account u WHERE u.status = :status ORDER BY u.date_created DESC LIMIT :limit OFFSET :offset",
               nativeQuery = true)
        List<User> findActiveUsersWithNativePagination(@Param("status") String status, @Param("limit") int limit, @Param("offset") int offset);

        // 原生 SQL 返回标量值
        @Query(value = "SELECT COUNT(*) FROM user_account WHERE YEAR(date_created) = :year", nativeQuery = true)
        int countUsersCreatedInYear(@Param("year") int year);

        // 原生 SQL 与投影 (需要接口或类来接收结果)
        // interface UserEmailOnly { String getEmailAddress(); }
        // @Query(value = "SELECT email_address FROM user_account WHERE username = :username", nativeQuery = true)
        // UserEmailOnly findEmailByUsernameNative(@Param("username") String username);
    }
    ```
    **使用原生 SQL 时要注意**:
    *   失去了数据库无关性。
    *   参数占位符与 JPQL 不同，通常是 `:paramName` 或 `?` (位置)。
    *   分页和排序参数 (`Pageable`, `Sort`) 在原生 SQL 中可能需要手动处理，除非 Spring Data JPA 针对特定数据库方言做了特殊支持 (如自动添加 `LIMIT` / `OFFSET` 或 `ROWNUM`)。通常，如果使用 `Pageable`，Spring Data JPA 会尝试包装原生 SQL 来实现分页，但这可能不总是高效或可行。

#### **`@Modifying` 注解: 用于更新和删除操作**

对于执行 `UPDATE` 或 `DELETE` 操作的 `@Query` (无论是 JPQL 还是原生 SQL)，**必须添加 `@Modifying` 注解**，并通常需要与 `@Transactional` 配合使用。

```java
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.transaction.annotation.Transactional; // 导入 Spring 的事务注解
// ...
public interface UserRepository extends JpaRepository<User, Long> {

    @Modifying // 标记这是一个修改查询 (UPDATE/DELETE)
    @Transactional // 修改操作通常需要在事务中执行
    @Query("UPDATE User u SET u.status = :newStatus WHERE u.username = :username")
    int updateUserStatusByUsername(@Param("username") String username, @Param("newStatus") String newStatus);

    @Modifying
    @Transactional
    @Query("DELETE FROM User u WHERE u.lastUpdated < :cutoffDate AND u.status = 'INACTIVE'")
    int deleteInactiveUsersBefore(@Param("cutoffDate") LocalDateTime cutoffDate);

    // 派生删除方法也需要 @Modifying 和 @Transactional
    @Modifying
    @Transactional
    void deleteByStatus(String status); // 假设之前定义的派生删除方法
}
```
*   **返回值**: `@Modifying` 查询通常返回 `int`，表示受影响的行数，或者 `void`。
*   **事务**: 修改操作改变数据库状态，必须在事务中执行。`@Transactional` 注解确保了这一点。如果 Service 层调用此方法时已经有事务，则会加入现有事务。
*   **持久化上下文的同步**: `@Modifying` 查询执行后，持久化上下文 (一级缓存) 中的实体可能与数据库中的状态不一致。
    *   为了避免这种情况，可以在 `@Query` 注解中设置 `clearAutomatically = true` (或 `@Modifying(clearAutomatically = true)`)，这会在查询执行后清空持久化上下文。这样后续的查询会直接从数据库加载最新数据。
    *   或者，如果只想刷新特定实体，可以在 Service 层手动调用 `entityManager.refresh(entity)`。

**`@Param("name")` 注解: 命名参数**

在 `@Query` 注解中使用 JPQL 或原生 SQL 时，如果查询包含参数，建议使用命名参数 (`:paramName`) 而不是位置参数 (`?1`, `?2`)，因为命名参数更易读且不易出错。
对应的 Repository 方法参数需要使用 `@Param("paramName")` 注解来将方法参数与查询中的命名参数关联起来。

```java
@Query("SELECT u FROM User u WHERE u.age > :minAge AND u.status = :userStatus")
List<User> findUsersOlderThanWithStatus(@Param("minAge") int age, @Param("userStatus") String status);
```

#### **分页与排序 (`Pageable`, `Sort`)**

Spring Data JPA 提供了对分页和排序的强大支持，通过 `Pageable` 和 `Sort` 接口。

*   **`org.springframework.data.domain.Sort`**:
    *   用于定义排序规则。
    *   可以按单个或多个属性排序，指定升序 (`ASC`) 或降序 (`DESC`)。
    *   创建方式：
        *   `Sort.by("propertyName")` (默认升序)
        *   `Sort.by(Sort.Direction.DESC, "propertyName")`
        *   `Sort.by(Sort.Order.asc("prop1"), Sort.Order.desc("prop2"))`
        *   `Sort.by(List<Sort.Order> orders)`

*   **`org.springframework.data.domain.Pageable`**:
    *   封装了分页请求信息，包括页码 (从 0 开始)、每页大小、以及可选的排序信息。
    *   通常作为 Repository 方法的最后一个参数。
    *   创建方式：
        *   `PageRequest.of(int page, int size)` (无排序)
        *   `PageRequest.of(int page, int size, Sort sort)`
        *   `PageRequest.of(int page, int size, Sort.Direction direction, String... properties)`
*   **`org.springframework.data.domain.Page<T>`**:
    *   分页查询的结果对象，继承自 `Slice<T>`。
    *   包含了当前页的数据列表 (`getContent()`)、总记录数 (`getTotalElements()`)、总页数 (`getTotalPages()`)、当前页码 (`getNumber()`)、每页大小 (`getSize()`)、是否有上一页/下一页等丰富信息。

**在 Repository 方法中使用 `Pageable` 和 `Sort`:**

1.  **派生查询中的分页与排序**:
    ```java
    public interface UserRepository extends JpaRepository<User, Long> {
        // 根据状态查询，并按用户名排序
        List<User> findByStatus(String status, Sort sort);

        // 根据年龄大于某值进行分页查询 (排序信息在 Pageable 对象中)
        Page<User> findByAgeGreaterThan(int age, Pageable pageable);
    }
    ```
    **调用示例**:
    ```java
    // Sort sort = Sort.by(Sort.Direction.ASC, "username").and(Sort.by(Sort.Direction.DESC, "dateCreated"));
    // List<User> users = userRepository.findByStatus("ACTIVE", sort);

    Pageable pageRequest = PageRequest.of(0, 10, Sort.by("lastUpdated").descending()); // 第1页，每页10条，按更新时间降序
    Page<User> userPage = userRepository.findByAgeGreaterThan(18, pageRequest);

    // List<User> currentPageContent = userPage.getContent();
    // long totalUsers = userPage.getTotalElements();
    // int totalPages = userPage.getTotalPages();
    ```

2.  **`@Query` 中的分页与排序**:
    *   当 `@Query` 方法的参数包含 `Pageable` 时，Spring Data JPA 会自动处理分页。
    *   它会执行两条查询：一条是带有分页条件的数据查询，另一条是 `COUNT` 查询 (用于获取总记录数)。
    *   **JPQL 中的排序**:
        *   如果 `Pageable` 对象中包含了 `Sort` 信息，并且你的 JPQL 查询**没有** `ORDER BY` 子句，Spring Data JPA 会自动将 `Sort` 信息追加到 JPQL 的 `ORDER BY` 子句中。
        *   如果 JPQL 查询中**已经有** `ORDER BY` 子句，则 `Pageable` 中的 `Sort` 信息会被**忽略**。
        *   如果 JPQL 查询很复杂，包含 `GROUP BY` 或 `DISTINCT`，自动追加 `Sort` 可能不总是有效或正确，此时建议在 JPQL 中显式写 `ORDER BY`。
    ```java
    public interface UserRepository extends JpaRepository<User, Long> {
        @Query("SELECT u FROM User u WHERE u.status = :status")
        Page<User> findByStatusWithQuery(@Param("status") String status, Pageable pageable);

        // 如果 JPQL 中有 ORDER BY，Pageable 中的 Sort 会被忽略
        @Query("SELECT u FROM User u WHERE u.status = :status ORDER BY u.username ASC")
        Page<User> findByStatusOrderedByName(@Param("status") String status, Pageable pageable);

        // 对于复杂的 COUNT 查询，可以自定义 countQuery
        @Query(value = "SELECT u FROM User u JOIN u.department d WHERE d.name = :deptName",
               countQuery = "SELECT count(u) FROM User u JOIN u.department d WHERE d.name = :deptName")
        Page<User> findByDepartmentName(@Param("deptName") String deptName, Pageable pageable);
    }
    ```
    *   **原生 SQL 中的分页与排序**:
        *   Spring Data JPA 对原生 SQL 的分页支持有限。它会尝试包装你的原生 SQL 来添加分页子句，但这取决于数据库方言和 SQL 的复杂性。
        *   对于原生 SQL，如果需要精确控制分页，有时可能需要手动在 SQL 中处理分页参数 (如 `LIMIT :limit OFFSET :offset`)，并自己计算 `count`。
        *   或者，如果查询简单，可以依赖 Spring Data JPA 的自动包装，但要充分测试。

---

我们已经深入讲解了 Spring Data JPA Repository 接口的强大功能，包括基本 CRUD、查询方法派生、`@Query` 注解、`@Modifying`、`@Param` 以及分页和排序。这是使用 Spring Data JPA 进行数据访问的核心。