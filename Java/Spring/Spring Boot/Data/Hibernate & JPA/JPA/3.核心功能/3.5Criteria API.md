探讨 JPA 的 **Criteria API**。这是一种用于构建动态查询的、类型安全的方式，作为 JPQL 字符串拼接的替代方案。

---

#### 3.5 Criteria API

**为什么需要 Criteria API？**

虽然 JPQL 是一种强大的查询语言，但在需要根据运行时条件动态构建查询（例如，用户在界面上选择了不同的过滤条件）的场景下，直接拼接 JPQL 字符串可能会变得复杂、易错，并且存在潜在的 JPQL 注入风险 (虽然不像 SQL 注入那么直接，但仍需注意)。

Criteria API 提供了一套 Java 编程接口，允许你以编程方式、面向对象地构建查询结构，最终由 JPA 提供者转换为 SQL 执行。其核心优势在于**类型安全**：由于查询是使用 Java 对象和方法构建的，很多错误可以在编译时就被发现，而不是在运行时。

**核心接口与概念：**

1.  **`CriteriaBuilder` (cb)**:
    *   **作用**: 查询构建的工厂。用于创建 `CriteriaQuery` 对象、谓词 (Predicates)、表达式 (Expressions)、排序规则等查询的各个组成部分。
    *   **获取**: 通过 `EntityManager.getCriteriaBuilder()` 获取。
    *   **常用方法**:
        *   `createQuery(Class<T> resultClass)`: 创建一个 `CriteriaQuery` 对象，指定查询结果的类型。
        *   `createTupleQuery()`: 创建一个返回 `Tuple` 的 `CriteriaQuery`。
        *   `asc(Expression<?> x)`, `desc(Expression<?> x)`: 创建升序/降序排序表达式。
        *   各种比较谓词: `equal(Expression<?> x, Object y)`, `notEqual(...)`, `gt(...)`, `ge(...)`, `lt(...)`, `le(...)`, `like(Expression<String> x, String pattern)`, `isNull(Expression<?> x)`, `isNotNull(...)`, `between(Expression<Y> v, Expression<Y> x, Expression<Y> y)`, `in(Expression<?> expression)` (配合 `value()` 或 `subquery()`)。
        *   逻辑谓词: `and(Predicate... restrictions)`, `or(Predicate... restrictions)`, `not(Predicate restriction)`。
        *   聚合函数: `count(Expression<?> x)`, `sum(Expression<N> x)`, `avg(Expression<N> x)`, `max(Expression<N> x)`, `min(Expression<N> x)`。
        *   其他表达式: `literal(T value)`, `parameter(Class<T> paramClass, String name)`, `concat(Expression<String> x, Expression<String> y)`, `substring(...)`, `lower(...)`, `upper(...)`, `trim(...)`, `currentDate()`, `currentTime()`, `currentTimestamp()`。

2.  **`CriteriaQuery<T>` (cq)**:
    *   **作用**: 代表一个顶级的查询对象。它定义了查询的结构，包括 `SELECT` 部分、`FROM` 部分、`WHERE` 部分、`GROUP BY` 部分、`HAVING` 部分和 `ORDER BY` 部分。
    *   `T` 是查询结果的类型。
    *   **获取**: 通过 `CriteriaBuilder.createQuery(Class<T> resultClass)` 或 `CriteriaBuilder.createTupleQuery()` 创建。
    *   **常用方法**:
        *   `from(Class<X> entityClass)`: 指定查询的根实体 (Root)，返回一个 `Root<X>` 对象。**这是定义查询的起点。**
        *   `select(Selection<? extends T> selection)`: 指定 `SELECT` 子句。`Selection` 可以是 `Root` (查询整个实体)、`Path` (查询特定属性)、`Expression` (查询表达式结果) 或构造函数表达式 (`cb.construct(...)`)。
        *   `multiselect(Selection<?>... selections)`: 用于选择多个项 (投影)，通常返回 `Object[]` 或与 `cb.construct()` 配合。
        *   `where(Predicate... restrictions)`: 指定 `WHERE` 子句的条件 (谓词)。多个谓词默认用 `AND` 连接。
        *   `groupBy(Expression<?>... grouping)`: 指定 `GROUP BY` 子句。
        *   `having(Predicate... restrictions)`: 指定 `HAVING` 子句。
        *   `orderBy(Order... orders)`: 指定 `ORDER BY` 子句。
        *   `distinct(boolean distinct)`: 设置是否去重 (`SELECT DISTINCT`)。

3.  **`Root<T>` (root / from)**:
    *   **作用**: 代表查询的根实体，是 `FROM` 子句的起点。一个 `CriteriaQuery` 可以有多个 `Root` (用于笛卡尔积或某些特定连接)。
    *   **获取**: 通过 `CriteriaQuery.from(Class<T> entityClass)` 创建。
    *   **常用方法**:
        *   `get(String attributeName)`: 获取实体的持久化属性，返回一个 `Path<Y>` 对象 (类型安全较弱，因为 `attributeName` 是字符串)。
        *   `get(SingularAttribute<T, Y> attribute)`: (配合 JPA Metamodel) 获取实体的持久化属性，返回 `Path<Y>`，**类型安全**。
        *   `join(String attributeName)`: 创建一个到关联属性的 `INNER JOIN`，返回 `Join<T, Y>`。
        *   `join(String attributeName, JoinType type)`: 创建指定类型的 `JOIN` (`LEFT`, `RIGHT`)。
        *   `join(SingularAttribute<T, Y> attribute)`: (配合 Metamodel) 类型安全的 `JOIN`。
        *   `fetch(String attributeName)`: 创建一个 `FETCH JOIN` (用于解决 N+1 问题)。
        *   `fetch(String attributeName, JoinType type)`: 指定类型的 `FETCH JOIN`。
        *   `as(Class<X> type)`: 类型转换 (不常用)。

4.  **`Path<Y>`**:
    *   **作用**: 代表从 `Root` 或 `Join` 导航到的属性路径。它可以是实体的基本类型属性、嵌入式属性或关联属性。
    *   **获取**: 通过 `Root.get(...)` 或 `Join.get(...)`。
    *   是 `Expression<Y>` 的子接口。

5.  **`Join<X, Y>`**:
    *   **作用**: 代表一个 `JOIN` 操作的结果。`X` 是连接的源实体类型，`Y` 是连接的目标实体类型。
    *   继承自 `From<X, Y>`，因此也具有 `get()` 方法来继续导航属性。

6.  **`Predicate`**:
    *   **作用**: 代表 `WHERE` 或 `HAVING` 子句中的一个条件表达式，其计算结果为布尔值。
    *   **获取**: 通过 `CriteriaBuilder` 的各种比较方法 (`equal`, `gt`, `like`, etc.) 或逻辑方法 (`and`, `or`, `not`) 创建。

7.  **`Expression<T>`**:
    *   **作用**: 代表一个可以产生值的表达式，例如属性路径、字面量、参数、函数调用、聚合函数等。
    *   `Path<T>` 是其子接口。

8.  **`Order`**:
    *   **作用**: 代表 `ORDER BY` 子句中的一个排序规则。
    *   **获取**: 通过 `CriteriaBuilder.asc(Expression<?>)` 或 `CriteriaBuilder.desc(Expression<?>)` 创建。

9.  **JPA Metamodel (元模型 - 可选但推荐用于类型安全)**:
    *   为了在 Criteria API 中实现完全的类型安全 (避免使用字符串属性名)，JPA 2.0 引入了元模型。
    *   元模型是一组与实体类对应的静态类 (通常在编译时由 JPA 提供者或构建插件生成)，这些类包含了实体的持久化属性的静态表示 (如 `SingularAttribute`, `CollectionAttribute`, `ListAttribute`, `SetAttribute`)。
    *   **示例 (假设有 `User` 实体，会生成 `User_` 元模型类)**:
        ```java
        // User.java
        // @Entity
        // public class User {
        //     @Id private Long id;
        //     private String username;
        //     private Integer age;
        //     @ManyToOne private Department department;
        // }

        // User_.java (自动生成)
        // @StaticMetamodel(User.class)
        // public abstract class User_ {
        //     public static volatile SingularAttribute<User, Long> id;
        //     public static volatile SingularAttribute<User, String> username;
        //     public static volatile SingularAttribute<User, Integer> age;
        //     public static volatile SingularAttribute<User, Department> department;
        // }
        ```
    *   **使用元模型**:
        `root.get(User_.username)` 代替 `root.get("username")`。
        `root.join(User_.department)` 代替 `root.join("department")`。

**使用 Criteria API 构建查询的步骤：**

1.  获取 `EntityManager` 实例。
2.  获取 `CriteriaBuilder` 实例: `CriteriaBuilder cb = entityManager.getCriteriaBuilder();`
3.  创建 `CriteriaQuery<T>` 对象: `CriteriaQuery<MyResultType> cq = cb.createQuery(MyResultType.class);`
4.  指定 `FROM` 子句并获取 `Root<E>` 对象: `Root<EntityType> root = cq.from(EntityType.class);`
5.  (可选) 构建 `JOIN` 子句: `Join<EntityType, RelatedEntity> join = root.join(EntityType_.relatedAttribute);`
6.  (可选) 构建 `WHERE` 子句的 `Predicate` (s):
    ```java
    List<Predicate> predicates = new ArrayList<>();
    if (nameParam != null) {
        predicates.add(cb.like(root.get(EntityType_.name), "%" + nameParam + "%"));
    }
    if (ageParam != null) {
        predicates.add(cb.greaterThan(root.get(EntityType_.age), ageParam));
    }
    cq.where(cb.and(predicates.toArray(new Predicate[0]))); // 或 cb.or(...)
    ```
7.  指定 `SELECT` 子句:
    *   查询整个实体: `cq.select(root);`
    *   查询特定属性 (投影): `cq.multiselect(root.get(EntityType_.id), root.get(EntityType_.name));`
    *   使用构造函数投影: `cq.select(cb.construct(MyDTO.class, root.get(EntityType_.id), root.get(EntityType_.name)));`
8.  (可选) 指定 `ORDER BY` 子句: `cq.orderBy(cb.asc(root.get(EntityType_.name)));`
9.  (可选) 指定 `GROUP BY` 和 `HAVING` 子句。
10. 从 `EntityManager` 创建 `TypedQuery<T>`: `TypedQuery<MyResultType> query = entityManager.createQuery(cq);`
11. (可选) 设置查询参数 (如果使用了 `cb.parameter(...)`)。
12. 执行查询: `List<MyResultType> results = query.getResultList();` 或 `MyResultType result = query.getSingleResult();`

**示例：使用 Criteria API 查询特定部门中年龄大于某值的员工**
```java
public List<Employee> findEmployeesByDepartmentAndMinAge(String departmentName, int minAge) {
    EntityManager em = getEntityManager(); // 获取 EntityManager
    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery<Employee> cq = cb.createQuery(Employee.class); // 结果类型是 Employee

    Root<Employee> employeeRoot = cq.from(Employee.class); // FROM Employee employeeRoot
    Join<Employee, Department> departmentJoin = employeeRoot.join(Employee_.department); // JOIN department

    List<Predicate> predicates = new ArrayList<>();
    predicates.add(cb.equal(departmentJoin.get(Department_.name), departmentName)); // WHERE department.name = :departmentName
    predicates.add(cb.greaterThan(employeeRoot.get(Employee_.age), minAge));       // AND employee.age > :minAge

    cq.where(predicates.toArray(new Predicate[0])); // 合并条件
    cq.orderBy(cb.asc(employeeRoot.get(Employee_.lastName))); // ORDER BY lastName ASC

    TypedQuery<Employee> query = em.createQuery(cq);
    return query.getResultList();
}
```

**Criteria API 的优缺点：**

*   **优点**:
    *   **类型安全**: 大部分错误能在编译期发现 (尤其配合 JPA Metamodel)。
    *   **动态性强**: 非常适合根据复杂运行时条件动态构建查询。
    *   **重构友好**: 如果实体属性名改变，使用元模型时，编译器会提示错误。
    *   **面向对象**: 以编程方式构建查询，更符合 Java 开发者的思维。
*   **缺点**:
    *   **代码冗余**: 相较于 JPQL 字符串，Criteria API 的代码通常更长、更啰嗦。
    *   **学习曲线**: 需要理解其核心接口和构建方式，比直接写 JPQL 更复杂一些。
    *   **可读性**: 对于简单的查询，JPQL 可能更直观易读。复杂的 Criteria API 查询有时可读性会下降。
    *   **某些高级数据库特性**: 可能不如原生 SQL 或特定 JPQL 扩展那样直接支持。

**与 Spring Data JPA Specifications 的关系：**

Spring Data JPA 提供了一个更高层次的抽象，称为 **Specifications (`org.springframework.data.jpa.domain.Specification<T>`)**，它基于 Criteria API 构建。
Specifications 允许你将查询条件封装成可复用的、可组合的逻辑单元。
```java
// Specification 示例
public class EmployeeSpecifications {
    public static Specification<Employee> hasDepartment(String departmentName) {
        return (root, query, criteriaBuilder) ->
            criteriaBuilder.equal(root.join(Employee_.department).get(Department_.name), departmentName);
    }

    public static Specification<Employee> ageGreaterThan(int age) {
        return (root, query, criteriaBuilder) ->
            criteriaBuilder.greaterThan(root.get(Employee_.age), age);
    }
}

// 在 Repository 中使用
// public interface EmployeeRepository extends JpaRepository<Employee, Long>, JpaSpecificationExecutor<Employee> {}
// ...
// List<Employee> results = employeeRepository.findAll(
//     Specification.where(EmployeeSpecifications.hasDepartment("IT"))
//                  .and(EmployeeSpecifications.ageGreaterThan(30))
// );
```
`JpaSpecificationExecutor` 接口提供了 `findAll(Specification<T> spec)`, `findOne(Specification<T> spec)`, `count(Specification<T> spec)` 等方法。Specifications 内部仍然是使用 Criteria API 来构建 Predicate。

**结论**: Criteria API 是 JPA 中用于动态构建类型安全查询的强大工具。虽然代码可能比 JPQL 更冗长，但在需要高度动态性和类型安全的场景下，它是非常有价值的。Spring Data JPA Specifications 在此基础上提供了更优雅的封装。

---

#### 3.6 原生 SQL 查询 (Native Queries)

尽管 JPA 和 JPQL 致力于提供数据库无关的、面向对象的查询方式，但总有一些场景需要直接使用特定数据库的原生 SQL：

*   **利用数据库特有功能**: 如特定数据库的函数、索引提示、递归查询 (CTE) 等 JPQL 不支持或支持不佳的特性。
*   **执行复杂或高度优化的 SQL**: 有时手写的原生 SQL 能达到比 JPA 生成的 SQL 更好的性能。
*   **操作非实体映射的表或视图**: 执行对数据库字典、临时表等的查询。
*   **调用存储过程**: 虽然 JPA 2.1+ 提供了 `@NamedStoredProcedureQuery`，但有时直接用原生 SQL 调用更方便。

**执行原生 SQL：**

通过 `EntityManager` 的 `createNativeQuery()` 方法。

1.  **返回标量值或 `Object[]`**:
    ```java
    // EntityManager em = ...;
    String sql = "SELECT COUNT(*) FROM user_account WHERE status = ?";
    Query query = em.createNativeQuery(sql);
    query.setParameter(1, "ACTIVE"); // 位置参数
    BigInteger count = (BigInteger) query.getSingleResult(); // 注意返回类型可能因数据库而异 (如 Long, BigInteger)

    sql = "SELECT username, email_address FROM user_account WHERE age > :minAge";
    Query listQuery = em.createNativeQuery(sql);
    listQuery.setParameter("minAge", 30);
    List<Object[]> results = listQuery.getResultList(); // 每行是一个 Object[]
    for (Object[] row : results) {
        String username = (String) row[0];
        String email = (String) row[1];
        // ...
    }
    ```

2.  **映射到实体对象**:
    如果原生 SQL 查询返回的列名能与实体类的属性名（或 `@Column(name=...)` 指定的列名）匹配，JPA 可以尝试自动将结果映射到实体对象。
    需要在 `createNativeQuery()` 方法中指定结果类型：
    ```java
    String sql = "SELECT u.user_id, u.username, u.email_address, u.status, u.date_created, u.last_updated " +
                 "FROM user_account u WHERE u.status = :status";
    Query query = em.createNativeQuery(sql, User.class); // 第二个参数指定映射的实体类
    query.setParameter("status", "ACTIVE");
    List<User> users = query.getResultList();
    ```
    *   **列名匹配**: 列名必须与实体中定义的（或默认的）列名完全一致（大小写通常不敏感，但取决于数据库和驱动）。
    *   **所有持久化字段**: 查询必须返回实体所有非 `nullable=false` 的持久化字段（除非 JPA 提供者有更宽松的策略）。

3.  **使用 `@SqlResultSetMapping` 进行复杂结果映射 (推荐用于非实体或复杂投影)**:
    当原生 SQL 的结果不能直接映射到单个实体，或者需要映射到 DTO 或多个不同类型的值时，可以使用 `@SqlResultSetMapping` (在实体类上定义或全局定义)。
    ```java
    // 在实体类 (如 User) 或一个专门的配置类上定义
    @SqlResultSetMapping(
        name = "UserBriefDTOMapping", // 映射的名称
        classes = @ConstructorResult( // 可以映射到 DTO 的构造函数
            targetClass = com.example.dto.UserBriefDTO.class,
            columns = {
                @ColumnResult(name = "uid", type = Long.class), // 别名 uid 对应 DTO 构造函数的第一个参数
                @ColumnResult(name = "uname", type = String.class) // 别名 uname 对应第二个参数
            }
        )
    )
    @SqlResultSetMapping(
        name="UserAndDepartmentMapping",
        entities={
            @EntityResult(entityClass=User.class, fields={ // 映射到 User 实体
                @FieldResult(name="id", column="u_id"),
                @FieldResult(name="username", column="u_name")
            }),
            @EntityResult(entityClass=Department.class, fields={ // 映射到 Department 实体
                @FieldResult(name="id", column="d_id"),
                @FieldResult(name="name", column="d_name")
            })
        },
        columns = { // (可选) 额外的标量列
            @ColumnResult(name="some_calculated_value")
        }
    )
    @Entity
    public class User { /* ... */ }

    // 使用 @SqlResultSetMapping
    String sqlDto = "SELECT u.user_id as uid, u.username as uname FROM user_account u WHERE u.age > 30";
    Query queryDto = em.createNativeQuery(sqlDto, "UserBriefDTOMapping"); // 使用映射名称
    List<UserBriefDTO> dtos = queryDto.getResultList();

    String sqlMultiEntity = "SELECT u.user_id as u_id, u.username as u_name, d.id as d_id, d.name as d_name " +
                           "FROM user_account u JOIN department d ON u.department_id = d.id";
    Query queryMulti = em.createNativeQuery(sqlMultiEntity, "UserAndDepartmentMapping");
    List<Object[]> multiResults = queryMulti.getResultList(); // 每行是一个 Object[], 元素是 User, Department
    for (Object[] row : multiResults) {
        User user = (User) row[0];
        Department dept = (Department) row[1];
        // ...
    }
    ```
    *   `@SqlResultSetMapping`: 定义一个或多个结果集映射配置。
    *   `@EntityResult`: 将结果映射到一个实体。`@FieldResult` 指定列如何映射到实体属性。
    *   `@ConstructorResult`: 将结果映射到一个非实体类 (DTO) 的构造函数。`@ColumnResult` 指定列及其类型，顺序必须与构造函数参数一致。
    *   `@ColumnResult`: 将结果映射到一个标量值。
    *   `em.createNativeQuery(sql, resultSetMappingName)`: 第二个参数传入 `@SqlResultSetMapping` 的 `name`。

**Spring Data JPA 中的原生 SQL (`@Query(nativeQuery = true)`)**:
在 Spring Data JPA Repository 中，使用 `@Query(value = "...", nativeQuery = true)` 是执行原生 SQL 的更常见方式。
```java
public interface UserRepository extends JpaRepository<User, Long> {

    @Query(value = "SELECT * FROM user_account WHERE username LIKE %:keyword%", nativeQuery = true)
    List<User> findByUsernameNativeLike(@Param("keyword") String keyword);

    // 原生 SQL 返回 DTO (需要 Hibernate 5.1+ 或特定配置支持构造函数投影)
    // 或者使用接口投影
    @Query(value = "SELECT username, email_address as email FROM user_account WHERE id = :id", nativeQuery = true)
    UserProjection findProjectionByIdNative(@Param("id") Long id);

    public interface UserProjection {
        String getUsername();
        String getEmail();
    }
}
```
Spring Data JPA 会尝试将原生查询的结果映射到方法的返回类型 (实体、标量、DTO、接口投影)。对于 DTO，构造函数参数名需要与查询返回的列别名匹配 (或者需要额外的配置如 `@NamedNativeQuery` 与 `@SqlResultSetMapping`)。接口投影通常更容易使用。

**注意事项：**
*   **数据库无关性降低**: 原生 SQL 耦合了特定数据库的语法。
*   **安全性**: 如果动态拼接原生 SQL 字符串，务必防范 SQL 注入。参数化查询 (`setParameter`) 是安全的。
*   **可维护性**: 大量原生 SQL 可能会降低代码的可读性和可维护性，优先考虑 JPQL 或 Criteria API。
*   **缓存**: 原生 SQL 查询的结果**通常不受 JPA 二级缓存的影响**，除非进行了特殊配置 (如 Hibernate 的 `addSynchronizedEntityClass` 或 `setCacheable(true)` 并指定结果集映射)。

---

我们已经覆盖了 JPA 的核心查询方式：JPQL、Criteria API 和原生 SQL 查询。这些工具为开发者提供了从高度抽象到精细控制的不同层次的数据访问能力。