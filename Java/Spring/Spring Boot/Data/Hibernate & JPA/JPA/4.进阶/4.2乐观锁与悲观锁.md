#### 4.2 乐观锁与悲观锁

在并发环境下，多个事务可能同时尝试修改同一份数据，导致数据不一致。锁机制是解决并发控制的主要手段。

##### 4.2.1 乐观锁 (Optimistic Locking)

*   **理念**: 假设并发冲突是小概率事件。在读取数据时不加锁，允许其他事务读取和修改。在提交更新时，检查数据在此期间是否已被其他事务修改过。如果被修改，则本次更新失败 (通常抛出异常)，由应用层决定如何处理 (如重试、提示用户)。
*   **实现方式**: 通常通过在实体中添加一个**版本号字段 (version column)**。
    *   每次读取数据时，连同版本号一起读出。
    *   每次更新数据时，将版本号加 1，并且在 `UPDATE` 语句的 `WHERE` 条件中检查版本号是否与读取时的一致 (`WHERE id = ? AND version = ?`)。
    *   如果版本号不匹配，说明数据已被修改，更新操作不会影响任何行。
*   **JPA 中的实现 (`@Version` 注解)**:
    ```java
    @Entity
    public class Product {
        @Id
        private Long id;
        private String name;
        private int stock;

        @Version // ① 标记为版本号字段
        private Integer version; // 类型可以是 Integer, Long, Timestamp, java.util.Date
                               // 通常用数值类型，每次更新时 JPA 提供者会自动加 1
        // getters, setters
    }
    ```
    **使用**:
    ```java
    @Transactional
    public void updateProductStock(Long productId, int newStock) {
        Product product = productRepository.findById(productId)
                            .orElseThrow(() -> new EntityNotFoundException("Product not found"));

        // 假设这里有一些业务逻辑，可能需要一些时间
        // Thread.sleep(100); // 模拟并发

        product.setStock(newStock);
        // product.setVersion(product.getVersion()); // 不需要手动设置 version，JPA 会自动处理

        try {
            productRepository.save(product); // save() 方法会触发 UPDATE
                                             // Hibernate 会生成类似:
                                             // UPDATE product SET name=?, stock=?, version=? WHERE id=? AND version=?
                                             // 新的 version 是 old_version + 1
        } catch (OptimisticLockException | StaleObjectStateException e) { // ② 捕获并发冲突异常
            // Hibernate 通常抛出 StaleObjectStateException 或其子类
            // JPA 规范定义了 OptimisticLockException
            log.error("Optimistic lock conflict for product " + productId, e);
            // 处理冲突：重试、给用户错误提示、合并更改等
            throw new ConcurrentModificationException("Data was modified by another transaction. Please retry.", e);
        }
    }
    ```
    *   **① `@Version` 注解**: 告诉 JPA 这个字段是版本号。JPA 提供者 (如 Hibernate) 会在更新时自动管理它 (读取、检查、递增)。
    *   **② 异常处理**: 当发生乐观锁冲突时 (即 `UPDATE` 语句的 `WHERE version = ?` 条件不满足，更新了0行)，JPA 提供者通常会抛出特定的异常 (如 Hibernate 的 `StaleObjectStateException`，或标准的 `OptimisticLockException`)。应用需要捕获并处理这种异常。
*   **优点**: 并发性能好 (读操作不加锁)，吞吐量高。
*   **缺点**: 更新冲突时需要应用层处理，可能增加逻辑复杂度。如果冲突频繁，性能反而可能下降 (因为大量重试)。
*   **适用场景**: 读多写少，并发冲突概率低的场景。

##### 4.2.2 悲观锁 (Pessimistic Locking)

*   **理念**: 假设并发冲突是大概率事件。在读取数据时就对其加锁 (通常是数据库层面的行级锁或表级锁)，阻止其他事务修改 (甚至读取，取决于锁类型) 这份数据，直到当前事务释放锁 (通常在事务提交或回滚时)。
*   **实现方式**: 依赖数据库提供的锁机制。
*   **JPA 中的实现 (`LockModeType` 枚举)**:
    可以通过 `EntityManager.find()`, `EntityManager.lock()`, `Query.setLockMode()`, 或 Spring Data JPA Repository 方法的 `@Lock` 注解来指定锁模式。
    **`jakarta.persistence.LockModeType` (或 `javax.persistence.LockModeType`) 枚举值**:
    *   `NONE`: 无锁 (默认)。
    *   **悲观读锁 (Pessimistic Read / Shared Lock)**:
        *   `PESSIMISTIC_READ` (JPA 2.0+): 其他事务可以读取该数据，但不能修改。当前事务可以读取。对应 SQL 通常是 `SELECT ... FOR SHARE` (PostgreSQL, MySQL 8+) 或 `SELECT ... WITH (HOLDLOCK, ROWLOCK)` (SQL Server)。
    *   **悲观写锁 (Pessimistic Write / Exclusive Lock)**:
        *   `PESSIMISTIC_WRITE` (JPA 2.0+): 其他事务既不能读取也不能修改该数据 (取决于数据库和隔离级别，有些数据库在写锁下仍允许非锁定读)。当前事务可以读取和修改。对应 SQL 通常是 `SELECT ... FOR UPDATE`。
    *   `OPTIMISTIC` (JPA 2.0+): 使用乐观锁 (通过 `@Version` 字段)。`find` 或 `lock` 时会检查版本。
    *   `OPTIMISTIC_FORCE_INCREMENT` (JPA 2.0+): 即使实体没有被修改，也强制增加版本号。用于确保即使只是读取了实体，如果希望其他事务知道它被“碰过”，也可以增加版本。
    *   `PESSIMISTIC_FORCE_INCREMENT`: 组合了 `PESSIMISTIC_WRITE` 和 `OPTIMISTIC_FORCE_INCREMENT`。
    *   `READ` (JPA 1.0, 类似于 `PESSIMISTIC_READ`，但语义上可能略有不同，建议用 `PESSIMISTIC_READ`)。
    *   `WRITE` (JPA 1.0, 类似于 `PESSIMISTIC_WRITE`，建议用 `PESSIMISTIC_WRITE`)。

    **使用示例：**
    1.  **通过 `EntityManager.find()`**:
        ```java
        @Transactional
        public Product getProductForUpdate(Long productId) {
            // 获取一个悲观写锁，其他事务无法修改此 product 直到本事务结束
            Product product = entityManager.find(Product.class, productId, LockModeType.PESSIMISTIC_WRITE);
            if (product == null) {
                throw new EntityNotFoundException("Product not found");
            }
            // ... 进行修改 ...
            // product.setStock(product.getStock() - 1); // 修改后，事务提交时会自动保存
            return product;
        }
        ```
    2.  **通过 `EntityManager.lock()`**: (对已加载的 Managed 实体尝试加锁)
        ```java
        @Transactional
        public void lockProductExplicitly(Product product) { // product 必须是 Managed 状态
            try {
                entityManager.lock(product, LockModeType.PESSIMISTIC_WRITE);
                // 现在 product 被悲观写锁锁定
            } catch (PessimisticLockException | LockTimeoutException e) {
                // 处理锁获取失败或超时
            }
        }
        ```
    3.  **通过 `Query.setLockMode()`**:
        ```java
        @Transactional
        public List<Product> findProductsByCategoryAndLock(String category) {
            TypedQuery<Product> query = entityManager.createQuery(
                "SELECT p FROM Product p WHERE p.category = :category", Product.class);
            query.setParameter("category", category);
            query.setLockMode(LockModeType.PESSIMISTIC_WRITE); // 对查询结果集中的所有行加写锁
            return query.getResultList();
        }
        ```
    4.  **通过 Spring Data JPA Repository 方法的 `@Lock` 注解 (推荐方式)**:
        ```java
        // ProductRepository.java
        import org.springframework.data.jpa.repository.Lock;
        // ...
        public interface ProductRepository extends JpaRepository<Product, Long> {
            @Lock(LockModeType.PESSIMISTIC_WRITE)
            @Query("SELECT p FROM Product p WHERE p.id = :id") // 也可以用于派生查询方法
            Optional<Product> findAndLockById(@Param("id") Long id);

            @Lock(LockModeType.PESSIMISTIC_READ)
            Optional<Product> findByName(String name); // 派生查询也可以加锁
        }

        // UserService.java
        // @Transactional
        // public void processProduct(Long id) {
        //     Optional<Product> productOpt = productRepository.findAndLockById(id);
        //     // ...
        // }
        ```
*   **优点**: 能有效防止数据更新丢失，数据一致性强。
*   **缺点**:
    *   **性能开销大**: 锁会阻塞其他事务，降低系统并发性和吞吐量。
    *   **死锁风险**: 如果多个事务以不同顺序请求锁，可能导致死锁。需要仔细设计锁的获取顺序和事务范围。
    *   **依赖数据库**: 锁的实现和行为依赖于底层数据库。
*   **适用场景**: 写操作频繁，并发冲突概率高，且数据一致性要求非常严格的场景 (如金融交易、库存扣减的关键步骤)。

**选择乐观锁还是悲观锁？**

*   **乐观锁**: 适合读多写少、冲突不频繁、对吞吐量要求高的场景。是 Web 应用中的常用选择。
*   **悲观锁**: 适合写多冲突多、数据一致性要求极高、且能接受一定性能损失的场景。通常只在核心的、短小的事务操作中使用。
*   可以根据具体业务场景混合使用。

---