探讨 JPA 中的**二级缓存 (L2 Cache)**。二级缓存是提升 JPA 应用性能的重要手段之一，它通过在 `EntityManagerFactory` 层面缓存实体数据，来减少对数据库的直接访问。

---

#### 4.3 二级缓存 (L 2 Cache)

**回顾一级缓存 (Persistence Context Cache / First-Level Cache)：**

*   范围：`EntityManager` 实例级别（通常对应一个事务）。
*   生命周期：与 `EntityManager` 或事务共存亡。
*   作用：在单个事务内避免重复查询同一实体，保证实体唯一性。
*   **不能跨事务或跨 `EntityManager` 共享。**

**二级缓存 (Shared Cache / Second-Level Cache)：**

*   **范围**: `EntityManagerFactory` 级别。这意味着它可以被同一应用中由同一个 `EntityManagerFactory` 创建的**所有 `EntityManager` 实例共享**。
*   **生命周期**: 通常与应用程序的生命周期一致 (从 `EntityManagerFactory` 创建到关闭)。
*   **目的**: 缓存那些不经常改变但读取频繁的实体数据，从而减少数据库负载，提高应用响应速度。
*   **存储内容**: 通常缓存的是实体数据的**分离状态 (disassembled state)** 或序列化形式，而不是 Managed 状态的实体对象本身。当从二级缓存中获取数据时，会重新组装（或反序列化）成实体对象，并将其放入当前事务的一级缓存中变为 Managed 状态。

**JPA 二级缓存的工作流程 (简化)：**

1.  当通过 `entityManager.find(Entity.class, id)` (或某些查询) 加载实体时：
    *   首先检查当前事务的一级缓存。如果命中，直接返回。
    *   如果一级缓存未命中，则检查二级缓存。
    *   如果二级缓存命中，从中获取数据，组装成实体对象，放入一级缓存变为 Managed 状态，然后返回。
    *   如果二级缓存也未命中，则从数据库查询数据，将结果放入二级缓存 (如果该实体配置为可缓存)，再放入一级缓存，然后返回。
2.  当事务提交时，如果事务中修改了已缓存的实体数据：
    *   JPA 提供者会负责更新二级缓存中的对应条目，或使其失效 (取决于缓存并发策略)。
3.  当执行批量更新/删除 (JPQL `UPDATE` / `DELETE` 或原生 SQL) 时：
    *   这些操作通常会绕过 JPA 的缓存管理机制，可能导致二级缓存与数据库数据不一致。需要特别注意并可能有策略地使相关缓存失效。

**如何启用和配置二级缓存：**

启用二级缓存通常涉及以下步骤：

1.  **选择并引入二级缓存提供者 (L 2 Cache Provider) 的依赖**:
    JPA 规范本身不提供二级缓存的实现，它依赖第三方缓存产品。常见的选择有：
    *   **Ehcache**: 成熟的 Java 缓存框架，支持内存、磁盘、分布式缓存。`org.ehcache:ehcache` (Ehcache 3.x) 或 `net.sf.ehcache:ehcache` (Ehcache 2.x)。Hibernate 对其有良好支持。
    *   **Infinispan**: 开源的分布式内存数据网格/键值 NoSQL 数据存储，也可用作 Hibernate L 2 缓存。
    *   **Hazelcast**: 开源的内存数据网格，也提供 L 2 缓存实现。
    *   **JCache (JSR-107)**: Java 缓存 API 规范。许多缓存框架 (如 Ehcache 3, Hazelcast, Infinispan) 都提供了 JCache 实现。Hibernate 5.2+ 推荐使用 JCache 作为 L 2 缓存的集成方式。

    **示例 (使用 Ehcache 3.x via JCache with Spring Boot):**
    `pom.xml`:
    ```xml
    <!-- Spring Boot Data JPA Starter (已包含 Hibernate) -->
    <!-- ... -->

    <!-- JCache API -->
    <dependency>
        <groupId>javax.cache</groupId>
        <artifactId>cache-api</artifactId>
    </dependency>

    <!-- Ehcache 3 as JCache Provider -->
    <dependency>
        <groupId>org.ehcache</groupId>
        <artifactId>ehcache</artifactId>
        <classifier>jakarta</classifier> <!-- For Jakarta EE 9+ (Spring Boot 3.x) -->
        <!-- <classifier>javax</classifier> for older javax.cache -->
    </dependency>

    <!-- (可选) Hibernate JCache Integration (通常Hibernate核心已包含或starter会带) -->
    <!-- <dependency>
        <groupId>org.hibernate.orm</groupId>
        <artifactId>hibernate-jcache</artifactId>
    </dependency> -->
    ```
    *(注意: `ehcache` 的 `classifier` 根据你的 JCache API 版本选择，Spring Boot 3.x 使用 Jakarta EE 规范，所以用 `jakarta`。如果是旧版 Spring Boot 和 `javax.cache`，则用 `javax` 或不指定 classifier)*

2.  **在 JPA 配置文件 (`application.yml` for Spring Boot) 中启用二级缓存并配置提供者**:
    ```yaml
    spring:
      jpa:
        properties:
          hibernate:
            # --- 二级缓存核心配置 ---
            cache:
              use_second_level_cache: true # ① 启用二级缓存
              region.factory_class: org.hibernate.cache.jcache.JCacheRegionFactory # ② 指定区域工厂类 (使用 JCache)
              # (对于 Hibernate 5.2 之前的版本或直接使用 Ehcache 2.x 时)
              # region.factory_class: org.hibernate.cache.ehcache.EhCacheRegionFactory (Ehcache 2.x)
              # region.factory_class: org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory (Ehcache 2.x Singleton)

            # --- JCache 特定配置 (如果使用 JCacheRegionFactory) ---
            javax.cache.provider: org.ehcache.jsr107.EhcacheCachingProvider # ③ 指定 JCache 提供者
            javax.cache.uri: ehcache.xml # ④ (可选) 指定 Ehcache (或相应JCache提供者) 的配置文件路径 (通常在 classpath 下)
                                          # 如果不指定，Ehcache 会使用默认配置或尝试加载 classpath:/ehcache.xml

            # (可选) 启用查询缓存 (稍后详述)
            # cache.use_query_cache: true
    ```
    *   **① `hibernate.cache.use_second_level_cache: true`**: 这是开启 Hibernate 二级缓存的总开关。
    *   **② `hibernate.cache.region.factory_class`**: 告诉 Hibernate 使用哪个缓存区域工厂。
        *   `org.hibernate.cache.jcache.JCacheRegionFactory`: Hibernate 5.2+ 推荐，通过 JCache API 与底层缓存框架集成。
        *   `org.hibernate.cache.ehcache.EhCacheRegionFactory` / `SingletonEhCacheRegionFactory`: 直接与 Ehcache 2.x 集成。
    *   **③ `javax.cache.provider` (或 `jakarta.cache.provider` for Jakarta EE)**: 当使用 `JCacheRegionFactory` 时，需要指定实际的 JCache 提供者实现类。
    *   **④ `javax.cache.uri`**: 指定底层 JCache 提供者 (如 Ehcache) 的配置文件。

3.  **创建缓存提供者的配置文件 (如 `ehcache.xml` for Ehcache)**:
    将此文件放在 `src/main/resources` 目录下。
    `src/main/resources/ehcache.xml` (Ehcache 3.x JCache 示例):
    ```xml
    <config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="http://www.ehcache.org/v3"
            xmlns:jsr107="http://www.ehcache.org/v3/jsr107"
            xsi:schemaLocation="
                http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.0.xsd
                http://www.ehcache.org/v3/jsr107 http://www.ehcache.org/schema/ehcache-107-ext-3.0.xsd">

        <!-- 默认缓存模板，可以被具体缓存区域继承或覆盖 -->
        <cache-template name="defaultTemplate">
            <expiry>
                <ttl unit="minutes">30</ttl> <!-- Time to Live: 30 分钟 -->
            </expiry>
            <resources>
                <heap unit="entries">1000</heap> <!-- 堆内存中最多缓存 1000 条记录 -->
                <!-- <offheap unit="MB">100</offheap> -->
                <!-- <disk unit="GB" persistent="false">1</disk> -->
            </resources>
            <!-- (可选) JSR-107 specific configuration for Hibernate statistics -->
            <jsr107:mbeans enable-management="true" enable-statistics="true"/>
        </cache-template>

        <!-- 为特定实体定义缓存区域 (region) -->
        <!-- 区域名通常是实体的全限定类名 -->
        <cache alias="com.example.yourproject.entity.Product" uses-template="defaultTemplate">
            <!-- 可以覆盖模板配置 -->
            <expiry>
                <ttl unit="hours">1</ttl>
            </expiry>
            <resources>
                <heap unit="entries">500</heap>
            </resources>
        </cache>

        <cache alias="com.example.yourproject.entity.Category" uses-template="defaultTemplate">
            <resources>
                <heap unit="entries">100</heap>
            </resources>
        </cache>

        <!-- (可选) 为集合关联定义缓存区域 -->
        <!-- 区域名通常是 "实体全限定类名.集合属性名" -->
        <cache alias="com.example.yourproject.entity.Product.tags" uses-template="defaultTemplate"/>

        <!-- (可选) 查询缓存区域 (如果启用查询缓存) -->
        <cache alias="org.hibernate.cache.internal.StandardQueryCache" uses-template="defaultTemplate">
            <expiry>
                <ttl unit="minutes">5</ttl>
            </expiry>
            <resources>
                <heap unit="entries">2000</heap>
            </resources>
        </cache>
        <cache alias="org.hibernate.cache.spi.UpdateTimestampsCache" uses-template="defaultTemplate">
            <expiry>
                <none/> <!-- 通常不希望时间戳缓存过期 -->
            </expiry>
        </cache>

    </config>
    ```
    *   这个配置文件定义了不同的**缓存区域 (cache regions)**。Hibernate 会为每个可缓存的实体类、集合关联以及查询缓存创建不同的区域。
    *   你可以为每个区域配置过期策略 (TTL - Time To Live, TTI - Time To Idle)、存储容量 (堆内存、堆外内存、磁盘)、持久化等。

4.  **在实体类上标记为可缓存 (`@Cacheable`, `@Cache`)**:
    *   **`@jakarta.persistence.Cacheable(true)` (或 `javax.persistence.Cacheable(true)`)**:
        在实体类上添加此注解，表示该实体可以被二级缓存。
        ```java
        @Entity
        @Cacheable // 等同于 @Cacheable(true)
        public class Product {
            // ...
        }
        ```
    *   **`@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.XXX, region = "optionalRegionName")`**:
        这是 Hibernate 特有的注解，提供了更细致的缓存并发策略控制。
        *   `usage`: 指定**缓存并发策略 (CacheConcurrencyStrategy)**:
            *   `NONE`: 不缓存此实体。
            *   `READ_ONLY`: 适用于几乎不发生变化的数据。缓存的数据是只读的。如果尝试更新，会抛异常。性能最好。
            *   `NONSTRICT_READ_WRITE`: 非严格读写。对于可能发生并发更新，但不需要绝对事务隔离性的数据。读取时可能读到稍微过时的数据 (在更新后缓存尚未失效或更新前)。更新时会使缓存失效。提供较好的性能和一定的并发性。
            *   `READ_WRITE`: 严格读写。提供事务级别的缓存一致性 (通常通过时间戳或版本号机制)。适用于需要保证数据一致性的读写数据。需要在事务内操作，性能开销比 `NONSTRICT_READ_WRITE` 大。
            *   `TRANSACTIONAL`: 完全事务性的缓存。需要 JTA 环境和支持事务的缓存提供者 (如 Infinispan)。提供最强的一致性保证，但性能开销最大。
        *   `region`: (可选) 指定此实体使用的缓存区域名称。如果省略，默认为实体的全限定类名。这需要与 `ehcache.xml` (或类似配置文件) 中的 `cache alias` 对应。
        *   `include`: (可选, 默认 `all`) 可以配置为 `non-lazy`，只缓存非懒加载的属性。

        ```java
        import org.hibernate.annotations.Cache;
        import org.hibernate.annotations.CacheConcurrencyStrategy;

        @Entity
        @Cacheable // JPA 标准注解
        @Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = "productCache") // Hibernate 注解
        public class Product {
            // ...
            @OneToMany(mappedBy = "product", fetch = FetchType.LAZY)
            @Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region = "product_tags_collection") // 缓存集合关联
            private Set<Tag> tags = new HashSet<>();
        }
        ```
    *   **同时使用 `@Cacheable` 和 `@Cache`**: 通常一起使用。`@Cacheable` 是 JPA 标准，而 `@Cache` (Hibernate) 提供了更细致的并发策略。

##### 4.3.1 缓存模式 (`jakarta.persistence.CacheStoreMode`, `CacheRetrieveMode`)

JPA 2.0 引入了 `CacheStoreMode` 和 `CacheRetrieveMode`，允许在 `EntityManagerFactory`、`EntityManager` 或特定查询级别控制缓存的读写行为。

*   **`CacheStoreMode`**: 控制数据如何写入缓存。
    *   `USE` (默认): 实体被读取或修改时，会存入或更新缓存。
    *   `BYPASS`: 操作不写入缓存 (绕过缓存写)。
    *   `REFRESH`: 操作会写入缓存，并强制刷新缓存中已存在的条目。
*   **`CacheRetrieveMode`**: 控制数据如何从缓存读取。
    *   `USE` (默认): 查询时会尝试从缓存读取。
    *   `BYPASS`: 查询时不使用缓存，直接访问数据库 (绕过缓存读)。

可以通过 `EntityManagerFactory.getCache().evictAll()` 清空所有二级缓存，或 `evict(Class cls)` 清空特定实体类的缓存，`evict(Class cls, Object primaryKey)` 清空特定实体的缓存。

**在 `EntityManager` 或查询级别设置 (不常用，通常在实体级别或全局配置)：**
```java
// entityManager.setProperty("javax.persistence.cache.storeMode", CacheStoreMode.BYPASS);
// query.setHint("javax.persistence.cache.retrieveMode", CacheRetrieveMode.BYPASS);
```

##### 4.3.2 查询缓存 (Query Cache)

*   **作用**: 二级缓存默认只缓存通过主键 `find()` 方法加载的单个实体。查询缓存用于**缓存 JPQL 或 Criteria API 查询的结果集**。
*   **存储内容**: 它不直接缓存实体对象，而是缓存：
    1.  查询语句及其参数。
    2.  与该查询结果对应的**实体的主键 ID 列表**。
*   **工作流程**:
    1.  当执行一个配置为可缓存的查询时，首先检查查询缓存中是否有该查询 (语句+参数) 的结果。
    2.  如果命中，则从缓存中获取主键 ID 列表。
    3.  然后，根据这些 ID 逐个从二级缓存 (或数据库，如果二级缓存未命中) 中加载实体对象。
*   **启用查询缓存**:
    1.  在 JPA 属性中设置 `spring.jpa.properties.hibernate.cache.use_query_cache: true`。
    2.  确保相关的实体也配置为可被二级缓存 (`@Cacheable`, `@Cache`)。
    3.  在 `ehcache.xml` (或类似) 中为查询缓存区域 (通常是 `org.hibernate.cache.internal.StandardQueryCache`) 进行配置。
*   **标记查询为可缓存**:
    在 `Query` 或 `TypedQuery` 对象上调用 `query.setHint("org.hibernate.cacheable", true)`。
    ```java
    TypedQuery<Product> query = entityManager.createQuery("SELECT p FROM Product p WHERE p.category.name = :catName", Product.class);
    query.setParameter("catName", "Electronics");
    query.setHint("org.hibernate.cacheable", true); // ① 标记此查询结果可缓存
    // query.setHint("org.hibernate.cacheRegion", "myCustomQueryCacheRegion"); // ② (可选) 指定查询缓存区域
    List<Product> products = query.getResultList();
    ```
    在 Spring Data JPA Repository 中，可以使用 `@QueryHints` 注解：
    ```java
    // ProductRepository.java
    import org.springframework.data.jpa.repository.QueryHints;
    import jakarta.persistence.QueryHint; // 或 javax.persistence.QueryHint
    // ...
    public interface ProductRepository extends JpaRepository<Product, Long> {
        @QueryHints({ // 应用查询提示
            @QueryHint(name = "org.hibernate.cacheable", value = "true"),
            @QueryHint(name = "org.hibernate.cacheRegion", value = "productQueries") // (可选)
        })
        @Query("SELECT p FROM Product p WHERE p.discontinued = false")
        List<Product> findAllActiveProducts();
    }
    ```

*   **查询缓存的失效**:
    *   当任何一个**被查询缓存引用的表**中的数据发生更改 (INSERT, UPDATE, DELETE) 时，Hibernate 会自动使所有依赖该表的查询缓存条目**失效**。这是通过 `UpdateTimestampsCache` 区域来跟踪表的时间戳实现的。
    *   这意味着查询缓存对于频繁更新的表可能效果不佳，因为缓存会经常失效。
*   **适用场景**: 适用于那些结果集相对稳定、参数组合有限、且查询本身开销较大的查询。

**二级缓存与查询缓存的注意事项：**

*   **开销**: 缓存本身有管理开销 (内存、CPU、网络如果是分布式缓存)。不恰当的缓存配置可能反而降低性能。
*   **数据一致性**: 需要仔细选择缓存并发策略，以平衡性能和数据一致性的需求。
*   **缓存粒度**: 仔细规划哪些实体、哪些关联、哪些查询需要缓存。不是所有东西都适合缓存。
*   **缓存污染/雪崩/穿透**: 需要了解并防范常见的缓存问题。
*   **测试**: 缓存的行为可能很微妙，需要充分测试以确保其按预期工作。
*   **监控**: 监控缓存的命中率、内存使用等指标，以便调优。
*   **分布式环境**: 如果应用是集群部署，需要使用分布式二级缓存提供者 (如 Ehcache Terracotta, Hazelcast, Infinispan 的集群模式)，否则每个应用实例都有自己的本地缓存，无法共享。

---

二级缓存和查询缓存是 JPA 中用于提升性能的高级特性。正确配置和使用它们可以显著减少数据库负载，但同时也带来了额外的复杂性和对数据一致性的考量。