探讨 MyBatis 的最佳实践与常见问题。遵循这些实践可以帮助你编写出更高效、更易维护、更健壮的 MyBatis 应用。

---

### 5. 最佳实践与常见问题

#### 5.1 XML vs 注解

我们在前面已经对比过 XML 和注解。这里总结一下最佳实践：

*   **简单、固定、CRUD 操作**：
    *   **注解**可以胜任，代码更集中，有时更直观。
    *   例如：`findById`, `findAll` (无动态条件), 简单 `insert`, `update`, `delete`。
*   **复杂 SQL、动态 SQL、需要精细控制的 SQL**：
    *   **XML 映射文件**是首选。
    *   XML 提供了强大的动态 SQL 标签 (`<if>`, `<foreach>`, `<choose>`, `<where>`, `<set>`, `<trim>`)，使得构建复杂的动态查询更为清晰和易于管理。
    *   SQL 语句与 Java 代码分离，便于 DBA 或 SQL 专家进行审查、优化，也更利于 SQL 的复用 (`<sql>` 和 `<include>`)。
    *   对于非常长的 SQL 语句，放在 XML 中可读性远胜于注解。
*   **团队协作与一致性**：
    *   团队内部应达成共识，制定使用规范。例如：
        *   “默认使用 XML，除非是非常简单的单行固定 SQL 且无复杂映射，方可使用注解。”
        *   或者“动态 SQL 必须使用 XML。”
    *   避免项目中 XML 和注解随意混用导致维护困难。
*   **可维护性**：
    *   长远来看，对于需要长期维护和迭代的项目，将 SQL 集中在 XML 文件中通常更容易管理和查找。
    *   注解方式的 SQL 如果分散在大量 Mapper 接口中，当需要批量修改或分析 SQL 时会比较麻烦。
*   **混合使用**：
    *   MyBatis 允许混合使用。你可以为一个 Mapper 接口同时使用注解和 XML 文件中定义的语句。MyBatis 会优先查找注解，如果找不到再查找 XML (通常是根据 namespace 和 id 匹配)。但为了清晰，建议一个方法要么用注解定义 SQL，要么在 XML 中定义。

**常见问题：**

*   **Q: 我应该完全放弃 XML，只用注解吗？**
    *   A: 不建议。虽然注解对于简单场景很方便，但它处理复杂动态 SQL 的能力远不如 XML。完全依赖注解可能会在遇到复杂需求时变得非常棘手。
*   **Q: 注解中的动态 SQL (`@XXXProvider`) 是否能完全替代 XML 动态 SQL？**
    *   A: 理论上可以，但 Provider 类中的 SQL 构建逻辑（即使使用 `SQL` 工具类）通常不如 XML 标签直观和易于维护，尤其是对于非常复杂的逻辑。XML 的标签化动态 SQL 是 MyBatis 的一大特色和优势。

---

#### 5.2 Mapper 接口设计

良好的 Mapper 接口设计能提升代码的可读性和可维护性。

*   **清晰的命名**：
    *   方法名应清晰表达其操作意图，例如：`findUserById`, `insertUser`, `updateUserStatus`, `deleteUsersByCreationDateBefore`。
    *   保持一致的命名约定（如动词在前：`find...`, `get...`, `save...`, `update...`, `delete...`）。
*   **参数处理**：
    *   **单个简单参数**：可以直接使用，如 `User findById(Long id);`。
    *   **多个参数**：**强烈建议使用 `@Param("paramName")` 注解**为每个参数命名，以提高 XML 中引用的明确性和健壮性。
        ```java
        List<User> findByStatusAndRole(@Param("status") String status, @Param("roleId") Long roleId);
        ```
    *   **复杂参数/多个条件**：考虑使用一个**参数对象 (Parameter Object / DTO)** 来封装查询条件，使接口更简洁。
        ```java
        // DTO
        public class UserQueryCriteria {
            private String username;
            private String email;
            private String status;
            // getters and setters
        }
        // Mapper
        List<User> findUsersByCriteria(UserQueryCriteria criteria);
        ```
*   **返回值**：
    *   查询单个对象：返回该对象类型，如 `User findById(Long id);`。如果查不到，MyBatis 默认返回 `null`。
    *   查询多个对象：返回 `List<T>`，如 `List<User> findAll();`。如果查不到，MyBatis 默认返回空列表 (empty list)，而不是 `null`，这通常是好的实践，避免了调用方不必要的 `null` 检查。
    *   `insert`, `update`, `delete` 操作：通常返回 `int`，表示受影响的行数。
    *   也可以返回 `void`，如果你不关心受影响的行数。
    *   对于批量操作，可以考虑返回 `int[]` (如果数据库驱动支持并配置了) 或自定义的批量操作结果对象。
*   **接口职责单一**：
    *   尽量让一个 Mapper 接口对应一个主要的业务实体或数据表的操作。避免创建过于庞大、包含各种不相关操作的 Mapper 接口。
*   **避免在 Mapper 接口中定义业务逻辑**：
    *   Mapper 接口应该只负责数据访问。业务逻辑、事务控制等应放在 Service 层。
*   **使用 `@Mapper` 或 `@MapperScan`**：
    *   确保 Mapper 接口能被 Spring Boot 正确扫描和注册。
        *   `@Mapper`：在每个 Mapper 接口上添加。
        *   `@MapperScan("com.example.yourproject.mapper")`：在配置类或启动类上指定扫描包，更集中管理。

**常见问题：**

*   **Q: Mapper 接口方法可以重载吗？**
    *   A: 可以，但对应的 XML 中的 SQL 语句 `id` 必须唯一。MyBatis 是通过 `namespace + id` 来唯一定位 SQL 语句的。如果 XML `id` 不唯一，MyBatis 启动会报错。通常不建议过度依赖重载，因为 XML `id` 无法重载。
*   **Q: Mapper 接口可以继承吗？**
    *   A: 可以。子接口可以继承父接口的方法。对应的 SQL 语句可以在父接口的 XML 中定义，也可以在子接口自己的 XML 中定义（如果 namespace 对应子接口）。这可以用于定义一些通用的 CRUD 方法。一些增强工具如 `MyBatis-Plus` 就大量使用了这种方式提供通用 Mapper。

---

#### 5.3 SQL 优化考量

MyBatis 将 SQL 的控制权交给了开发者，因此 SQL 优化非常重要。

*   **使用索引 (Indexes)**：
    *   确保查询条件中的列（`WHERE` 子句、`JOIN ON` 子句、`ORDER BY` 子句）建立了合适的索引。
    *   使用数据库的 `EXPLAIN` (或类似命令) 分析查询计划，检查索引是否被有效利用。
*   **避免 `SELECT *`**：
    *   只查询你需要的列。`SELECT *` 会增加网络传输开销、内存消耗，并且如果表结构发生变化（如增加列），可能会导致不必要的兼容性问题或数据冗余。它还可能阻止某些数据库优化（如覆盖索引）。
*   **合理使用 JOIN**：
    *   避免不必要的 `JOIN`。`JOIN` 操作会增加查询复杂度。
    *   确保 `JOIN` 条件的列上有索引。
    *   考虑是否可以将复杂的 `JOIN` 拆分成多个简单查询，然后在应用层组装数据（需要权衡，有时 `JOIN` 更高效）。
*   **优化 `WHERE` 子句**：
    *   尽量避免在 `WHERE` 子句中对索引列使用函数或进行运算，这可能导致索引失效。例如，`WHERE SUBSTRING(column, 1, 3) = 'abc'` 可能比 `WHERE column LIKE 'abc%'` 效率低（如果 `column` 上有索引）。
    *   注意 `OR` 条件的使用，有时 `UNION ALL` 可能比 `OR` 更高效（具体取决于数据库和查询计划）。
    *   对于模糊查询 `LIKE`，尽量避免使用前导通配符 (`%keyword`)，因为它通常会导致索引失效。如果业务需要，考虑使用全文索引或其他技术。
*   **批量操作 (Batch Operations)**：
    *   对于大量数据的插入、更新、删除，使用批量操作远比单条执行高效。
    *   MyBatis 的 `<foreach>` 标签可以用于构建批量 `INSERT` 或 `UPDATE` 语句。
    *   也可以通过 `SqlSession` 的 `ExecutorType.BATCH` 模式执行批量操作（这需要在创建 `SqlSession` 时指定，Spring 集成中可能需要自定义 `SqlSessionTemplate` 或 `SqlSessionFactory`）。
        ```java
        // 示例：使用 BATCH 模式 (更底层的方式)
        // SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
        // try {
        //     YourMapper mapper = sqlSession.getMapper(YourMapper.class);
        //     for (YourObject obj : list) {
        //         mapper.insertObject(obj);
        //     }
        //     sqlSession.commit(); // 或者 sqlSession.flushStatements() 来批量执行
        // } finally {
        //     sqlSession.close();
        // }
        ```
        在 Spring Boot 中，使用 `@Transactional` 时，通常 `SqlSession` 的生命周期由 Spring 管理。要使用 `BATCH` 模式，一种方式是在 `SqlSessionFactoryBean` 中设置 `defaultExecutorType`，或者为特定操作创建一个单独的 `SqlSessionTemplate` 配置为 `BATCH` 模式。
        不过，对于大多数场景，使用 `<foreach>` 构建批量 SQL 语句更为常见和方便。
*   **分页查询优化**：
    *   使用物理分页插件（如 `PageHelper`）而不是 `RowBounds` 逻辑分页。
    *   确保分页查询利用了索引，特别是 `ORDER BY` 的列。
    *   对于深度分页（如查询第10000页），MySQL 的 `LIMIT offset, count` 性能会下降，因为需要扫描 `offset + count` 条记录。可以考虑使用“书签”或“延迟关联”等优化技巧。
*   **合理使用缓存**：
    *   对于不经常变化且查询频繁的数据，合理配置二级缓存可以显著提升性能。
    *   注意缓存的失效策略和数据一致性问题。
*   **监控和分析**：
    *   使用数据库性能监控工具 (如 PMM for MySQL, pgAdmin for PostgreSQL) 或 APM (Application Performance Management) 工具 (如 SkyWalking, Pinpoint, New Relic) 来监控慢查询和数据库负载。
    *   定期审查和优化慢 SQL。

**常见问题：**

*   **Q: MyBatis 会自动帮我优化 SQL 吗？**
    *   A: 不会。MyBatis 忠实地执行你编写的 SQL。SQL 优化的责任在于开发者。
*   **Q: 如何在 MyBatis 中执行 `EXPLAIN`？**
    *   A: 你可以创建一个 Mapper 方法，其 SQL 就是 `EXPLAIN SELECT ...`，然后执行这个方法并查看结果。或者直接在数据库客户端执行。

---

#### 5.4 避免 N+1 查询

N+1 查询是 ORM 和持久层框架中常见的性能问题，MyBatis 中也可能出现，尤其是在处理关联对象时。

**什么是 N+1 查询？**

当你查询一个主对象列表（1 次查询），然后对于列表中的每个主对象，又单独去查询其关联的子对象（N 次查询），总共执行了 1 + N 次查询，这就是 N+1 问题。

**MyBatis 中 N+1 产生的常见场景：**

*   在使用 `<association>` 或 `<collection>` 进行嵌套查询 (Nested Select) 并且**没有开启或合理使用延迟加载 (Lazy Loading)** 时。
    ```xml
    <!-- 假设 OrderMapper.xml -->
    <resultMap id="OrderWithUserMap" type="Order">
        <id property="id" column="order_id"/>
        <result property="orderNumber" column="order_no"/>
        <!-- 嵌套查询，如果 fetchType 不是 lazy 或者被立即访问 -->
        <association property="customer" column="user_id" javaType="User"
                     select="com.example.mapper.UserMapper.findById"/>
    </resultMap>
    <!-- 当查询 List<Order> 时，如果每个 Order 的 customer 属性被访问，就会触发对 UserMapper.findById 的 N 次调用 -->
    ```

**避免和解决 N+1 的方法：**

1.  **使用 JOIN 查询 (Eager Fetching)**：
    *   在一次 SQL 查询中通过 `JOIN` 将主对象和关联对象的数据一起查出来，然后通过 `<resultMap>` 的 `<association>` 和 `<collection>` 进行映射。
    *   这是最直接有效避免 N+1 的方法。
    ```xml
    <resultMap id="OrderWithUserJoinedMap" type="Order">
        <id property="id" column="o_id"/>
        <result property="orderNumber" column="o_number"/>
        <association property="customer" javaType="User" resultMap="userResultMapPrefix"/>
    </resultMap>
    <resultMap id="userResultMapPrefix" type="User"> <!-- 可以用前缀区分列 -->
         <id property="id" column="u_id"/>
         <result property="username" column="u_name"/>
    </resultMap>
    <!-- SQL -->
    <!-- SELECT o.id as o_id, o.order_number as o_number, u.id as u_id, u.username as u_name
         FROM orders o JOIN users u ON o.user_id = u.id
         WHERE ...
    -->
    ```
    *   **缺点**：如果关联对象过多或层级过深，JOIN 语句可能变得复杂，且可能产生笛卡尔积（对于一对多和多对多），需要注意去重和数据冗余。

2.  **合理使用延迟加载 (Lazy Loading)**：
    *   **全局配置**：`mybatis.configuration.lazy-loading-enabled: true`
    *   **局部配置**：在 `<association>` 或 `<collection>` 上设置 `fetchType="lazy"`。
    *   当开启延迟加载后，关联对象只有在**实际被访问时**才会触发查询。如果某些场景下你不需要访问关联对象，就可以避免不必要的查询。
    *   **触发延迟加载的条件**：当调用关联对象的 getter 方法，或者 `equals()`, `hashCode()`, `toString()`, `clone()` 等方法时，会触发加载。
    *   **`aggressiveLazyLoading`** (默认为 `false`)：如果设为 `true`，访问主对象的任何一个属性都会导致其所有懒加载的关联对象被加载。通常保持 `false`。
    *   **注意**：延迟加载依赖于 MyBatis 创建的代理对象。如果对象在 `SqlSession` 关闭后才访问懒加载属性，会抛出 `LazyLoadException`。在 Spring 集成中，如果事务结束 (`SqlSession` 关闭)，之后访问懒加载属性就会出问题。
        *   **解决方案**：确保在 `SqlSession` 开启的范围内（通常是 `@Transactional` 方法内）访问懒加载属性，或者使用 `OpenSessionInViewFilter` / `Interceptor` (对于 Web 应用，但这有其自身的优缺点，可能导致长事务或意外的数据库访问)。

3.  **分批查询 (Batch Fetching / IN Clause)**：
    *   先查询出主对象列表 (1 次查询)。
    *   收集所有主对象的 ID。
    *   根据这些 ID，使用 `IN` 子句一次性查询出所有相关的子对象 (1 次查询)。
    *   在应用层将子对象与主对象进行匹配和组装。
    *   总共执行 1 + 1 = 2 次查询。
    *   MyBatis 本身没有直接提供这种模式的自动化支持（不像 JPA 的 `@BatchSize`），需要开发者手动实现这种逻辑。
        ```java
        // Service 层逻辑
        // List<Order> orders = orderMapper.findOrders(...); // 查询主订单
        // if (!orders.isEmpty()) {
        //     List<Long> userIds = orders.stream().map(Order::getUserId).distinct().collect(Collectors.toList());
        //     List<User> users = userMapper.findUsersByIds(userIds); // IN 查询用户
        //     Map<Long, User> userMap = users.stream().collect(Collectors.toMap(User::getId, u -> u));
        //     orders.forEach(order -> order.setCustomer(userMap.get(order.getUserId())));
        // }
        ```

4.  **对于一对多/多对多，使用 `resultMap` 的 `<collection>` 结合 JOIN**：
    *   MyBatis 在处理 `JOIN` 带来的一对多结果集时，会自动将多行子对象数据聚合到主对象的集合属性中，避免了 N+1。
    ```xml
    <resultMap id="UserWithOrdersMap" type="User">
        <id property="id" column="user_id"/>
        <result property="username" column="username"/>
        <collection property="orders" ofType="Order">
            <id property="id" column="order_id"/>
            <result property="orderNumber" column="order_no"/>
        </collection>
    </resultMap>
    <!-- SQL -->
    <!-- SELECT u.id as user_id, u.username, o.id as order_id, o.order_no
         FROM users u LEFT JOIN orders o ON u.id = o.user_id
         WHERE u.id = #{userId}
    -->
    ```
    MyBatis 会正确地将一个用户 (user_id, username) 的多条订单记录 (order_id, order_no) 填充到 `User` 对象的 `orders` 列表中。

**最佳实践：**

*   **优先考虑 JOIN 查询**，尤其是一对一和多对一关联。
*   对于一对多，如果数据量不大，JOIN 依然是好选择。如果子集合数据量非常大，JOIN 可能导致主对象数据冗余过多，此时可以考虑延迟加载或分批查询。
*   谨慎使用嵌套查询，如果使用，务必结合延迟加载，并清楚其触发条件和生命周期。
*   通过日志监控 SQL 执行数量，及时发现潜在的 N+1 问题。

---

#### 5.5 日志与调试

有效的日志和调试手段对于开发和排查 MyBatis 问题至关重要。

**1. 配置 MyBatis SQL 日志 (Spring Boot `application.yml`)**：

*   **打印执行的 SQL 和参数 (推荐)**:
    ```yaml
    logging:
      level:
        # 将 com.example.yourproject.mapper 替换为你的 Mapper 接口所在的包路径
        com.example.yourproject.mapper: DEBUG
        # 或者更精细地控制 (通常上面的就够了)
        # java.sql.Connection: DEBUG
        # java.sql.Statement: DEBUG
        # java.sql.PreparedStatement: DEBUG # 这个能看到 PrepareStatement 的 SQL 和绑定的参数值
        # java.sql.ResultSet: TRACE      # (非常详细，显示结果集，生产环境谨慎开启)
    ```
    当 Mapper 包的日志级别设为 `DEBUG` 时，MyBatis 会通过 SLF 4 J (通常由 Logback 实现) 输出类似以下格式的日志：
    ```
    DEBUG c.e.y.mapper.UserMapper.findById - ==>  Preparing: SELECT id, username, email FROM users WHERE id = ?
    DEBUG c.e.y.mapper.UserMapper.findById - ==> Parameters: 1(Long)
    TRACE c.e.y.mapper.UserMapper.findById - <==      Total: 1
    ```
    *   `Preparing`: 显示预编译的 SQL 语句。
    *   `Parameters`: 显示绑定的参数值和类型。
    *   `Total`: 显示查询结果的行数 (对于 `select`) 或影响的行数 (对于 `update` / `insert` / `delete`)。

*   **配置 MyBatis 内部日志实现 (可选，通常 Spring Boot 会自动处理好 SLF 4 J)**:
    `mybatis.configuration.log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl`
    MyBatis 支持多种日志实现：`SLF4J`, `LOG4J`, `LOG4J2`, `JDK_LOGGING`, `COMMONS_LOGGING`, `STDOUT_LOGGING` (直接输出到控制台), `NO_LOGGING`。

**2. 使用 Logback / Log 4 j 2 进行更细致的日志配置**：

*   如果你需要更复杂的日志配置 (如输出到文件、不同级别不同输出、异步日志等)，可以在 `src/main/resources` 下创建 `logback-spring.xml` (推荐) 或 `log4j2-spring.xml`。
    **`logback-spring.xml` 示例：**
    ```xml
    <configuration>
        <include resource="org/springframework/boot/logging/logback/base.xml"/>

        <!-- Console Appender -->
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>

        <!-- MyBatis Mapper SQL Log -->
        <logger name="com.example.yourproject.mapper" level="DEBUG" additivity="false">
            <appender-ref ref="CONSOLE"/>
            <!-- <appender-ref ref="FILE_SQL"/> 可以配置一个专门输出 SQL 的文件 Appender -->
        </logger>

        <!-- MyBatis PreparedStatement 参数日志 (如果上面的 DEBUG 不够详细) -->
        <!--
        <logger name="java.sql.PreparedStatement" level="DEBUG" additivity="false">
            <appender-ref ref="CONSOLE"/>
        </logger>
        <logger name="java.sql.Statement" level="DEBUG" additivity="false">
            <appender-ref ref="CONSOLE"/>
        </logger>
        -->

        <root level="INFO">
            <appender-ref ref="CONSOLE"/>
        </root>
    </configuration>
    ```

**3. 调试技巧**：

*   **断点调试**:
    *   在 Mapper 接口调用处打断点，单步进入 MyBatis 内部执行流程 (如果需要深入理解)。
    *   在 Service 层打断点，检查传入 Mapper 的参数是否正确，以及 Mapper 返回的结果是否符合预期。
*   **检查代理对象**: 确保你注入和调用的是 MyBatis 为 Mapper 接口生成的代理对象，而不是接口本身或其实例（虽然 Mapper 接口通常没有实例）。
*   **SQL 客户端验证**: 将 MyBatis 日志中打印出的 SQL (替换 `?` 为参数值) 拿到数据库客户端 (如 DBeaver, Navicat, MySQL Workbench) 中直接执行，验证 SQL 语句本身是否正确、是否能查出预期数据、性能如何。这是排查 SQL 问题非常有效的方法。
*   **`toString()` 方法**: 为你的实体类和参数对象实现有意义的 `toString()` 方法，方便在日志或调试器中查看对象状态。Lombok 的 `@ToString` 注解很有用。
*   **MyBatis 插件 (Interceptor)**: 可以编写自定义的 MyBatis 插件来拦截 SQL 执行过程，打印更详细的调试信息，或者在特定点进行检查。例如，一个插件可以记录完整的 SQL (参数已替换) 和执行时间。

**常见问题：**

*   **Q: 为什么我看不到 SQL 日志？**
    *   A: 检查：
        1.  `application.yml/properties` 中日志级别配置是否正确，包路径是否匹配你的 Mapper 接口。
        2.  项目中是否有 SLF 4 J 的实现 (如 Logback, Log 4 j 2)，Spring Boot Starter 通常会带。
        3.  `mybatis.configuration.log-impl` 是否配置正确 (如果手动配置了)。
        4.  检查是否有其他日志配置文件 (如 `logback.xml` 而非 `logback-spring.xml`) 覆盖了 Spring Boot 的配置。
*   **Q: SQL 日志中的参数是 `?`，怎么看到具体值？**
    *   A: 将 Mapper 包的日志级别设为 `DEBUG`，通常 SLF4J 实现 (如 Logback) 会在另一行 `Parameters:` 中显示具体值。如果需要更底层的，可以尝试将 `java.sql.PreparedStatement` 的级别也设为 `DEBUG` (具体日志输出格式取决于 JDBC 驱动和日志库的配合)。一些专门的 SQL 日志库或 MyBatis 插件 (如 P 6 Spy 或自定义拦截器) 可以提供更友好的、参数内联的 SQL 日志。

---

遵循这些最佳实践，并了解常见问题的解决方法，可以让你在使用 MyBatis 时更加得心应手，构建出高质量的应用程序。