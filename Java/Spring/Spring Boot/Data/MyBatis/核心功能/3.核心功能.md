深入探讨 MyBatis 的这些核心功能。这些是掌握 MyBatis 的关键所在，能够让你更灵活、更高效地使用它。

---

### 3. MyBatis 核心功能详解

#### 3.1 SQL 映射：`select`, `insert`, `update`, `delete`

这四个是最基本的 CRUD (Create, Read, Update, Delete) 操作映射标签，我们在之前的示例中已经接触过了。这里再强调一些它们共有的和各自特有的重要属性：

**通用属性 (适用于所有四个标签)：**

*   **`id` (必需)**: 映射语句的唯一标识符，通常与 Mapper 接口中的方法名一致。
*   **`parameterType` (可选)**: 传入 SQL 语句的参数的完全限定类名或别名。MyBatis 通常能自动推断，但显式指定可以更清晰。
*   **`timeout` (可选)**: 设置 SQL 执行的超时时间（秒）。
*   **`databaseId` (可选)**: 用于支持多数据库厂商。如果配置了 `databaseIdProvider`，MyBatis 会执行带有匹配 `databaseId` 的语句，或没有 `databaseId` 的语句。
*   **`lang` (可选, 默认为 `XMLLanguageDriver`)**: 指定用于解析 SQL 语句的语言驱动。通常不需要修改。

**`<select>` 标签特有属性：**

*   **`resultType` (可选)**: 指定 SQL 查询结果集应该映射到的 Java 类型（完全限定类名或别名）。适用于简单结果映射，当数据库列名与 Java 属性名一致或通过驼峰转换能匹配时。
*   **`resultMap` (可选)**: 引用一个预定义的 `<resultMap>` 的ID。用于复杂的结果映射，如列名与属性名不一致、关联查询、嵌套结果等。`resultType` 和 `resultMap` **二选一**。
*   **`fetchSize` (可选)**: JDBC 驱动程序每次从数据库获取的记录行数。可以优化大型结果集的处理。
*   **`resultSetType` (可选)**: 控制结果集的类型。可选值：`FORWARD_ONLY` (默认), `SCROLL_INSENSITIVE`, `SCROLL_SENSITIVE`。
*   **`statementType` (可选)**: 语句类型。可选值：`STATEMENT` (普通Statement), `PREPARED` (默认, PreparedStatement), `CALLABLE` (CallableStatement, 用于存储过程)。
*   **`useCache` (可选, 默认为 `true` for `<select>`)**: 是否对此 `select` 语句的结果启用二级缓存。
*   **`flushCache` (可选, 默认为 `false` for `<select>`)**: 执行此 `select` 语句前是否清空一级和二级缓存。通常在可能会读取到脏数据时设为 `true`。

**`<insert>` 标签特有属性：**

*   **`useGeneratedKeys` (可选, 默认为 `false`)**: 是否使用JDBC的 `getGeneratedKeys` 方法来获取数据库生成的主键（通常是自增 ID）。
*   **`keyProperty` (可选)**: 当 `useGeneratedKeys="true"` 时，指定将生成的主键值设置到参数对象的哪个属性上。
*   **`keyColumn` (可选)**: 当 `useGeneratedKeys="true"` 时，如果主键列名与 `keyProperty` 指定的 Java 属性不一致，用此属性指定数据库中的主键列名。
*   **`<selectKey>` 子元素**: 用于不支持自增主键或需要其他方式生成主键的数据库（如 Oracle 的序列）。它会在 `insert` 语句执行之前或之后执行一个查询来获取主键。
    *   `keyProperty`: 同上。
    *   `resultType`: `selectKey` 查询返回的主键类型。
    *   `order`: `BEFORE` 或 `AFTER`，表示在 `insert` 语句之前还是之后执行。
    *   `statementType`: 同上。
    ```xml
    <!-- Oracle Sequence Example -->
    <insert id="insertUserWithSequence" parameterType="User">
        <selectKey keyProperty="id" resultType="long" order="BEFORE">
            SELECT USER_SEQ.NEXTVAL FROM DUAL
        </selectKey>
        INSERT INTO users (id, username, email)
        VALUES (#{id}, #{username}, #{email})
    </insert>
    ```
*   **`flushCache` (可选, 默认为 `true` for `<insert>`)**: 执行此 `insert` 语句后是否清空一级和二级缓存。因为插入操作改变了数据，通常需要清空缓存。

**`<update>` 和 `<delete>` 标签特有属性：**

*   **`flushCache` (可选, 默认为 `true` for `<update>` / `<delete>`)**: 执行此语句后是否清空一级和二级缓存。
*   这两个标签通常返回一个 `int` 类型的值，表示受影响的行数。

---

#### 3.2 动态 SQL

动态 SQL 是 MyBatis 非常强大和灵活的功能，它允许你根据不同的条件动态地构建 SQL 语句。这避免了在 Java 代码中拼接 SQL 字符串的麻烦和风险。

常用的动态 SQL 元素：

1.  **`if`**: 用于简单的条件判断。
    ```xml
    <select id="findActiveUsersByName" resultType="User">
        SELECT * FROM users
        WHERE status = 'ACTIVE'
        <if test="username != null and username != ''">
            AND username LIKE CONCAT('%', #{username}, '%')
        </if>
    </select>
    ```
    *   `test` 属性的值是一个 OGNL (Object-Graph Navigation Language) 表达式，用于进行条件判断。
    *   如果 `username` 参数不为 `null` 且不为空字符串，则 `AND username LIKE ...` 这部分 SQL 会被包含。

2.  **`choose`, `when`, `otherwise`**: 类似于 Java 中的 `switch` 语句，只选择一个条件分支执行。
    ```xml
    <select id="findUsersByCriteria" resultType="User">
        SELECT * FROM users
        WHERE
        <choose>
            <when test="id != null">
                id = #{id}
            </when>
            <when test="email != null and email != ''">
                email = #{email}
            </when>
            <otherwise>
                status = 'ACTIVE'
            </otherwise>
        </choose>
    </select>
    ```

3.  **`where`**: 用于智能地处理 `AND` 或 `OR` 前缀。如果 `where` 元素内的任何条件成立，它会自动插入 `WHERE` 关键字，并且会移除多余的 `AND` 或 `OR`。
    ```xml
    <select id="findUsersDynamically" resultType="User">
        SELECT * FROM users
        <where>
            <if test="username != null and username != ''">
                AND username = #{username}
            </if>
            <if test="email != null and email != ''">
                AND email = #{email}
            </if>
            <if test="status != null">
                AND status = #{status}
            </if>
        </where>
    </select>
    <!-- 如果 username 和 email 都为 null, 但 status 不为 null, 生成: WHERE status = #{status} -->
    <!-- 如果 username 不为 null, 其他为 null, 生成: WHERE username = #{username} (自动去掉开头的 AND) -->
    ```

4.  **`set`**: 用于动态 `UPDATE` 语句。它会自动插入 `SET` 关键字，并移除任何多余的逗号。
    ```xml
    <update id="updateUserDynamically" parameterType="User">
        UPDATE users
        <set>
            <if test="username != null and username != ''">
                username = #{username},
            </if>
            <if test="email != null and email != ''">
                email = #{email},
            </if>
            <if test="password != null and password != ''">
                password = #{password},
            </if>
        </set>
        WHERE id = #{id}
    </update>
    <!-- 如果只更新 email, 生成: UPDATE users SET email = #{email} WHERE id = #{id} (自动去掉末尾逗号) -->
    ```

5.  **`foreach`**: 用于迭代集合（如 `List`, `Set`, `Array`）或 `Map`，常用于构建 `IN` 条件或批量插入/更新。
    *   `collection` (必需): 指定要迭代的集合参数的名称。如果参数是 `List` 类型，默认为 `list`；如果是数组类型，默认为 `array`。如果使用了 `@Param` 注解，则使用注解的名称。
    *   `item` (必需): 迭代过程中当前元素的变量名。
    *   `index` (可选): 迭代过程中当前元素的索引（对于 `List` 和数组）或键（对于 `Map`）。
    *   `open` (可选): 迭代开始前添加的字符串。
    *   `close` (可选): 迭代结束后添加的字符串。
    *   `separator` (可选): 每次迭代之间添加的分隔符。

    ```xml
    <!-- IN 条件示例 -->
    <select id="findUsersByIds" resultType="User">
        SELECT * FROM users
        WHERE id IN
        <foreach item="userId" collection="idList" open="(" separator="," close=")">
            #{userId}
        </foreach>
        <!-- 假设 idList 是 [1, 2, 3], 生成: WHERE id IN (1,2,3) -->
    </select>

    <!-- 批量插入示例 (MySQL) -->
    <insert id="batchInsertUsers" parameterType="list">
        INSERT INTO users (username, email) VALUES
        <foreach item="user" collection="list" separator=",">
            (#{user.username}, #{user.email})
        </foreach>
    </insert>
    ```

6.  **`trim`**: 一个更通用的元素，用于添加前缀/后缀，并移除指定的前缀/后缀覆盖。`where` 和 `set` 标签实际上是 `trim` 的特例。
    *   `prefix` (可选): 当内部有内容时，在前面添加的前缀。
    *   `suffix` (可选): 当内部有内容时，在后面添加的后缀。
    *   `prefixOverrides` (可选): 如果内部内容以指定的字符串开头，则移除这些字符串。
    *   `suffixOverrides` (可选): 如果内部内容以指定的字符串结尾，则移除这些字符串。

    ```xml
    <!-- 使用 trim 实现类似 where 的效果 -->
    <select id="findUsersWithTrim" resultType="User">
        SELECT * FROM users
        <trim prefix="WHERE" prefixOverrides="AND |OR ">
            <if test="username != null and username != ''">
                AND username = #{username}
            </if>
            <if test="email != null and email != ''">
                OR email = #{email} <!-- 注意这里可以是 OR -->
            </if>
        </trim>
    </select>
    ```

7.  **`bind`**: 允许你在 OGNL 表达式中创建一个变量，并在后续的 SQL 中使用它。常用于模糊查询时拼接 `%`。
    ```xml
    <select id="findUsersByUsernameLike" resultType="User">
        <bind name="pattern" value="'%' + _parameter.getUsername() + '%'" />
        <!-- 或者 <bind name="pattern" value="'%' + username + '%'" /> 如果 username 是直接参数 -->
        SELECT * FROM users
        WHERE username LIKE #{pattern}
    </select>
    <!-- 或者在 SQL 中直接使用 CONCAT (数据库函数) -->
    <!-- WHERE username LIKE CONCAT('%', #{username}, '%') -->
    ```
    注意：`_parameter` 是一个内置变量，如果参数是一个简单类型或没有用 `@Param` 的单个对象，它指向这个参数对象。如果参数是 Map 或 JavaBean，可以直接访问其属性。

8.  **`<sql>` 和 `<include>`**: 用于定义可重用的 SQL 片段。
    *   `<sql id="columns">id, username, email, created_at</sql>`
    *   `<select id="findUserById" resultType="User"> SELECT <include refid="columns"/> FROM users WHERE id = #{id} </select>`
    *   `<include>` 还可以传递属性：
        ```xml
        <sql id="userColumns">
            ${alias}.id, ${alias}.username, ${alias}.email
        </sql>
        <select id="selectUsers" resultType="User">
            SELECT
                <include refid="userColumns"><property name="alias" value="u"/></include>
            FROM users u
        </select>
        ```

---

#### 3.3 参数处理

MyBatis 如何处理传入 SQL 语句的参数。

1.  **`#{} (预编译参数)`**:
    *   这是**推荐的参数占位符**。
    *   MyBatis 会将其替换为 `?`，并使用 `PreparedStatement` 安全地设置参数值。
    *   **有效防止 SQL 注入**。
    *   `#{propertyName}`: `propertyName` 是参数对象的属性名（如果是 JavaBean 或 Map），或者是 `@Param` 注解指定的名字，或者是参数本身的索引（不推荐）。
    *   可以指定 `jdbcType` 和 `typeHandler`：`#{propertyName, jdbcType=VARCHAR, typeHandler=MyTypeHandler}`。`jdbcType` 有时是必要的，比如当参数值为 `null` 时，JDBC 需要知道目标列的类型。

2.  **`${} (字符串替换)`**:
    *   MyBatis 会将 `${propertyName}` 直接替换为参数的值，**不做任何转义或预编译处理**。
    *   **存在 SQL 注入风险，务必谨慎使用**，并且不要用于接收用户输入的值。
    *   主要用于动态表名、列名、`ORDER BY` 子句等不能使用预编译参数的场景。
    *   示例：`ORDER BY ${columnName} ${sortDirection}`。
    *   如果你确定传入的值是安全的（比如来自程序内部定义的常量或枚举），可以考虑使用。

3.  **`@Param` 注解**:
    *   当 Mapper 接口的方法有多个参数时，强烈建议使用 `@Param("name")` 为每个参数命名。
    *   XML 中就可以通过 `#{name}` 或 `${name}` 来引用。
    *   如果只有一个参数且是 JavaBean 或集合/数组，可以不使用 `@Param`，MyBatis 会尝试直接使用属性名或默认名称 (`list`, `array`)。但为了清晰和避免潜在问题，对于非 JavaBean 的单个参数也推荐使用 `@Param`。
    ```java
    // Mapper 接口
    List<User> findUsers(@Param("status") String status, @Param("orderByColumn") String orderByColumn);

    // XML
    // <select id="findUsers" resultType="User">
    //     SELECT * FROM users WHERE status = #{status} ORDER BY ${orderByColumn}
    // </select>
    ```

4.  **`ParameterMap` (已不推荐)**:
    *   早期 MyBatis (iBATIS) 版本中用于定义参数映射的方式，类似 `ResultMap`。
    *   现在几乎不再使用，因为 `@Param` 和 JavaBean 参数更简单直观。

**参数对象的类型：**

*   **基本类型/包装类型**: `int`, `String`, `Long`, etc.
    *   如果只有一个这样的参数，XML 中可以直接用 `#{_parameter}` 或 `#{anyName}` (在某些 MyBatis 版本和配置下)。推荐使用 `@Param`。
*   **JavaBean (POJO)**: MyBatis 会自动读取其属性。XML 中用 `#{propertyName}`。
*   **Map**: XML 中用 `#{keyName}`。
*   **集合/数组 (List, Set, Array)**: 通常用于 `foreach` 标签。如果作为整体参数（不常见），默认名称是 `list` 或 `array`。

---

#### 3.4 结果映射：`resultMap`

`resultMap` 是 MyBatis 中处理复杂结果集映射的强大工具。当 `resultType` 无法满足需求时（如列名与属性名不一致且未开启驼峰转换、关联查询、嵌套结果、鉴别器等），就需要使用 `resultMap`。

**基本 `<resultMap>` 结构：**

```xml
<resultMap id="UserResultMap" type="com.example.yourproject.model.User">
    <constructor> <!-- 可选, 用于构造器注入 -->
        <idArg column="id" javaType="long" jdbcType="BIGINT"/>
        <arg column="username" javaType="string" jdbcType="VARCHAR"/>
    </constructor>
    <id property="id" column="user_id" jdbcType="BIGINT"/> <!-- 主键映射 -->
    <result property="username" column="user_name" jdbcType="VARCHAR"/> <!-- 普通列映射 -->
    <result property="emailAddress" column="email" jdbcType="VARCHAR"/>
    <result property="isActive" column="status" javaType="boolean" jdbcType="TINYINT" typeHandler="org.apache.ibatis.type.BooleanTypeHandler"/>
</resultMap>
```
*   `id`: `resultMap` 的唯一标识。
*   `type`: 映射的目标 Java 类型。
*   `<constructor>`: 用于通过构造方法实例化对象。`<idArg>` 用于主键参数，`<arg>` 用于普通参数。
*   `<id>`: 定义主键属性的映射。有助于性能提升，特别是在嵌套查询和缓存中。
*   `<result>`: 定义普通属性的映射。
    *   `property`: Java 对象的属性名。
    *   `column`: 数据库结果集的列名。
    *   `javaType`: Java 属性的类型 (通常 MyBatis 可以推断，但显式指定更精确)。
    *   `jdbcType`: 数据库列的 JDBC 类型 (可选，有助于类型转换)。
    *   `typeHandler`: 指定自定义的 `TypeHandler` 来处理特定类型的转换。

**高级映射：**

1.  **关联 (Association) - 一对一 / 多对一**
    *   用于映射一个复杂类型的属性 (即一个对象嵌套在另一个对象中)。
    *   例如：一个 `Order` 对象包含一个 `User` 对象。
    *   实现方式：
        *   **嵌套 `resultMap`**: 在一个 `resultMap` 内部定义另一个 `resultMap` 或引用一个已有的 `resultMap`。
        *   **嵌套查询 (Nested Select / N+1 问题)**: 先查询主对象，然后根据主对象的 ID 再去查询关联对象。**可能会导致 N+1 查询问题，需要谨慎使用或优化。**

    ```xml
    <!-- Order 实体类包含 User user 属性 -->
    <resultMap id="OrderResultMap" type="com.example.model.Order">
        <id property="id" column="order_id"/>
        <result property="orderNumber" column="order_no"/>
        <!-- 方式一：嵌套 resultMap (JOIN 查询) -->
        <association property="customer" javaType="com.example.model.User">
            <id property="id" column="user_id"/>
            <result property="username" column="user_name"/>
            <result property="email" column="user_email"/>
        </association>
        <!-- SQL 示例 (JOIN):
             SELECT o.id as order_id, o.order_no, u.id as user_id, u.username as user_name, u.email as user_email
             FROM orders o JOIN users u ON o.user_id = u.id
             WHERE o.id = #{id}
        -->
    </resultMap>

    <resultMap id="OrderWithNestedSelectMap" type="com.example.model.Order">
        <id property="id" column="order_id"/>
        <result property="orderNumber" column="order_no"/>
        <!-- 方式二：嵌套查询 (N+1 风险) -->
        <association property="customer" column="user_id" javaType="com.example.model.User"
                     select="com.example.mapper.UserMapper.findById" fetchType="lazy"/>
        <!-- 'column="user_id"' 会作为参数传递给 UserMapper.findById 方法 -->
        <!-- 'fetchType="lazy"' (或 eager): 开启延迟加载 -->
    </resultMap>
    ```
    *   `fetchType`: `lazy` (延迟加载) 或 `eager` (立即加载)。延迟加载可以提高初始查询性能，但如果总是需要访问关联对象，可能会导致多次查询。
        *   全局延迟加载开关: `mybatis.configuration.lazy-loading-enabled=true`
        *   积极的延迟加载: `mybatis.configuration.aggressive-lazy-loading=true` (默认为 false) 如果开启，访问对象任何属性都会触发所有懒加载属性的加载。

2.  **集合 (Collection) - 一对多**
    *   用于映射一个集合类型的属性 (如 `List<OrderItem>`)。
    *   例如：一个 `Order` 对象包含一个 `List<OrderItem>` 列表。
    *   实现方式类似 `association`，也有嵌套 `resultMap` 和嵌套查询。

    ```xml
    <!-- Order 实体类包含 List<OrderItem> items 属性 -->
    <resultMap id="OrderWithItemsResultMap" type="com.example.model.Order">
        <id property="id" column="order_id"/>
        <result property="orderNumber" column="order_no"/>
        <association property="customer" column="user_id" javaType="com.example.model.User"
                     select="com.example.mapper.UserMapper.findById" fetchType="lazy"/>
        <!-- 嵌套 resultMap (JOIN 查询) -->
        <collection property="items" ofType="com.example.model.OrderItem">
            <id property="id" column="item_id"/>
            <result property="productName" column="product_name"/>
            <result property="quantity" column="quantity"/>
            <result property="price" column="price"/>
        </collection>
        <!-- SQL 示例 (JOIN, 可能产生笛卡尔积，需要主对象去重):
             SELECT o.id as order_id, o.order_no, ..., oi.id as item_id, oi.product_name, ...
             FROM orders o
             LEFT JOIN order_items oi ON o.id = oi.order_id
             WHERE o.id = #{id}
             MyBatis 会根据 order_id 将多行 order_items 记录聚合到同一个 Order 对象的 items 集合中。
        -->
    </resultMap>

    <resultMap id="OrderWithNestedSelectItemsMap" type="com.example.model.Order">
        <id property="id" column="order_id"/>
        <result property="orderNumber" column="order_no"/>
        <!-- 嵌套查询 (N+1 风险) -->
        <collection property="items" column="order_id" ofType="com.example.model.OrderItem"
                    select="com.example.mapper.OrderItemMapper.findItemsByOrderId" fetchType="lazy"/>
    </resultMap>
    ```
    *   `ofType`: 指定集合中元素的类型。

3.  **鉴别器 (Discriminator)**
    *   用于根据某个列的值来决定使用哪个 `resultMap` 或如何映射。类似于 Java 中的 `switch` 或 `if-else if-else`。
    *   例如：一个 `Vehicle` 表可能存储了 `Car` 和 `Truck` 两种类型的数据，它们有共享的属性，也有各自特有的属性。

    ```xml
    <resultMap id="VehicleResultMap" type="com.example.model.Vehicle">
        <id property="id" column="id"/>
        <result property="make" column="make"/>
        <result property="model" column="model"/>
        <discriminator javaType="string" column="vehicle_type">
            <case value="CAR" resultMap="CarResultMap"/>
            <case value="TRUCK" resultMap="TruckResultMap"/>
            <!-- 也可以直接在 case 内部定义映射 -->
            <case value="BIKE">
                 <result property="hasBasket" column="has_basket"/>
            </case>
        </discriminator>
    </resultMap>

    <resultMap id="CarResultMap" type="com.example.model.Car" extends="VehicleResultMap">
        <result property="numberOfDoors" column="door_count"/>
    </resultMap>

    <resultMap id="TruckResultMap" type="com.example.model.Truck" extends="VehicleResultMap">
        <result property="towingCapacity" column="towing_capacity"/>
    </resultMap>
    ```
    *   `column`: 用于判断的列。
    *   `javaType`: 该列在 Java 中的类型。
    *   `<case value="...">`: 当列的值匹配 `value` 时应用的映射。
        *   `resultMap`: 引用另一个 `resultMap`。
        *   可以直接在 `<case>` 内部定义 `<result>` 等映射。
    *   `extends`: `resultMap` 可以继承另一个 `resultMap` 的配置。

---

#### 3.5 一级缓存与二级缓存

MyBatis 内建了两级缓存机制，用于提升查询性能，减少对数据库的直接访问。

1.  **一级缓存 (Local Cache / Session Cache)**:
    *   **作用域**: `SqlSession` 级别。默认开启且无法关闭。
    *   **生命周期**: 当 `SqlSession` 被创建时，一个新的一级缓存被创建。当 `SqlSession` 关闭或清空 (flush) 时，缓存被清除。
    *   **工作原理**: 在同一个 `SqlSession` 中，如果执行完全相同的 SQL 查询（相同的语句 ID，相同的参数，相同的 `RowBounds` 等），MyBatis 会直接从一级缓存中返回结果，而不会再次查询数据库。
    *   **失效情况**:
        *   执行 `commit()` (如果 `autoCommit=false`)。
        *   执行任何 `insert`, `update`, `delete` 操作会清空该 `SqlSession` 的一级缓存（为了防止脏读）。
        *   调用 `sqlSession.clearCache()` 方法。
        *   `select` 语句的 `flushCache` 属性设置为 `true`。
    *   **Spring 集成**: 在 Spring 集成中，每个数据库操作通常都在一个新的 `SqlSession` 中执行（由 `SqlSessionTemplate` 管理），因此一级缓存的跨方法共享效果不明显，主要在同一个事务方法内的多次相同查询中起作用。

2.  **二级缓存 (Global Cache / Namespace Cache)**:
    *   **作用域**: `Mapper Namespace` 级别。多个 `SqlSession` 可以共享同一个 Namespace 下的二级缓存。
    *   **生命周期**: 应用级别，只要应用在运行，缓存就可能存在，直到被清除。
    *   **开启方式**:
        1.  全局配置开启二级缓存 (默认是开启的，但需要进一步配置才生效)：
            `application.yml`: `mybatis.configuration.cache-enabled: true` (默认值)
        2.  在 Mapper XML 文件中使用 `<cache/>` 标签声明该 Namespace 使用二级缓存：
            ```xml
            <mapper namespace="com.example.mapper.UserMapper">
                <cache
                    eviction="FIFO"   atributos de la caché LRU (Least Recently Used), FIFO (First In First Out), SOFT, WEAK
                    flushInterval="60000"  limpia el caché cada 60 segundos
                    size="512"  numero máximo de objetos que puede guardar la caché
                    readOnly="true"  si es true, devuelve la misma instancia del objeto cacheado. Si es false, devuelve una copia (más seguro, pero más lento)
                    blocking="false" si es true, en caso de cache miss, solo un hilo irá a la DB, los demás esperarán.
                />
                <!-- ...你的 SQL 语句... -->
            </mapper>
            ```
            或者使用更复杂的自定义缓存实现，如 Ehcache, Redis：
            `<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>` (需要引入 `mybatis-ehcache` 依赖)
            `<cache type="org.mybatis.caches.redis.RedisCache"/>` (需要引入 `mybatis-redis` 依赖)
        3.  被缓存的 Java 对象必须实现 `java.io.Serializable` 接口。
        4.  `select` 语句的 `useCache` 属性必须为 `true` (默认值)。
    *   **工作原理**: 当一个 `SqlSession` 提交 (`commit()`) 或关闭 (`close()`) 时，它的一级缓存中的数据如果配置了二级缓存，并且符合条件，会被刷新到对应的 Namespace 的二级缓存中。后续其他 `SqlSession` 执行相同查询时，可以从二级缓存获取数据。
    *   **失效/清空情况**:
        *   执行同一个 Namespace 下的 `insert`, `update`, `delete` 操作（默认会清空该 Namespace 的二级缓存，`flushCache="true"`）。
        *   `select` 语句的 `flushCache` 属性设置为 `true`。
        *   达到 `<cache>` 标签中配置的 `eviction` 策略（如 LRU）、`flushInterval` 时间间隔、`size` 限制等。
    *   **`readOnly` 属性**:
        *   `true` (默认对于非序列化缓存如 HashMap): 缓存返回的是对象的同一实例。性能好，但如果对象被修改，可能会影响其他使用者（线程不安全）。
        *   `false` (默认对于序列化缓存如 Ehcache/Redis): 缓存返回的是对象的副本（通过序列化和反序列化）。线程安全，但性能稍差。
    *   **注意事项**:
        *   二级缓存适用于**读多写少**且数据一致性要求不是极端严格的场景。
        *   对于经常变化的数据，使用二级缓存可能导致缓存命中率低，甚至因频繁刷新缓存而降低性能。
        *   在分布式环境中，默认的基于 JVM 内存的二级缓存 (如 MyBatis 内置的 `PerpetualCache` 使用 `HashMap`) 是无法共享的，每个应用实例都有自己的缓存。需要使用集中的分布式缓存方案（如 Redis, Memcached, Ehcache 分布式模式）。

---

#### 3.6 插件 (Plugins / Interceptors)

MyBatis 允许你通过插件（拦截器）在 SQL 执行过程的特定点进行拦截和修改，这为扩展 MyBatis 功能提供了强大的机制。

**可拦截的方法签名 (四大对象)：**

1.  **`Executor` (执行器)**: 拦截执行器的方法，如 `update`, `query`, `commit`, `rollback` 等。这是最常用的拦截点，可以修改 SQL、参数、结果等。
2.  **`ParameterHandler` (参数处理器)**: 拦截参数处理的方法，如 `getParameterObject`, `setParameters`。
3.  **`ResultSetHandler` (结果集处理器)**: 拦截结果集处理的方法，如 `handleResultSets`, `handleOutputParameters`。可以修改查询结果。
4.  **`StatementHandler` (语句处理器)**: 拦截语句处理的方法，如 `prepare`, `parameterize`, `batch`, `update`, `query`。可以修改 SQL 语句的生成。

**如何编写一个插件：**

1.  实现 `org.apache.ibatis.plugin.Interceptor` 接口。
2.  使用 `@Intercepts` 注解声明要拦截的方法签名。
    *   `@Signature` 注解定义了具体的拦截点：
        *   `type`: 要拦截的四大对象之一 (`Executor.class`, `ParameterHandler.class`, etc.)。
        *   `method`: 要拦截的方法名。
        *   `args`: 要拦截的方法的参数类型列表。

```
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.plugin.*;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;

import java.util.Properties;

// 示例：一个简单的查询耗时打印插件
@Intercepts({
    @Signature(
        type = Executor.class,
        method = "query",
        args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}
    ),
    @Signature( // 也可以拦截 update, commit 等
        type = Executor.class,
        method = "update",
        args = {MappedStatement.class, Object.class}
    )
})
public class ExecutionTimeInterceptor implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = invocation.proceed(); // 执行原始方法
        long endTime = System.currentTimeMillis();
        long executionTime = endTime - startTime;

        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];
        String sqlId = mappedStatement.getId();
        System.out.println("[ExecutionTimeInterceptor] SQL ID [" + sqlId + "] executed in " + executionTime + "ms");

        return result;
    }

    @Override
    public Object plugin(Object target) {
        // 使用 MyBatis 提供的 Plugin.wrap 方法创建代理对象
        return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {
        // 可以从 MyBatis 配置文件中获取插件的属性
        // String propValue = properties.getProperty("someProperty");
    }
}
```

**注册插件：**

*   **XML 配置 (`mybatis-config.xml`)**:
    ```xml
    <plugins>
        <plugin interceptor="com.example.yourproject.plugin.ExecutionTimeInterceptor">
            <property name="someProperty" value="someValue"/>
        </plugin>
    </plugins>
    ```
    然后在 `application.yml` 中指定 `mybatis.config-location: classpath:mybatis-config.xml`。

*   **Java Config (Spring Boot 推荐方式)**: 创建一个 `ConfigurationCustomizer` Bean。
    ```java
    import com.example.yourproject.plugin.ExecutionTimeInterceptor;
    import org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    @Configuration
    public class MyBatisPluginConfig {

        @Bean
        public ConfigurationCustomizer mybatisConfigurationCustomizer() {
            return configuration -> {
                ExecutionTimeInterceptor interceptor = new ExecutionTimeInterceptor();
                // 如果插件需要属性:
                // Properties props = new Properties();
                // props.setProperty("someProperty", "someValue");
                // interceptor.setProperties(props);
                configuration.addInterceptor(interceptor);
            };
        }
    }
    ```

**常用插件示例：**

*   **分页插件 (PageHelper)**: 非常流行的第三方插件，简化分页查询。
*   **性能监控插件**: 记录 SQL 执行时间、慢查询等。
*   **数据权限插件**: 根据用户权限动态修改 SQL，实现数据行/列级别过滤。
*   **乐观锁插件**: 自动处理版本号的更新和检查。
*   **加解密插件**: 对特定字段进行自动加解密。

---

以上就是 MyBatis 核心功能的详解。这些功能共同构成了 MyBatis 的强大能力，使其能够灵活应对各种数据持久化需求。