详细讲解如何在 Spring Boot 项目中快速上手并集成 MyBatis-Plus。MP 官方提供了 `mybatis-plus-boot-starter`，使得这个过程非常简单。

---

### 2. 快速上手与 Spring Boot 集成

#### 2.1 依赖引入 (`mybatis-plus-boot-starter`)

要在 Spring Boot 项目中使用 MyBatis-Plus，首先需要在你的 `pom.xml` (Maven) 或 `build.gradle` (Gradle) 文件中添加核心依赖。

**对于 Maven 项目 (`pom.xml`)：**

```xml
<dependencies>
    <!-- MyBatis-Plus Spring Boot Starter -->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.5.5</version> <!-- 请使用最新的稳定版本 -->
    </dependency>

    <!-- 数据库驱动 (以 MySQL 为例) -->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- Lombok (可选, 但推荐用于简化实体类代码) -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>

    <!-- Spring Boot Web Starter (如果需要构建 Web 应用) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Spring Boot Test Starter (用于测试) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

**关键点：**

*   `mybatis-plus-boot-starter`: 这是 MP 的核心 Spring Boot Starter。它会自动引入 `mybatis-plus-core`, `mybatis-plus-extension` (包含插件和条件构造器等), `mybatis-spring` (MyBatis 与 Spring 的集成包) 以及 Spring Boot 相关的自动配置类。
*   **数据库驱动**: 与原生 MyBatis 一样，你需要根据你的数据库类型添加相应的 JDBC 驱动。
*   **Lombok**: 强烈推荐使用 Lombok。MP 的很多示例和最佳实践都利用 Lombok 的 `@Data`, `@TableName`, `@TableId` 等注解来简化实体类的编写。
*   **版本号**: 建议总是查看 [MyBatis-Plus 的 GitHub 仓库](https://github.com/baomidou/mybatis-plus) 或 Maven 中央仓库来获取最新的稳定版本。目前（截至我最后更新时）`3.5.x` 系列是主流稳定版。

**对于 Gradle 项目 (`build.gradle`)：**

```gradle
dependencies {
    implementation 'com.baomidou:mybatis-plus-boot-starter:3.5.5' // 请使用最新的稳定版本
    runtimeOnly 'com.mysql:mysql-connector-j' // 以 MySQL 为例
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

#### 2.2 核心配置 (`application.yml` 或 `application.properties`)

引入依赖后，接下来是在 Spring Boot 的配置文件中进行必要的配置。MP 的配置项通常以 `mybatis-plus` 为前缀。

**`src/main/resources/application.yml`:**

```yaml
spring:
  # --- 数据源配置 (DataSource Configuration) ---
  # (与原生 MyBatis 配置方式相同)
  datasource:
    url: jdbc:mysql://localhost:3306/your_database_name?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
    username: your_username
    password: your_password
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari: # (可选, Spring Boot 默认使用 HikariCP)
      connection-timeout: 30000
      idle-timeout: 600000
      maximum-pool-size: 10
      minimum-idle: 5

mybatis-plus:
  # --- MyBatis-Plus 核心配置 ---

  # (可选) MyBatis 原生 XML Mapper 文件位置
  # 如果你仍然需要使用自定义的 XML 文件 (MP 完全兼容)
  # 默认值: classpath*:/mapper/**/*.xml (如果 XML 放在 resources/mapper/ 下，可以不配)
  mapper-locations: classpath:mapper/**/*.xml # 例如: classpath:com/example/mapper/**/*.xml

  # (可选) 实体类别名扫描包 (与原生 MyBatis 的 type-aliases-package 作用类似)
  # 推荐配置，这样在 XML 或代码中可以使用类名作为类型别名
  type-aliases-package: com.example.yourproject.entity # 替换为你的实体类所在的包
  # (可选) 如果你的实体类和 type-aliases-package 不一致，可以单独指定
  # type-aliases-super-type: com.example.yourproject.base.BaseEntity # 指定别名的超类

  # (可选) 枚举类扫描包 (如果实体类中使用了枚举，并且希望MP能正确处理)
  # MP 会自动查找并注册这个包下的枚举类对应的 TypeHandler
  type-enums-package: com.example.yourproject.enums

  # (可选) 全局配置 (GlobalConfig)
  global-config:
    # 数据库相关配置
    db-config:
      # 主键类型 (IdType): AUTO, NONE, INPUT, ASSIGN_ID (雪花算法/Long), ASSIGN_UUID (UUID/String)
      id-type: assign_id # 推荐使用雪花算法作为默认分布式ID方案
      # 表名前缀 (用于 entity 生成或自动映射)
      # table-prefix: tbl_
      # 表名是否使用下划线转驼峰命名 (默认 true)
      # table-underline: true
      # 字段名是否使用下划线转驼峰命名 (默认 true, 建议开启)
      # field-underline: true # 已废弃, 使用 mybatis-plus.configuration.map-underscore-to-camel-case
      # 大写命名 (生成代码时表名、字段名均大写)
      # capital-mode: false
      # 逻辑删除字段 (实体属性名)
      logic-delete-field: deleted
      # 逻辑删除值 (默认为 1)
      logic-delete-value: "1" # 注意：字符串类型的值需要引号
      # 逻辑未删除值 (默认为 0)
      logic-not-delete-value: "0"
    # (可选) 是否打印 MyBatis-Plus Banner (默认 true)
    banner: false
    # (可选) 全局的 SQL 注入器 (一般不需要自定义)
    # sql-injector: com.baomidou.mybatisplus.core.injector.DefaultSqlInjector
    # (可选) 全局的 MetaObjectHandler (用于自动填充)
    # meta-object-handler: com.example.yourproject.config.MyMetaObjectHandler

  # (可选) MyBatis 原生配置 (Configuration)
  # 这些配置会应用到 MyBatis 的 Configuration 对象
  configuration:
    # 开启驼峰命名自动映射 (数据库下划线 -> Java 驼峰) - 非常重要且常用
    map-underscore-to-camel-case: true
    # 配置 MyBatis 使用的日志实现
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
    # (可选) 延迟加载总开关
    # lazy-loading-enabled: false
    # (可选) 是否开启二级缓存 (需要配合 Mapper 的 <cache/> 或 <cache-ref/>)
    # cache-enabled: false
    # (可选) 默认的执行器类型: SIMPLE, REUSE, BATCH
    # default-executor-type: SIMPLE
    # (可选) 指定默认的 Statement 超时时间 (秒)
    # default-statement-timeout: 30

  # (可选) 指定 MyBatis 原生配置文件路径 (如果你需要更复杂的 MyBatis 配置，如插件、TypeHandler 等)
  # MP 会加载并合并这个文件的配置。但很多配置也可以通过 mybatis-plus.configuration.* 或 Java Config 完成。
  # config-location: classpath:mybatis-config.xml

# (可选) 日志配置, 方便查看 MP/MyBatis 执行的 SQL
logging:
  level:
    com.example.yourproject.mapper: DEBUG # 将你的 Mapper 接口所在的包路径替换掉，设置为 DEBUG 可以看到执行的 SQL
    # 如果想看 MP 内部的日志 (例如插件执行情况)
    # com.baomidou.mybatisplus: DEBUG
```

**关键配置项解释：**

*   **`spring.datasource.*`**: 与原生 MyBatis 完全一致，用于配置数据源。
*   **`mybatis-plus.mapper-locations`**: 如果你除了使用 MP 的通用 Mapper 外，还需要自定义手写 SQL 的 XML 文件，这个配置项就很重要。它告诉 MP (实际上是 MyBatis) 去哪里加载这些 XML 文件。
*   **`mybatis-plus.type-aliases-package`**: 指定实体类所在的包，MP (和 MyBatis) 会为这些类注册别名，方便在 XML 中或作为 `resultType` 时直接使用类名。
*   **`mybatis-plus.type-enums-package`**: 如果你的实体类中使用了枚举类型，并且希望 MP 自动处理枚举与数据库值（通常是字符串或数字）的转换，可以配置此项。MP 会扫描该包下的枚举，并为其注册一个默认的 `MybatisEnumTypeHandler` 或 `EnumTypeHandler` (取决于枚举是否实现了 `IEnum` 接口)。
*   **`mybatis-plus.global-config.db-config.*`**:
    *   `id-type`: **非常重要**。全局配置默认的主键生成策略。
        *   `AUTO`: 数据库自增。
        *   `NONE`: 无策略，用户自己控制 (或通过 `@TableId(type = IdType.INPUT)` 手动输入)。
        *   `INPUT`: 用户手动输入主键。
        *   `ASSIGN_ID`: MP 默认使用雪花算法生成分布式唯一 ID (Long 类型)。如果主键是 String 类型，会使用不带 `-` 的 UUID。**推荐用于分布式系统**。
        *   `ASSIGN_UUID`: 生成 UUID (String 类型)。
    *   `logic-delete-field`, `logic-delete-value`, `logic-not-delete-value`: 全局配置逻辑删除相关的字段名和值。
*   **`mybatis-plus.configuration.*`**: 这些配置项会直接应用到 MyBatis 的 `org.apache.ibatis.session.Configuration` 对象上。
    *   `map-underscore-to-camel-case: true`: **强烈推荐开启**。自动将数据库的下划线命名风格映射到 Java 的驼峰命名风格。
    *   `log-impl`: 配置 MyBatis 使用的日志框架。Spring Boot 项目通常与 SLF 4 J (通过 Logback) 集成良好。
*   **`mybatis-plus.config-location`**: 如果你需要更复杂的 MyBatis 原生配置（比如注册全局的 MyBatis 插件、TypeHandler，或者定义复杂的 settings），可以创建一个 `mybatis-config.xml` 文件，并在这里指定其路径。MP 会加载并应用这个配置文件。不过，很多配置也可以通过 Spring Boot 的 Java Config 方式实现，这通常更符合 Spring Boot 的风格。

**Spring Boot 自动配置做了什么？**

当你引入 `mybatis-plus-boot-starter` 时，Spring Boot 会：

1.  自动检测并配置 `DataSource`。
2.  自动配置 `SqlSessionFactory`，并将 MP 的全局配置 (`GlobalConfig`) 和 MyBatis 配置 (`Configuration`) 应用上去。
3.  自动配置 `SqlSessionTemplate`。
4.  自动扫描 `@Mapper` 注解的接口（或通过 `@MapperScan` 配置的包路径下的接口），并为它们注册 Mapper Bean。
5.  自动配置 MP 的一些核心组件，如 `IdentifierGenerator` (用于主键生成), `ISqlInjector` (用于注入通用 SQL)。
6.  如果你配置了 MP 的插件 (如分页插件、乐观锁插件)，Starter 也会尝试自动配置它们。

#### 2.3 与 MyBatis 原生配置的协同

MyBatis-Plus 的设计原则是“只做增强不做改变”，因此它与 MyBatis 的原生配置是**完全兼容且可以协同工作**的。

*   **XML 映射文件**：
    *   你可以继续使用 MyBatis 的 XML 映射文件来编写复杂的自定义 SQL。MP 不会干扰它们。
    *   确保 `mybatis-plus.mapper-locations` (或 `mybatis.mapper-locations`，MP 会兼容) 配置正确。
    *   MP 的通用方法 (如 `selectById`) 是通过代码注入 SQL 的，它们不需要 XML 文件。但如果你在 `BaseMapper` 的子接口中定义了新的方法，这些新方法仍然需要在 XML 中提供 SQL 实现 (或者使用 MyBatis 的 `@Select` 等注解)。
*   **MyBatis 注解**：
    *   你可以在 Mapper 接口中继续使用 MyBatis 的 `@Select`, `@Insert`, `@Update`, `@Delete`, `@Results` 等注解来定义 SQL。MP 同样不干扰。
*   **`mybatis-config.xml`**：
    *   如果通过 `mybatis-plus.config-location` (或 `mybatis.config-location`) 指定了 `mybatis-config.xml` 文件，MP 会加载它。
    *   这意味着你可以在 `mybatis-config.xml` 中配置 MyBatis 原生的 `<settings>`, `<typeAliases>`, `<typeHandlers>`, `<plugins>` (MyBatis 原生插件) 等。
    *   **注意**：MP 自己的插件 (如 `PaginationInnerInterceptor`, `OptimisticLockerInnerInterceptor` 等) 通常建议通过 Java Config (`MybatisPlusInterceptor` Bean) 的方式配置，而不是放在 `mybatis-config.xml` 的 `<plugins>` 里，因为 MP 的 Starter 对 Java Config 的支持更好，并且能更好地与 Spring Boot 生态集成。
*   **配置项优先级**：
    *   通常，`application.yml/properties` 中的 `mybatis-plus.*` 配置具有较高优先级。
    *   如果同时在 `application.yml` 和 `mybatis-config.xml` 中配置了相同的 MyBatis 原生设置（如 `mapUnderscoreToCamelCase`），其最终效果可能取决于加载顺序和 MP 的合并策略，建议尽量在一个地方配置以避免混淆。对于 MyBatis 原生配置，优先考虑在 `mybatis-plus.configuration.*` 下配置。
*   **Type Handler 注册**：
    *   可以在 `mybatis-config.xml` 中注册。
    *   也可以通过 `mybatis-plus.type-handlers-package` 自动扫描。
    *   还可以通过 Java Config (`ConfigurationCustomizer` Bean) 编程方式注册。

**总结集成步骤：**

1.  **添加 `mybatis-plus-boot-starter` 依赖。**
2.  **配置 `application.yml/properties`**：
    *   数据源 (`spring.datasource.*`)。
    *   MP 核心配置 (`mybatis-plus.*`)，特别是 `global-config.db-config.id-type` 和 `configuration.map-underscore-to-camel-case`。
    *   如果需要，配置 `mapper-locations` 和 `type-aliases-package`。
3.  **创建实体类 (Entity)**，并使用 MP 注解 (如 `@TableName`, `@TableId`, `@TableField`)。
4.  **创建 Mapper 接口**，继承 `com.baomidou.mybatisplus.core.mapper.BaseMapper<YourEntity>`，并添加 `@Mapper` 注解。
5.  **(可选) 创建 Service 接口**，继承 `com.baomidou.mybatisplus.extension.service.IService<YourEntity>`。
6.  **(可选) 创建 Service 实现类**，继承 `com.baomidou.mybatisplus.extension.service.impl.ServiceImpl<YourMapper, YourEntity>` 并实现你的 Service 接口。
7.  **在需要的地方注入 Mapper 或 Service 并使用。**

```java
// 实体类示例 (User.java)
package com.example.yourproject.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
import java.io.Serializable;

@Data
@TableName("user_info") // 假设表名是 user_info
public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    @TableId(value = "user_id", type = IdType.ASSIGN_ID) // 主键列名 user_id, 使用雪花算法
    private Long id;
    private String name;
    private Integer age;
    private String email;
}

// Mapper 接口示例 (UserMapper.java)
package com.example.yourproject.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.example.yourproject.entity.User;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface UserMapper extends BaseMapper<User> {
    // 已经拥有了 BaseMapper<User> 中定义的所有通用 CRUD 方法
    // 如果有自定义 SQL, 可以在这里声明方法，然后在 XML 中实现或使用 MyBatis 注解
    // List<User> findByNameLike(@Param("name") String name);
}

// Service 接口示例 (IUserService.java)
package com.example.yourproject.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.example.yourproject.entity.User;

public interface IUserService extends IService<User> {
    // 已经拥有了 IService<User> 中定义的常用 Service 层方法
    // 可以添加自定义的业务方法
    boolean checkUserExists(String name);
}

// Service 实现类示例 (UserServiceImpl.java)
package com.example.yourproject.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.example.yourproject.entity.User;
import com.example.yourproject.mapper.UserMapper;
import com.example.yourproject.service.IUserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {
    // baseMapper 属性由 ServiceImpl 自动注入 (就是 UserMapper)
    // 已经拥有了 ServiceImpl<UserMapper, User> 中封装的 Service 层方法

    @Override
    public boolean checkUserExists(String name) {
        // 使用 LambdaQueryWrapper 进行查询
        return baseMapper.exists(new LambdaQueryWrapper<User>().eq(User::getName, name));
        // 或者使用 this.count(lambdaQueryWrapper) > 0; IService 提供了 count 方法
    }
}

// 在 Controller 或其他地方使用
// @RestController
// public class UserController {
//     @Autowired
//     private IUserService userService;
//     @Autowired
//     private UserMapper userMapper; // 也可以直接注入 Mapper
//
//     @PostMapping("/users")
//     public boolean createUser(@RequestBody User user) {
//         return userService.save(user); // IService 提供的 save 方法
//     }
//
//     @GetMapping("/users/{id}")
//     public User getUser(@PathVariable Long id) {
//         return userMapper.selectById(id); // BaseMapper 提供的 selectById 方法
//     }
// }
```

至此，你就完成了 MyBatis-Plus 在 Spring Boot 项目中的基本集成和上手。

接下来，我们将深入探讨 MP 的核心功能，比如通用 CRUD 的具体方法、强大的条件构造器、各种注解的详细用法以及各种实用插件。