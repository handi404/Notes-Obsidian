讲解 **MyBatis-Plus 代码生成器 (MyBatis-Plus Generator)**。这是一个极其实用的工具，能够根据数据库表结构自动生成项目所需的各层代码，大幅减少重复劳动，提高开发效率，并有助于保持代码风格的一致性。

---

### 4. MyBatis-Plus 代码生成器 (MyBatis-Plus Generator)

MyBatis-Plus Generator (简称 MPG) 是 MP 提供的一个独立的代码生成引擎。它非常灵活，可以通过配置来控制生成的代码内容、风格、模板等。

#### 4.1 依赖引入

要在项目中使用代码生成器，你需要添加以下依赖到你的 `pom.xml` (通常在一个专门的 `generator` 模块或者临时添加到主模块，生成完代码后可以移除或注释掉)。

**对于 Maven 项目 (`pom.xml`):**

```xml
<dependencies>
    <!-- MyBatis-Plus Generator -->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-generator</artifactId>
        <version>3.5.5</version> <!-- 建议与 mybatis-plus-boot-starter 版本保持一致或兼容 -->
    </dependency>

    <!-- 数据库驱动 (根据你的数据库类型选择) -->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope> <!-- 注意 scope，生成时需要，运行时不一定需要这个依赖在主模块 -->
    </dependency>

    <!-- 模板引擎 (根据你选择的模板引擎添加) -->
    <!-- Velocity (默认模板引擎) -->
    <dependency>
        <groupId>org.apache.velocity</groupId>
        <artifactId>velocity-engine-core</artifactId>
        <version>2.3</version> <!-- 或更高兼容版本 -->
    </dependency>
    <!-- Freemarker (可选模板引擎) -->
    <!--
    <dependency>
        <groupId>org.freemarker</groupId>
        <artifactId>freemarker</artifactId>
        <version>2.3.32</version>
    </dependency>
    -->
    <!-- Beetl (可选模板引擎) -->
    <!--
    <dependency>
        <groupId>com.ibeetl</groupId>
        <artifactId>beetl</artifactId>
        <version>3.15.7.RELEASE</version>
    </dependency>
    -->

    <!-- Lombok (如果生成的实体类希望使用 Lombok 注解) -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**关键点：**

*   `mybatis-plus-generator`: 核心代码生成器依赖。
*   **数据库驱动**: 必须添加，因为生成器需要连接数据库读取表结构信息。
*   **模板引擎**: MPG 支持多种模板引擎，默认是 Velocity。如果你想使用 Freemarker 或 Beetl，需要引入相应的依赖，并在配置中指定。
*   **版本**: `mybatis-plus-generator` 的版本最好与你项目中使用的 `mybatis-plus-boot-starter` 版本保持一致或接近，以确保兼容性。

#### 4.2 配置代码生成器

配置代码生成器通常是通过编写一个 Java 类，在该类中实例化并配置 `AutoGenerator` 对象。这个类可以放在 `src/test/java` 目录下，或者一个独立的 `generator` 模块中。

以下是一个典型的配置示例 (使用 Velocity 模板引擎)：

```java
package com.example.yourproject.generator; // 包路径自定义

import com.baomidou.mybatisplus.generator.FastAutoGenerator;
import com.baomidou.mybatisplus.generator.config.*;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import com.baomidou.mybatisplus.generator.engine.VelocityTemplateEngine; // 或 FreemarkerTemplateEngine 等

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class CodeGenerator {

    public static void main(String[] args) {
        // 1. 数据源配置
        String jdbcUrl = "jdbc:mysql://localhost:3306/your_database_name?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai";
        String username = "your_username";
        String password = "your_password";

        FastAutoGenerator.create(jdbcUrl, username, password)
                // 2. 全局配置
                .globalConfig(builder -> {
                    builder.author("YourName") // 设置作者
                            .enableSwagger() // 开启 swagger 模式 (可选)
                            .outputDir(System.getProperty("user.dir") + "/src/main/java") // 指定输出目录
                            .commentDate("yyyy-MM-dd") // 注释日期格式
                            .dateType(DateType.TIME_PACK); // 时间类型策略 DateType.ONLY_DATE (java.util.Date) / TIME_PACK (java.time.*) / SQL_PACK (java.sql.*)
                            // .disableOpenDir(); // 禁止生成完成后打开输出目录
                })
                // 3. 包配置
                .packageConfig(builder -> {
                    builder.parent("com.example.yourproject") // 设置父包名
                            .moduleName("module_name") // 设置父包模块名 (可选，会在父包下再创建一级)
                            .entity("entity") // Entity 包名
                            .mapper("mapper") // Mapper 包名
                            .service("service") // Service 包名
                            .serviceImpl("service.impl") // Service Impl 包名
                            .controller("controller") // Controller 包名 (可选)
                            .xml("mapper.xml"); // Mapper XML 文件路径 (相对于 resources 目录)
                            // .pathInfo(Collections.singletonMap(OutputFile.xml, System.getProperty("user.dir") + "/src/main/resources/mapper/module_name")); // 自定义 Mapper XML 输出路径
                })
                // 4. 策略配置
                .strategyConfig(builder -> {
                    builder.addInclude("user_info", "product_orders") // 设置需要生成的表名 (可多个)
                            // .addExclude("flyway_schema_history") // 设置需要排除的表名 (可多个)
                            // .addTablePrefix("t_", "c_") // 设置过滤表前缀 (生成实体时会去掉这些前缀)
                            // .addTableSuffix("_db") // 设置过滤表后缀
                            // .addFieldPrefix("f_", "field_") // 设置过滤字段前缀
                            // .addFieldSuffix("_col") // 设置过滤字段后缀

                            // Entity 策略配置
                            .entityBuilder()
                            .enableLombok() // 开启 Lombok 模型
                            // .disableSerialVersionUID() // (可选) 禁止生成 serialVersionUID (如果开启了Lombok @Data，通常Lombok会处理)
                            .enableTableFieldAnnotation() // (可选) 开启生成实体时生成字段注解 (标记 @TableField)
                            .naming(NamingStrategy.underline_to_camel) // 数据库表名下划线转驼峰命名
                            .columnNaming(NamingStrategy.underline_to_camel) // 数据库表字段下划线转驼峰命名
                            // .addSuperEntityClass(BaseEntity.class) // (可选) 设置父类
                            // .addSuperEntityColumns("id", "create_time", "update_time") // (可选) 父类公共字段
                            .idType(com.baomidou.mybatisplus.annotation.IdType.ASSIGN_ID) // 全局主键策略
                            // .formatFileName("%sEntity") // (可选) 自定义实体类文件名格式，%s 会替换为表名转换后的实体名

                            // Mapper 策略配置
                            .mapperBuilder()
                            .superClass(com.baomidou.mybatisplus.core.mapper.BaseMapper.class) // 设置父类
                            .enableMapperAnnotation() // 开启 @Mapper 注解
                            .enableBaseResultMap() // (可选) 启用 BaseResultMap 生成
                            .enableBaseColumnList() // (可选) 启用 BaseColumnList 生成
                            .formatMapperFileName("%sMapper") // Mapper 文件名格式
                            .formatXmlFileName("%sMapper") // XML 文件名格式

                            // Service 策略配置
                            .serviceBuilder()
                            .superServiceClass(com.baomidou.mybatisplus.extension.service.IService.class) // Service 接口父类
                            .superServiceImplClass(com.baomidou.mybatisplus.extension.service.impl.ServiceImpl.class) // Service 实现类父类
                            .formatServiceFileName("I%sService") // Service 接口文件名格式 (例如 IUserService)
                            .formatServiceImplFileName("%sServiceImpl") // Service 实现类文件名格式

                            // Controller 策略配置 (可选)
                            .controllerBuilder()
                            .enableRestStyle(); // 开启生成 @RestController 控制器
                            // .formatFileName("%sController");
                })
                // 5. 模板引擎配置 (可选，默认 Velocity)
                // .templateEngine(new FreemarkerTemplateEngine()) // 使用 Freemarker 引擎
                .templateEngine(new VelocityTemplateEngine()) // 显式指定 Velocity
                // 6. 注入自定义配置 (可选，用于在模板中通过 cfg 对象访问)
                /*
                .injectionConfig(builder -> {
                    builder.beforeOutputFile((tableInfo, objectMap) -> {
                        System.out.println("tableInfo: " + tableInfo.getEntityName() + " objectMap: " + objectMap.size());
                    })
                    .customMap(Collections.singletonMap("my_config_key", "my_config_value"))
                    .customFile(Collections.singletonMap("DTO.java", "/templates/dto.java.vm")) // 自定义输出文件
                    .build();
                })
                */
                // 7. 执行生成
                .execute();

        System.out.println("代码生成完毕！");
    }

    // (可选) 辅助方法：获取表名列表 (如果不想写死)
    private static List<String> getTables(String tables) {
        return Arrays.asList(tables.split(","));
    }
}
```

**配置项详解：**

*   **`FastAutoGenerator.create(url, username, password)`**: 创建生成器实例并传入数据库连接信息。
*   **`.globalConfig(builder -> {})` (全局配置)**:
    *   `author(String author)`: 生成的类注释中的作者名。
    *   `enableSwagger()`: 如果实体类属性需要 Swagger 注解 (`@ApiModelProperty`)，则开启。
    *   `outputDir(String outputDir)`: **非常重要**。所有生成文件的根输出目录。通常是 `System.getProperty("user.dir") + "/src/main/java"`。
    *   `commentDate(String pattern)`: 注释中日期的格式。
    *   `dateType(DateType dateType)`: 数据库中日期时间类型映射到 Java 中的类型策略。
        *   `DateType.ONLY_DATE`: `java.util.Date`
        *   `DateType.SQL_PACK`: `java.sql.Timestamp` 或 `java.sql.Date`
        *   `DateType.TIME_PACK`: `java.time.LocalDateTime`, `java.time.LocalDate`, `java.time.LocalTime` (**推荐，Java 8+**)
*   **`.packageConfig(builder -> {})` (包配置)**:
    *   `parent(String parent)`: 所有生成类的父包名。
    *   `moduleName(String moduleName)`: (可选) 模块名，会在 `parent` 包下再创建一级目录。
    *   `entity(String entity)`: Entity (POJO) 类的包名 (相对于 `parent` 或 `parent.moduleName`)。
    *   `mapper(String mapper)`: Mapper 接口的包名。
    *   `service(String service)`: Service 接口的包名。
    *   `serviceImpl(String serviceImpl)`: Service 实现类的包名。
    *   `controller(String controller)`: Controller 类的包名。
    *   `xml(String xml)`: Mapper XML 文件的路径。**注意**: 这个路径是相对于 `resources` 目录的，而不是 Java 代码的输出目录。例如，`mapper.xml` 表示 XML 文件会生成在 `src/main/resources/mapper/xml/` 目录下（如果 `moduleName` 也配置了，可能会是 `src/main/resources/mapper/module_name/xml/`，具体路径取决于组合）。
    *   `pathInfo(Map<OutputFile, String> pathInfo)`: 可以更精细地控制每种类型文件的输出路径，覆盖默认规则。`OutputFile` 是一个枚举，包含 `entity`, `mapper`, `mapperXml`, `service`, `serviceImpl`, `controller` 等。
*   **`.strategyConfig(builder -> {})` (策略配置)**: 这是最核心的配置部分。
    *   **表过滤**:
        *   `addInclude(String... include)`: 指定要生成代码的表名。
        *   `addExclude(String... exclude)`: 指定要排除的表名。
        *   `addTablePrefix(String... tablePrefix)`: 生成实体类名时，会自动移除这些表前缀。例如，表名 `t_user`，配置 `addTablePrefix("t_")`，则实体类名为 `User`。
        *   `addTableSuffix(String... tableSuffix)`: 类似地移除表后缀。
        *   `addFieldPrefix(String... fieldPrefix)`: 生成实体属性名时，移除字段前缀。
        *   `addFieldSuffix(String... fieldSuffix)`: 移除字段后缀。
    *   **Entity 策略 (`.entityBuilder()`)**:
        *   `enableLombok()`: 生成的实体类会添加 Lombok 注解 (如 `@Data`, `@TableName`, `@TableId` 等)，从而省略 getter/setter 等样板代码。
        *   `enableTableFieldAnnotation()`: 在实体字段上生成 `@TableField` 注解（即使字段名和属性名能通过驼峰转换匹配）。
        *   `naming(NamingStrategy namingStrategy)`: 数据库表名到实体类名的转换策略。
            *   `NamingStrategy.underline_to_camel`: 下划线转驼峰 (常用)。
            *   `NamingStrategy.no_change`: 不改变。
        *   `columnNaming(NamingStrategy namingStrategy)`: 数据库列名到实体属性名的转换策略。
        *   `superClass(Class<?> superClass)`: 指定实体类的父类。
        *   `addSuperEntityColumns(String... superEntityColumns)`: 如果设置了父类，这里指定父类中已经包含的、来自数据库表的公共字段名 (驼峰命名)。生成子实体时会忽略这些字段。
        *   `idType(IdType idType)`: 指定该批次生成实体的主键策略，会覆盖全局配置。
        *   `formatFileName(String format)`: 自定义实体类文件名，`%s` 代表表名按规则转换后的名称。
    *   **Mapper 策略 (`.mapperBuilder()`)**:
        *   `superClass(Class<?> superClass)`: 指定 Mapper 接口的父接口，通常是 `com.baomidou.mybatisplus.core.mapper.BaseMapper.class`。
        *   `enableMapperAnnotation()`: 在生成的 Mapper 接口上添加 `@Mapper` 注解。
        *   `enableBaseResultMap()`: 在生成的 Mapper XML 文件中，自动创建一个基础的 `ResultMap` (包含所有字段的映射)。
        *   `enableBaseColumnList()`: 在 XML 中生成一个包含所有列名的 `<sql>` 片段。
        *   `formatMapperFileName(String format)`: Mapper 接口文件名格式。
        *   `formatXmlFileName(String format)`: Mapper XML 文件名格式。
    *   **Service 策略 (`.serviceBuilder()`)**:
        *   `superServiceClass(Class<?> superClass)`: Service 接口的父接口，通常是 `com.baomidou.mybatisplus.extension.service.IService.class`。
        *   `superServiceImplClass(Class<?> superClass)`: Service 实现类的父类，通常是 `com.baomidou.mybatisplus.extension.service.impl.ServiceImpl.class`。
        *   `formatServiceFileName(String format)`: Service 接口文件名格式 (如 `I%sService` -> `IUserService`)。
        *   `formatServiceImplFileName(String format)`: Service 实现类文件名格式。
    *   **Controller 策略 (`.controllerBuilder()`)**: (如果需要生成 Controller)
        *   `enableRestStyle()`: 生成的 Controller 会使用 `@RestController` 注解。
*   **`.templateEngine(ITemplateEngine templateEngine)`**:
    *   指定使用的模板引擎。可以是 `new VelocityTemplateEngine()` (默认), `new FreemarkerTemplateEngine()`, `new BeetlTemplateEngine()`。
*   **`.injectionConfig(builder -> {})` (注入配置)**:
    *   允许你在代码生成过程中注入自定义的配置数据 (`customMap`)，这些数据可以在模板文件中通过 `cfg.key` 的方式访问。
    *   可以注册 `beforeOutputFile` 回调，在文件输出前进行一些处理。
    *   `customFile`: 可以指定自定义的模板文件和输出文件名，用于生成额外的、非标准的文件 (如 DTO, VO)。
*   **`.execute()`**: 执行代码生成过程。

#### 4.3 生成 Entity, Mapper, Service, Controller

运行配置好的 `CodeGenerator` 的 `main` 方法后，MPG 会连接数据库，读取指定表的元数据 (表名、列名、类型、注释等)，然后根据策略配置和模板文件，在指定的输出目录下生成相应的 Java 类和 XML 文件。

**生成的文件通常包括：**

*   **Entity 类**: 包含属性、getter/setter (或 Lombok 注解)、以及 MP 的实体注解。
*   **Mapper 接口**: 继承 `BaseMapper`，带有 `@Mapper` 注解。
*   **Mapper XML 文件**: (如果配置生成) 可能包含 `BaseResultMap` 和 `BaseColumnList`。自定义的 SQL 之后可以添加到这里。
*   **Service 接口**: 继承 `IService`。
*   **Service 实现类**: 继承 `ServiceImpl`，实现对应的 Service 接口，并注入 Mapper。
*   **Controller 类**: (如果配置生成) 包含基本的 RESTful API 框架，注入 Service。

**首次生成与后续生成：**

*   **首次生成**: MPG 会创建所有指定的文件。
*   **后续生成 (文件已存在)**:
    *   默认情况下，如果目标文件已存在，MPG **不会覆盖**它，以防止你手动修改的代码丢失。它会在控制台打印提示。
    *   可以通过全局配置 `globalConfig(builder -> builder.fileOverride())` 来强制覆盖已存在的文件。**使用此选项务必小心！**
    *   通常的做法是：
        1.  首次生成全部代码。
        2.  对于 Entity、Mapper 接口、Service 接口，如果表结构发生较大变化，可以考虑删除后重新生成 (注意备份自定义内容)。
        3.  对于 Service 实现类、Controller 类、Mapper XML 中的自定义 SQL，这些是业务逻辑的主要承载者，**不应该被自动生成覆盖**。如果需要根据新表结构调整，通常是手动修改。
        4.  一种策略是，将 Service 实现类和 Controller 等包含大量业务逻辑的类，放到生成器不直接覆盖的包路径下，或者在生成后手动移动和合并。

#### 4.4 自定义模板与策略

MPG 的强大之处在于其高度的可定制性。你可以修改内置的模板，或者提供全新的模板来生成完全符合你项目规范的代码。

**模板文件：**

*   MPG 内置了 Velocity 模板 (`.vm` 文件) 用于生成各种代码。
*   这些模板文件位于 `mybatis-plus-generator.jar` 包的 `templates` 目录下 (如 `entity.java.vm`, `mapper.java.vm`, `service.java.vm`, `controller.java.vm`, `mapper.xml.vm` 等)。
*   **如何自定义模板**:
    1.  从 JAR 包中复制出你想要修改的模板文件。
    2.  将它们放到你项目的 `src/main/resources/templates` 目录下 (或者通过 `.templateConfig()` 指定其他自定义模板路径)。
    3.  修改这些 `.vm` (或 `.ftl` for Freemarker) 文件。模板中可以使用预定义的变量 (如 `table` 对象包含表信息，`entity` 对象包含实体信息，`cfg` 对象包含注入的自定义配置等) 来动态生成内容。
    4.  在代码生成器配置中，通过 `.templateConfig(builder -> {})` 来指定自定义模板的路径或禁用某些默认模板的生成。
        ```java
        // .templateConfig(builder -> {
        //     builder.entity("/templates/my_entity.java.vm") // 使用自定义的 entity 模板
        //            .service("/templates/my_service.java.ftl") // 使用自定义的 service 模板 (假设用 Freemarker)
        //            .disable(TemplateType.CONTROLLER); // 禁止生成 Controller 文件
        // })
        ```
        `TemplateType` 是一个枚举，包含了 `ENTITY`, `MAPPER`, `XML`, `SERVICE`, `SERVICE_IMPL`, `CONTROLLER`。

**自定义策略与扩展点：**

*   **`INameConvert`**: 用于自定义表名、字段名到类名、属性名的转换逻辑。
*   **`IKeyGenerator`**: 如果需要自定义主键生成逻辑 (除了 MP 内置的 `IdType`)。
*   **`ISqlInjector`**: 可以自定义注入的通用 SQL 方法 (高级)。
*   **`InjectionConfig`**: 前面提到的注入自定义配置和文件。
*   **自定义 `StrategyConfig` 中的 Builder**: `strategyConfig` 中的各个 `xxxBuilder()` 返回的对象，其本身也提供了很多配置方法，可以进行更细致的控制。
*   **继承并扩展 `FastAutoGenerator`**: 对于非常复杂的定制需求，可以考虑继承 `FastAutoGenerator` 或其内部组件，并重写相关逻辑。

**使用建议：**

*   **从小处开始**: 先使用默认配置和模板生成一次，了解其输出。
*   **逐步定制**: 根据需要，逐步修改配置项，或者复制和修改模板文件。
*   **保持简洁**: 不要过度设计代码生成逻辑，目标是提高效率，而不是制造另一个复杂的系统。
*   **版本控制**: 将代码生成器的配置文件和自定义模板纳入版本控制，方便团队协作和追踪变更。
*   **不要期望一次完美**: 代码生成器是辅助工具，生成的代码通常是一个良好的起点，后续可能仍需人工调整和完善业务逻辑。

---

MyBatis-Plus Generator 是一个非常强大的生产力工具。熟练掌握其配置和定制能力，可以极大地加速项目的初期搭建和后续迭代。