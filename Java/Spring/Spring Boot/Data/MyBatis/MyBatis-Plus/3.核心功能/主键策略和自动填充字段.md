深入 MyBatis-Plus 的核心功能，重点关注主键策略、自动填充、以及各种实用插件。

---

#### 3.4 主键策略 (IdType)

MyBatis-Plus 提供了灵活的主键生成策略，可以通过全局配置和实体类注解进行设置。

**IdType 枚举常量：**

*   `AUTO`: **数据库ID自增**。依赖数据库的自增主键功能 (如 MySQL 的 `AUTO_INCREMENT`)。实体类主键字段类型通常为数值型。
*   `NONE`: **无状态**。表示不使用任何内置策略，主键值由用户在插入前自行设置或依赖数据库触发器等。
*   `INPUT`: **用户输入**。主键值由用户在插入前显式设置。如果未设置，可能会报错或插入失败 (取决于数据库约束)。
*   `ASSIGN_ID`: **MP 分配ID (雪花算法)**。MP 内部默认使用雪花算法 (Snowflake) 生成一个全局唯一的长整型 ID。如果主键字段是 `String` 类型，则会生成一个不含 `-` 的 UUID 字符串。**这是分布式系统中最常用的主键策略之一**。
*   `ASSIGN_UUID`: **MP 分配UUID**。生成一个标准的 UUID 字符串 (含 `-`)。主键字段类型应为 `String`。

**配置方式：**

1.  **全局配置 (推荐设置默认策略)**:
    在 `application.yml` (或 `application.properties`) 中配置：
    ```yaml
    mybatis-plus:
      global-config:
        db-config:
          id-type: assign_id # 设置全局默认主键策略为雪花算法
          # (可选) 如果使用 ASSIGN_ID 且主键为 String，可以通过 identifier-generator 指定
          # identifier-generator: com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator (默认)
          # 或者自定义的 com.baomidou.mybatisplus.core.incrementer.IdentifierGenerator 实现
    ```

2.  **局部注解配置 (覆盖全局配置)**:
    在实体类的主键字段上使用 `@TableId` 注解的 `type` 属性：
    ```java
    import com.baomidou.mybatisplus.annotation.IdType;
    import com.baomidou.mybatisplus.annotation.TableId;

    public class User {
        @TableId(type = IdType.AUTO) // 此实体类使用数据库自增，覆盖全局的 ASSIGN_ID
        private Long id;
        // ...
    }

    public class Product {
        @TableId(type = IdType.ASSIGN_UUID) // 此实体类使用 UUID
        private String productId;
        // ...
    }

    public class Order {
        // 如果全局配置了 ASSIGN_ID，这里不指定 type，则默认使用全局配置
        @TableId
        private Long orderId;
        // ...
    }
    ```

**雪花算法 (Snowflake) 详解与配置：**

雪花算法是 Twitter 开源的一种分布式 ID 生成算法，它可以生成趋势递增的、全局唯一的 64 位长整型 ID。其结构通常如下：

*   **1 位符号位**: 固定为 0，表示正数。
*   **41 位时间戳 (毫秒级)**: 从一个固定的起始时间点开始计算的时间差，大约可以使用 69 年。
*   **10 位数据中心 ID + 机器 ID (DataCenterId + WorkerId)**:
    *   `dataCenterId` (默认 5 位): 0-31。
    *   `workerId` (默认 5 位): 0-31。
    *   这两个 ID 用于区分不同的数据中心和机器，确保不同节点生成的 ID 不会冲突。**在分布式部署时，必须确保每个节点的 `(dataCenterId, workerId)` 组合是唯一的。**
*   **12 位序列号**: 在同一毫秒内，如果同一节点需要生成多个 ID，则序列号递增。每毫秒可以生成 4096 个 ID。

**MP 中雪花算法的配置：**

*   **默认行为**: 如果你将 `id-type` 设置为 `ASSIGN_ID`，MP 会使用内置的 `DefaultIdentifierGenerator`。它会尝试通过获取机器的 MAC 地址等信息来生成一个相对唯一的 `workerId` 和 `dataCenterId`，但这并非绝对可靠，尤其是在虚拟化或容器环境中。
*   **自定义 `workerId` 和 `dataCenterId` (推荐用于生产环境)**:
    为了保证在分布式环境中的唯一性，强烈建议手动配置 `workerId` 和 `dataCenterId`。可以通过实现 `com.baomidou.mybatisplus.core.incrementer.IdentifierGenerator` 接口并注册为 Spring Bean 来实现。

    **方式一：通过 Spring Boot 属性配置 (MP 3.4.0+ 支持)**
    如果你的 `mybatis-plus-boot-starter` 版本较新，可以直接在 `application.yml` 中配置：
    ```yaml
    mybatis-plus:
      global-config:
        db-config:
          id-type: assign_id
          # (可选) 雪花算法的起始时间戳 (默认为 2016-11-01)
          # epoch: 2020-01-01T00:00:00.000Z
      # (可选) 雪花算法的 workerId 和 dataCenterId, 需要 mp-spring-boot-starter 3.4.0+
      # 并且需要你的主键生成器是 DefaultIdentifierGenerator 或其子类能读取这些属性
      # 这部分配置实际上是传递给 DefaultIdentifierGenerator 的。
      # 但更稳妥的方式是自定义 IdentifierGenerator Bean。
      # snowflake:
      #   worker-id: 1 # (0-31)
      #   datacenter-id: 1 # (0-31)
    ```
    **注意**: 直接通过 `mybatis-plus.snowflake.worker-id` 配置的方式，其生效依赖于 MP 内部的 `DefaultIdentifierGenerator` 是否能从 Spring Environment 中获取这些值。在某些版本或特定场景下可能不直接生效。

    **方式二：自定义 `IdentifierGenerator` Bean (更可靠和灵活的方式)**
    ```java
    package com.example.yourproject.config;

    import com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator;
    import com.baomidou.mybatisplus.core.incrementer.IdentifierGenerator;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    @Configuration
    public class MybatisPlusIdConfig {

        // 从配置文件或环境变量中获取 workerId 和 dataCenterId
        // 确保每个部署实例的值是唯一的
        @Value("${myapp.snowflake.worker-id:0}") // 提供默认值
        private long workerId;

        @Value("${myapp.snowflake.datacenter-id:0}") // 提供默认值
        private long datacenterId;

        @Bean
        public IdentifierGenerator identifierGenerator() {
            // 你可以传入自定义的 workerId 和 datacenterId
            // DefaultIdentifierGenerator 构造函数: DefaultIdentifierGenerator(long workerId, long datacenterId)
            // 确保 workerId 和 datacenterId 在允许的范围内 (通常是0-31)
            System.out.println("Initializing Snowflake IdentifierGenerator with workerId: " + workerId + ", datacenterId: " + datacenterId);
            return new DefaultIdentifierGenerator(workerId, datacenterId);
        }
    }
    ```
    在 `application.yml` 中配置：
    ```yaml
    myapp:
      snowflake:
        worker-id: 1  # 根据你的部署实例进行分配
        datacenter-id: 1 # 根据你的数据中心或集群进行分配
    ```
    MP 会自动检测到这个 `IdentifierGenerator` Bean 并使用它。

**使用 `INPUT` 类型配合数据库序列 (如 Oracle)：**
如果数据库使用序列生成主键 (如 Oracle)，通常会将主键类型设为 `IdType.INPUT`，然后在插入前手动查询序列并将值赋给实体的主键属性，或者在 Mapper XML 中使用 `<selectKey>`。MP 本身不直接管理数据库序列的获取。

---

#### 3.5 自动填充字段 (MetaObjectHandler)

在很多业务场景中，一些字段需要在插入或更新时自动填充，例如 `create_time`, `update_time`, `create_by`, `update_by` 等。MP 提供了 `MetaObjectHandler` 机制来优雅地实现这一功能。

**步骤：**

1.  **实现 `com.baomidou.mybatisplus.core.handlers.MetaObjectHandler` 接口：**
    你需要创建一个类实现该接口，并重写 `insertFill` 和 `updateFill` 方法。
    ```java
    package com.example.yourproject.handler;

    import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
    import lombok.extern.slf4j.Slf4j;
    import org.apache.ibatis.reflection.MetaObject;
    import org.springframework.stereotype.Component; // 注册为 Spring Bean

    import java.time.LocalDateTime;

    @Slf4j
    @Component // 必须将 Handler 注册为 Spring Bean，MP 才会自动使用它
    public class MyMetaObjectHandler implements MetaObjectHandler {

        // 插入操作时的填充策略
        @Override
        public void insertFill(MetaObject metaObject) {
            log.info("Start insert fill ....");
            // metaObject: 元数据对象，可以获取到原始实体对象及其属性
            // fieldName: 实体类中的属性名 (不是数据库列名)
            // fieldVal: 要填充的值
            // metaObject: 原始的 metaObject

            // 示例：填充创建时间 (属性名为 createTime, 类型为 LocalDateTime)
            // this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0,推荐使用
            // 或者使用 older version
            this.setFieldValByName("createTime", LocalDateTime.now(), metaObject);

            // 示例：填充创建者 (假设有一个 getCurrentUserId() 方法获取当前用户ID)
            // Long currentUserId = getCurrentUserId();
            // this.setFieldValByName("createBy", currentUserId, metaObject);

            // 也可以判断属性是否存在，避免空指针
            if (metaObject.hasSetter("updateTime")) {
                this.setFieldValByName("updateTime", LocalDateTime.now(), metaObject);
            }
            if (metaObject.hasSetter("version")) { // 比如为乐观锁字段设置初始版本号
                 this.setFieldValByName("version", 1, metaObject);
            }
        }

        // 更新操作时的填充策略
        @Override
        public void updateFill(MetaObject metaObject) {
            log.info("Start update fill ....");
            // this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0,推荐使用
            // 或者
            this.setFieldValByName("updateTime", LocalDateTime.now(), metaObject);

            // 示例：填充更新者
            // Long currentUserId = getCurrentUserId();
            // this.setFieldValByName("updateBy", currentUserId, metaObject);
        }

        // 辅助方法，获取当前用户ID (需要自己实现)
        // private Long getCurrentUserId() {
        //     // 例如从 Spring Security 上下文获取
        //     // Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        //     // if (authentication != null && authentication.getPrincipal() instanceof UserDetails) {
        //     //     UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        //     //     // 假设 UserDetails 实现类中有 getId() 方法
        //     //     return ((YourUserDetailsImpl) userDetails).getId();
        //     // }
        //     return null; // 或者一个默认值
        // }
    }
    ```
    **注意**：
    *   `strictInsertFill` / `strictUpdateFill` (MP 3.3.0+) 方法提供了更严格的类型检查和属性存在检查，推荐使用。它们有多个重载版本。
    *   `setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject)` 是较早版本的方法，依然可用。
    *   `getFieldValByName(String fieldName, MetaObject metaObject)` 可以获取字段的当前值。

2.  **在实体类的相应字段上使用 `@TableField(fill = FieldFill.XXX)` 注解：**
    `FieldFill` 是一个枚举，常用的值有：
    *   `DEFAULT`: 默认不处理。
    *   `INSERT`: 只在插入时填充。
    *   `UPDATE`: 只在更新时填充。
    *   `INSERT_UPDATE`: 插入和更新时都填充。

    ```java
    import com.baomidou.mybatisplus.annotation.FieldFill;
    import com.baomidou.mybatisplus.annotation.TableField;
    import java.time.LocalDateTime;

    public class AuditEntity {
        @TableField(value = "create_time", fill = FieldFill.INSERT)
        private LocalDateTime createTime;

        @TableField(value = "update_time", fill = FieldFill.INSERT_UPDATE)
        private LocalDateTime updateTime;

        @TableField(value = "create_by", fill = FieldFill.INSERT)
        private Long createBy;

        @TableField(value = "update_by", fill = FieldFill.INSERT_UPDATE)
        private Long updateBy;
    }
    ```

3.  **确保 `MetaObjectHandler` 实现类被 Spring 容器管理** (通常通过 `@Component` 注解)。MP 会自动查找并使用容器中的 `MetaObjectHandler` Bean。

**工作流程：**
当执行 `insert` 或 `update` 操作时，MP 会在实际执行 SQL 之前，调用你注册的 `MetaObjectHandler` 的相应 `fill` 方法。`Handler` 根据 `@TableField` 注解的 `fill` 策略，为标记的字段设置值。

---
