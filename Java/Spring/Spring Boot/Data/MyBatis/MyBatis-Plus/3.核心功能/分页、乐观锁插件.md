继续深入 MyBatis-Plus 的插件机制，这些插件极大地增强了 MyBatis 的功能。

---

#### 3.6 分页插件 (PaginationInnerInterceptor)

MyBatis-Plus 提供了一个强大的分页插件，可以方便地实现物理分页，对业务代码侵入小。

**配置与使用：**

1.  **添加插件到 `MybatisPlusInterceptor`**:
    MP 3.4.0 版本之后，推荐使用 `MybatisPlusInterceptor` 来统一管理所有内部插件 (`InnerInterceptor`)。

    ```java
    package com.example.yourproject.config;

    import com.baomidou.mybatisplus.annotation.DbType;
    import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
    import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    @Configuration
    public class MybatisPlusPluginConfig {

        @Bean
        public MybatisPlusInterceptor mybatisPlusInterceptor() {
            MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();

            // 1. 添加分页插件
            PaginationInnerInterceptor paginationInterceptor = new PaginationInnerInterceptor();

            // (可选) 设置请求的页面大于最大页后操作，true调回到首页，false继续请求，默认false
            // paginationInterceptor.setOverflow(false);
            // (可选) 设置最大单页限制数量，默认 500 条，-1 不受限制
            // paginationInterceptor.setMaxLimit(500L);
            // (可选) 设置数据库类型 (如果 MP 无法自动识别，或者你想强制指定)
            paginationInterceptor.setDbType(DbType.MYSQL); // 例如 MySQL

            interceptor.addInnerInterceptor(paginationInterceptor);

            // 还可以添加其他插件，如下面的乐观锁插件等
            // interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());

            return interceptor;
        }
    }
    ```
    *   **`DbType`**: 务必正确设置你的数据库类型，分页插件会根据不同的数据库类型生成不同的分页 SQL。MP 会尝试自动识别，但显式指定更保险。常用的有 `MYSQL`, `ORACLE`, `POSTGRE_SQL`, `SQL_SERVER`, `MARIADB`, `DB2`, `H2`, `SQLITE` 等。
    *   `setOverflow(boolean overflow)`: 当请求的页码超出总页数时：
        *   `true` (溢出处理): 会查询第一页的数据 (或最后一页，取决于具体实现和版本)。
        *   `false` (默认): 继续请求，通常会返回空列表。
    *   `setMaxLimit(Long maxLimit)`: 设置单页查询的最大记录数，防止一次查询过多数据。默认是 500。设置为 `-1` 表示不限制。

2.  **在 Service 或 Mapper 方法中使用**:
    分页插件的使用非常简单，通常是在调用 Mapper 的查询方法之前，创建一个分页对象。

    **`IPage<T>` 和 `Page<T>` 对象:**
    *   `com.baomidou.mybatisplus.core.metadata.IPage<T>`: 分页参数和结果的接口。
    *   `com.baomidou.mybatisplus.extension.plugins.pagination.Page<T>`: `IPage` 的标准实现类。

    **使用示例 (在 Service 层):**
    ```java
    import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
    import com.baomidou.mybatisplus.core.metadata.IPage;
    import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
    import com.example.yourproject.entity.User;
    import com.example.yourproject.mapper.UserMapper;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    @Service
    public class UserServiceImpl { // 假设继承了 ServiceImpl<UserMapper, User>

        @Autowired
        private UserMapper userMapper; // 或者通过 baseMapper 访问

        public IPage<User> findUsersByPage(int pageNum, int pageSize, String nameKeyword) {
            // 1. 创建 Page 对象，传入当前页码 (pageNum) 和每页数量 (pageSize)
            // Page 构造函数: Page(long current, long size)
            // Page(long current, long size, boolean searchCount) // searchCount: 是否进行 count 查询，默认 true
            // Page(long current, long size, long total) // 如果已知总数，可以传入
            Page<User> pageRequest = new Page<>(pageNum, pageSize);

            // (可选) 构建查询条件
            LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
            if (nameKeyword != null && !nameKeyword.isEmpty()) {
                queryWrapper.like(User::getName, nameKeyword);
            }
            queryWrapper.orderByDesc(User::getCreateTime);

            // 2. 调用 Mapper 的 selectPage 方法 (或 IService 提供的 page 方法)
            // 这个 selectPage 方法是 BaseMapper 提供的，它会自动被分页插件拦截
            IPage<User> userPageResult = userMapper.selectPage(pageRequest, queryWrapper);

            // userPageResult 对象现在包含了分页信息和当前页的数据列表
            System.out.println("总记录数: " + userPageResult.getTotal());
            System.out.println("总页数: " + userPageResult.getPages());
            System.out.println("当前页数据: " + userPageResult.getRecords());
            System.out.println("当前页码: " + userPageResult.getCurrent());
            System.out.println("每页数量: " + userPageResult.getSize());

            return userPageResult;
        }

        // 使用 IService 提供的 page 方法更简洁
        // public IPage<User> findUsersByPageWithIService(int pageNum, int pageSize, String nameKeyword) {
        //     Page<User> pageRequest = new Page<>(pageNum, pageSize);
        //     LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
        //     if (nameKeyword != null && !nameKeyword.isEmpty()) {
        //         queryWrapper.like(User::getName, nameKeyword);
        //     }
        //     return this.page(pageRequest, queryWrapper); // this 指向 ServiceImpl
        // }
    }
    ```
    **关键点:**
    *   Mapper 的 `selectPage` 方法的**第一个参数必须是 `IPage` 类型**，分页插件会识别这个参数并进行拦截处理。
    *   插件会自动执行两条 SQL：一条是查询总记录数的 `COUNT(*)` SQL (除非 `Page` 对象设置了 `searchCount=false` 或者总数已传入)，另一条是带有分页条件 (如 `LIMIT`) 的数据查询 SQL。
    *   `IPage` 返回对象包含了丰富的分页信息，可以直接返回给前端。

    **自定义 XML 中的分页查询：**
    如果你的分页查询 SQL 是在 XML 中自定义的，分页插件**默认也能生效**，只要你的 Mapper 方法的第一个参数是 `IPage` 类型。
    ```xml
    <!-- UserMapper.xml -->
    <select id="findActiveUsersWithPagination" resultType="com.example.yourproject.entity.User">
        SELECT * FROM user_info
        <where>
            status = 'ACTIVE'
            <if test="ew != null and ew.sqlSegment != null and ew.sqlSegment != ''">
                AND ${ew.sqlSegment}
            </if>
        </where>
        <!-- 不需要在这里写 LIMIT，分页插件会自动添加 -->
    </select>
    ```
    ```java
    // UserMapper.java
    public interface UserMapper extends BaseMapper<User> {
        IPage<User> findActiveUsersWithPagination(IPage<User> page, @Param(Constants.WRAPPER) Wrapper<User> queryWrapper);
    }
    ```

---

#### 3.7 乐观锁插件 (OptimisticLockerInnerInterceptor)

乐观锁是一种在并发环境下控制数据一致性的策略。它假设数据冲突的概率较低，在更新数据时不加锁，而是在提交更新时检查数据在此期间是否被其他事务修改过。通常通过版本号 (version) 字段实现。

**配置与使用：**

1.  **在实体类中添加版本号字段并使用 `@Version` 注解：**
    ```java
    import com.baomidou.mybatisplus.annotation.Version;
    import java.time.LocalDateTime;

    public class Product {
        @TableId
        private Long id;
        private String name;
        private Integer stock;

        @Version // 标记这是版本号字段
        private Integer version; // 类型可以是 Integer, Long, Date, Timestamp, LocalDateTime

        // (可选) 如果希望在插入时自动填充初始版本号 (如 1)
        // @TableField(fill = FieldFill.INSERT)
        // private Integer version;
    }
    ```
    *   版本号字段的初始值通常是 0 或 1。
    *   当更新时，MP 会在 `WHERE` 条件中带上 `AND version = #{oldVersion}`，并在 `SET` 子句中 `SET version = version + 1`。

2.  **添加 `OptimisticLockerInnerInterceptor` 插件到 `MybatisPlusInterceptor`**:
    ```java
    // 在 MybatisPlusPluginConfig.java 中的 mybatisPlusInterceptor() 方法内添加
    // ...
    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
    // ...
    ```

3.  **使用 `updateById` 或 `update` 方法进行更新：**
    ```java
    @Service
    public class ProductService extends ServiceImpl<ProductMapper, Product> {

        public boolean decreaseStock(Long productId, int quantityToDecrease) {
            // 1. 先查询出商品信息，获取当前版本号
            Product product = this.getById(productId); // 或者 baseMapper.selectById(productId)
            if (product == null) {
                throw new RuntimeException("商品不存在");
            }
            if (product.getStock() < quantityToDecrease) {
                throw new RuntimeException("库存不足");
            }

            // 2. 修改库存
            product.setStock(product.getStock() - quantityToDecrease);
            // product.setVersion(product.getVersion()); // 版本号由插件自动处理，无需手动设置新版本号

            // 3. 执行更新 (updateById 或 update)
            // MP 会在 SQL 中加入 version 条件: WHERE id = ? AND version = ?
            // 并自动将 version + 1: SET stock = ?, version = version + 1
            boolean success = this.updateById(product);
            // 或者:
            // LambdaUpdateWrapper<Product> uw = new LambdaUpdateWrapper<>();
            // uw.eq(Product::getId, productId)
            //   .eq(Product::getVersion, product.getVersion()) // 显式带上版本号条件 (插件也会自动加)
            //   .set(Product::getStock, product.getStock());
            // success = this.update(uw); // 注意: 这种方式下，版本号的自增需要 UpdateWrapper 支持或数据库触发器

            if (!success) {
                // 更新失败，说明数据可能已被其他事务修改 (版本号不匹配)
                // 可以进行重试或抛出并发异常
                throw new RuntimeException("更新失败，数据可能已被修改，请重试");
            }
            return true;
        }
    }
    ```
    **工作原理：**
    *   当你调用 `updateById(entity)` 或 `update(entity, wrapper)` 时，如果实体类中有 `@Version` 注解的字段：
        *   MP 会从 `entity` 对象中获取当前的 `version` 值。
        *   在生成的 `UPDATE` 语句的 `WHERE` 子句中，会自动追加 `AND version = #{currentVersion}`。
        *   在 `SET` 子句中，会自动追加 `version = version + 1`。
    *   如果 `WHERE` 条件中的 `version` 与数据库中的 `version` 不匹配（说明在你查询到更新期间，数据已被其他事务修改），则 `UPDATE` 语句不会更新任何行 (返回影响行数为 0)。
    *   你需要检查 `updateById` 或 `update` 方法的返回值 (通常是 `boolean` 或 `int`) 来判断更新是否成功。如果不成功，通常表示发生了并发冲突。

**注意事项：**

*   乐观锁只对 `updateById(T entity)` 和 `update(T entity, Wrapper<T> updateWrapper)` 方法生效。对于自定义 SQL 的 `update`，你需要手动实现乐观锁逻辑。
*   如果使用 `update(Wrapper<T> updateWrapper)` 仅通过 Wrapper 来更新（第一个实体参数为 `null`），乐观锁插件**默认不会自动处理版本号**，因为没有实体对象来获取旧版本号。你需要自己在 `UpdateWrapper` 的 `eq` 中加入版本号条件，并在 `setSql` 中 `version = version + 1`。或者，确保你的 Wrapper 是基于一个带有正确版本号的实体构建的。
*   并发冲突时，需要应用层决定如何处理（如重试、提示用户、记录日志等）。

---

