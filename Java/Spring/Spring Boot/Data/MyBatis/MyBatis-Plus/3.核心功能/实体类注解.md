“实体类注解详解”的详细阐述。这是理解 MyBatis-Plus 如何将 Java 实体与数据库表关联起来的关键部分。现在我们来补充这部分内容。

---

#### 3.3 实体类注解详解

MyBatis-Plus 通过在实体类上使用一系列注解，来定义类与表、属性与列之间的映射关系，以及一些特殊的行为（如主键策略、自动填充、逻辑删除等）。这些注解使得配置非常灵活和直观。

以下是 MP 中最常用的一些实体类注解：

1.  **`@TableName("table_name")`**:
    *   **作用**: 指定实体类对应的数据库表名。
    *   **使用场景**:
        *   当实体类名与数据库表名不一致时（即使开启了驼峰下划线转换也无法匹配，或者想明确指定）。
        *   例如，实体类为 `UserInfo`，而数据库表名为 `sys_user`，则需要 `@TableName("sys_user")`。
    *   **属性**:
        *   `value()`: 表名字符串。
        *   `schema()`: (可选) 数据库 schema (模式名)。
        *   `keepGlobalPrefix()`: (可选, boolean, 默认 `false`) 是否保持全局配置的表前缀。如果全局配置了 `table-prefix`，并且这里设置为 `true`，则 MP 会在 `value` 指定的表名前再拼接全局前缀。通常保持默认 `false`，即 `value` 就是最终表名。
        *   `resultMap()`: (可选) 指定该表对应的自定义 ResultMap 的 ID (通常用于更复杂的原生 MyBatis XML 映射)。
        *   `autoResultMap()`: (可选, boolean, 默认 `false`) 是否自动构建一个 ResultMap。如果为 `true`，MP 会尝试根据实体字段自动生成一个基础的 ResultMap，这对于一些包含复杂类型（如嵌套对象、集合，需要自定义 TypeHandler）的字段，并且没有显式定义 ResultMap 的情况可能有用。但通常如果需要复杂映射，还是建议手写 ResultMap。
    ```java
    import com.baomidou.mybatisplus.annotation.TableName;

    @TableName("user_profile_detail") // 明确指定表名
    public class UserProfile {
        // ...
    }
    ```

2.  **`@TableId`**:
    *   **作用**: 标记实体类中的主键字段。
    *   **使用场景**: 必须在主键属性上使用此注解。
    *   **属性**:
        *   `value()`: (可选) 指定主键在数据库中的列名。如果属性名与列名符合驼峰下划线转换规则（且已开启 `map-underscore-to-camel-case`），或者完全一致，则可以省略。
        *   `type()`: (可选) 指定主键的生成策略 (`IdType` 枚举)。如果省略，则采用全局配置的 `id-type`。常用的值有：
            *   `IdType.AUTO`: 数据库自增。
            *   `IdType.NONE`: 无策略。
            *   `IdType.INPUT`: 用户输入。
            *   `IdType.ASSIGN_ID`: MP 分配 ID (雪花算法 for Long, 无'-'UUID for String)。
            *   `IdType.ASSIGN_UUID`: MP 分配 UUID (带'-'UUID for String)。
    ```java
    import com.baomidou.mybatisplus.annotation.IdType;
    import com.baomidou.mybatisplus.annotation.TableId;

    public class Order {
        @TableId(value = "order_pk_id", type = IdType.ASSIGN_ID) // 列名为 order_pk_id, 使用雪花算法
        private Long id;
        // ...
    }
    ```

3.  **`@TableField`**:
    *   **作用**: 标记实体类中的非主键属性与数据库表列的映射关系，以及一些特殊处理。
    *   **使用场景**: 用于普通（非主键）属性。
    *   **属性**:
        *   `value()`: (可选) 指定该属性对应的数据库列名。如果属性名与列名符合驼峰下划线转换，或完全一致，则可省略。
        *   `exist()`: (可选, boolean, 默认 `true`) 当前字段是否为数据库表字段。
            *   `true`: 表示该属性是数据库表中的一个列，MP 会在生成 SQL 时包含它。
            *   `false`: 表示该属性不是数据库表字段（例如，是一个临时计算字段或辅助字段），MP 在生成 SQL 时会忽略它。这常用于所谓的“非持久化”属性。
        *   `select()`: (可选, boolean, 默认 `true`) 在执行 `SELECT` 查询时，是否查询该字段。如果设置为 `false`，则通过 MP 通用查询方法（如 `selectList`, `selectById`）返回的实体对象中，该字段将为 `null` (或其默认值)，除非你在 Wrapper 中通过 `.select()` 方法显式指定查询该列。这对于一些敏感字段或大字段的按需加载有用。
        *   `fill()`: (可选, `FieldFill` 枚举) 指定自动填充策略，配合 `MetaObjectHandler` 使用。
            *   `FieldFill.DEFAULT`: 默认不处理。
            *   `FieldFill.INSERT`: 插入时填充。
            *   `FieldFill.UPDATE`: 更新时填充。
            *   `FieldFill.INSERT_UPDATE`: 插入和更新时都填充。
        *   `jdbcType()`: (可选, `org.apache.ibatis.type.JdbcType` 枚举) 显式指定该字段对应的 JDBC 类型。有时在插入 `null` 值或特定类型转换时需要。
        *   `typeHandler()`: (可选, `Class<? extends org.apache.ibatis.type.TypeHandler>`) 显式指定用于该字段类型转换的自定义 `TypeHandler`。
        *   `numericScale()`: (可选, String) 用于 `java.math.BigDecimal` 类型，指定小数点位数。例如 `numericScale = "2"` 表示保留两位小数。MP 在进行数据库操作时会参考此设置。
        *   `insertStrategy()`: (可选, `FieldStrategy` 枚举, 默认 `DEFAULT`) 插入时的字段策略 (仅对 `insert` 方法有效)。
            *   `DEFAULT`: 跟随全局配置 `global-config.db-config.insert-strategy` (默认是 `NOT_NULL`)。
            *   `NOT_NULL`: 字段值不为 `null` 时才插入。
            *   `NOT_EMPTY`: 字段值不为 `null` 且不为空字符串时才插入 (仅对 String 类型有效)。
            *   `IGNORED`: 忽略此字段的插入策略判断 (总是插入，除非 `exist=false`)。
            *   `NEVER`: 从不插入该字段。
        *   `updateStrategy()`: (可选, `FieldStrategy` 枚举, 默认 `DEFAULT`) 更新时的字段策略 (仅对 `updateById` 和 `update(entity, wrapper)` 的 `entity` 部分有效)。规则类似 `insertStrategy`。
        *   `whereStrategy()`: (可选, `FieldStrategy` 枚举, 默认 `DEFAULT`) 条件构造器中，根据实体构建条件时的字段策略 (`Wrappers.query(entity)` 或 `Wrappers.lambdaQuery(entity)`)。

    ```java
    import com.baomidou.mybatisplus.annotation.FieldFill;
    import com.baomidou.mybatisplus.annotation.FieldStrategy;
    import com.baomidou.mybatisplus.annotation.TableField;
    import java.math.BigDecimal;
    import java.time.LocalDateTime;

    public class ProductItem {
        @TableId
        private Long id;

        @TableField("item_name")
        private String itemName;

        @TableField(exist = false) // 这个字段不在数据库表中
        private String transientHelperField;

        @TableField(select = false) // 默认查询不返回这个字段的值
        private String sensitiveData;

        @TableField(fill = FieldFill.INSERT)
        private LocalDateTime createDate;

        @TableField(value = "item_price", numericScale = "2", updateStrategy = FieldStrategy.NOT_NULL)
        private BigDecimal price; // 更新时，如果 price 为 null，则不更新此字段
    }
    ```

4.  **`@Version`**:
    *   **作用**: 标记一个字段为乐观锁版本号字段。
    *   **使用场景**: 用于实现乐观锁并发控制。
    *   **属性**: 无。
    *   **字段类型**: 通常是 `Integer`, `Long`, `Date`, `Timestamp`, `LocalDateTime`。
    *   **行为**: 需要配合 `OptimisticLockerInnerInterceptor` 插件使用。在更新时，MP 会自动在 `WHERE` 条件中加入 `version = oldVersion`，并在 `SET` 子句中 `version = version + 1`。
    ```java
    import com.baomidou.mybatisplus.annotation.Version;

    public class Account {
        @TableId
        private Long id;
        private BigDecimal balance;
        @Version
        private Integer version;
    }
    ```

5.  **`@TableLogic`**:
    *   **作用**: 标记一个字段为逻辑删除状态字段。
    *   **使用场景**: 实现数据的逻辑删除（软删除）。
    *   **属性**:
        *   `value()`: (可选, String) 逻辑上**未删除**状态的值。默认为全局配置的 `logic-not-delete-value` (通常是 "0")。
        *   `delval()`: (可选, String) 逻辑上**已删除**状态的值。默认为全局配置的 `logic-delete-value` (通常是 "1")。
    *   **字段类型**: 通常是 `Integer`, `Boolean`, `String` 等可以表示两种或多种状态的类型。
    *   **行为**: MP 的通用删除方法会变成更新此字段为 `delval`，通用查询方法会自动添加 `WHERE field = value` 的条件。
    ```java
    import com.baomidou.mybatisplus.annotation.TableLogic;

    public class Document {
        @TableId
        private Long id;
        private String content;

        @TableLogic(value = "false", delval = "true") // 使用 boolean 类型的 true/false
        private Boolean deleted;
        // 或者使用数字 0/1
        // @TableLogic
        // private Integer deleted;
    }
    ```

6.  **`@EnumValue`**:
    *   **作用**: 用于标记 Java 枚举类中的属性，该属性的值将作为实际存储到数据库中的值。
    *   **使用场景**: 当你希望将 Java 枚举类型映射到数据库中的特定值 (如数字或字符串) 时。
    *   **属性**: 无。
    *   **行为**:
        *   MP 默认提供了 `MybatisEnumTypeHandler` (3.1.2版本后) 或 `EnumTypeHandler`。
        *   如果枚举类实现了 `com.baomidou.mybatisplus.annotation.IEnum` 接口，则 `IEnum` 接口的 `getValue()` 方法的返回值会作为存入数据库的值。
        *   如果枚举类没有实现 `IEnum` 接口，但其某个属性被 `@EnumValue` 注解标记，则该属性的值会作为存入数据库的值。
        *   如果既没有实现 `IEnum` 也没有 `@EnumValue`，MP 默认会将枚举的 `name()` (即枚举常量的名称) 存入数据库 (如果数据库列是字符串类型)，或者其 `ordinal()` (顺序，不推荐) 存入数据库 (如果数据库列是数字类型)。
        *   建议配置 `mybatis-plus.type-enums-package` 来让 MP 自动扫描并注册枚举的 TypeHandler。

    ```java
    // 枚举类
    public enum GenderEnum { // 假设不实现 IEnum 接口
        MALE(1, "男"),
        FEMALE(0, "女");

        @EnumValue // 标记 code 属性的值是存入数据库的值
        private final int code;
        private final String description;

        GenderEnum(int code, String description) {
            this.code = code;
            this.description = description;
        }

        public int getCode() { return code; }
        public String getDescription() { return description; }
    }

    // 实体类
    public class Person {
        @TableId
        private Long id;
        private String name;
        private GenderEnum gender; // 数据库中存储的是 gender.code 的值 (0 或 1)
    }

    // 或者实现 IEnum 接口 (更推荐的方式)
    public enum UserStatusEnum implements IEnum<Integer> {
        ACTIVE(1, "激活"),
        INACTIVE(0, "未激活"),
        LOCKED(2, "锁定");

        private final int value; // 这个 value 会被存入数据库
        private final String desc;

        UserStatusEnum(int value, String desc) {
            this.value = value;
            this.desc = desc;
        }

        @Override
        public Integer getValue() { // 实现 IEnum 接口的方法
            return this.value;
        }

        public String getDesc() { return desc; }
    }
    ```
    当使用实现了 `IEnum` 接口的枚举时，MP 会自动使用 `IEnum#getValue()` 的值进行数据库存储和查询时的参数绑定。从数据库读取时，也会根据数据库的值找到对应的枚举常量。