探讨 MyBatis-Plus 的一些进阶使用与技巧。这些内容可以帮助你更灵活、更深入地运用 MP，解决一些特定场景下的问题。

---

### 5. 进阶使用与技巧

#### 5.1 自定义 SQL 与 MP 通用方法结合

MyBatis-Plus 的核心优势之一是其通用 CRUD 能力，但实际项目中，复杂的查询和业务逻辑往往需要手写 SQL。MP 与 MyBatis 原生特性完美兼容，因此你可以非常自然地将自定义 SQL 与 MP 的通用方法结合起来。

**结合方式：**

1.  **在 Mapper 接口中定义自定义方法**:
    你的 Mapper 接口继承了 `BaseMapper<T>`，拥有了通用方法。同时，你可以在这个接口中声明任何你需要自定义 SQL 的方法。
    ```java
    package com.example.yourproject.mapper;

    import com.baomidou.mybatisplus.core.mapper.BaseMapper;
    import com.baomidou.mybatisplus.core.metadata.IPage;
    import com.example.yourproject.entity.User;
    import com.example.yourproject.dto.UserStatsDTO; // 假设一个自定义DTO
    import org.apache.ibatis.annotations.Mapper;
    import org.apache.ibatis.annotations.Param;

    import java.util.List;

    @Mapper
    public interface UserMapper extends BaseMapper<User> {

        // --- 使用 MP 通用方法 (无需实现) ---
        // User selectById(Long id);
        // List<User> selectList(Wrapper<User> queryWrapper);
        // ...

        // --- 自定义 SQL 方法 (需要在 XML 中实现或使用 MyBatis 注解) ---

        /**
         * 根据用户名模糊查询，并按创建时间降序排序 (示例)
         */
        List<User> findUsersByNameLike(@Param("nameKeyword") String nameKeyword);

        /**
         * 查询用户统计信息 (例如：按年龄段分组的用户数)
         * 返回自定义 DTO
         */
        List<UserStatsDTO> getUserStatisticsByAgeGroup();

        /**
         * 分页查询特定状态的用户，并关联查询其角色信息 (复杂查询)
         * @param page 分页参数 (第一个参数必须是 IPage，分页插件才能生效)
         * @param status 用户状态
         * @return
         */
        IPage<UserWithRolesDTO> findUsersWithRolesByStatus(IPage<UserWithRolesDTO> page, @Param("status") String status);

        /**
         * 使用 MyBatis 注解定义简单自定义 SQL (可选)
         */
        @Select("SELECT COUNT(*) FROM user_info WHERE email = #{email}")
        int countByEmail(@Param("email") String email);
    }
    ```

2.  **在对应的 Mapper XML 文件中实现自定义 SQL**:
    对于在 Mapper 接口中声明的、没有使用 MyBatis 注解的自定义方法，你需要在 XML 文件中提供 SQL 实现。
    `src/main/resources/mapper/UserMapper.xml` (假设 `mybatis-plus.mapper-locations` 配置了此路径):
    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper
            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

    <mapper namespace="com.example.yourproject.mapper.UserMapper">

        <!-- (可选) BaseResultMap 和 BaseColumnList，如果代码生成器生成了 -->
        <resultMap id="BaseResultMap" type="com.example.yourproject.entity.User">
            <id column="id" property="id" />
            <result column="name" property="name" />
            <result column="age" property="age" />
            <result column="email" property="email" />
            <result column="create_time" property="createTime" />
        </resultMap>
        <sql id="Base_Column_List">
            id, name, age, email, create_time
        </sql>

        <!-- 实现 findUsersByNameLike 方法 -->
        <select id="findUsersByNameLike" resultMap="BaseResultMap">
            SELECT <include refid="Base_Column_List" />
            FROM user_info
            WHERE name LIKE CONCAT('%', #{nameKeyword}, '%')
            ORDER BY create_time DESC
        </select>

        <!-- 实现 getUserStatisticsByAgeGroup 方法 -->
        <resultMap id="UserStatsDTOMap" type="com.example.yourproject.dto.UserStatsDTO">
            <result column="age_group" property="ageGroup" />
            <result column="user_count" property="userCount" />
        </resultMap>
        <select id="getUserStatisticsByAgeGroup" resultMap="UserStatsDTOMap">
            SELECT
                CASE
                    WHEN age BETWEEN 0 AND 18 THEN '0-18'
                    WHEN age BETWEEN 19 AND 35 THEN '19-35'
                    WHEN age BETWEEN 36 AND 50 THEN '36-50'
                    ELSE '50+'
                END AS age_group,
                COUNT(*) AS user_count
            FROM user_info
            GROUP BY age_group
            ORDER BY age_group
        </select>

        <!-- 实现 findUsersWithRolesByStatus 方法 (复杂 JOIN 和 DTO 映射) -->
        <resultMap id="UserWithRolesDTOMap" type="com.example.yourproject.dto.UserWithRolesDTO">
            <id column="user_id" property="userId" />
            <result column="user_name" property="userName" />
            <result column="user_email" property="email" />
            <collection property="roles" ofType="com.example.yourproject.dto.RoleDTO">
                <id column="role_id" property="roleId" />
                <result column="role_name" property="roleName" />
            </collection>
        </resultMap>
        <select id="findUsersWithRolesByStatus" resultMap="UserWithRolesDTOMap">
            SELECT
                u.id AS user_id,
                u.name AS user_name,
                u.email AS user_email,
                r.id AS role_id,
                r.name AS role_name
            FROM
                user_info u
            LEFT JOIN
                user_role ur ON u.id = ur.user_id
            LEFT JOIN
                role_info r ON ur.role_id = r.id
            WHERE
                u.status = #{status}
            <!-- 分页插件会自动处理这里的 SQL，添加分页条件 -->
            <!-- 如果有排序需求，可以在这里加 ORDER BY u.create_time DESC -->
        </select>
    </mapper>
    ```

**最佳实践：**

*   **优先使用 MP 通用方法和 Wrapper**: 对于单表 CRUD 和大部分条件查询，MP 的通用方法和 Wrapper 非常高效。
*   **复杂逻辑、多表 JOIN、特定聚合、存储过程调用**: 当 Wrapper 难以表达或性能不佳时，果断使用自定义 SQL。
*   **保持 Mapper 接口清晰**: 通用方法由 `BaseMapper` 提供，自定义方法在接口中声明，实现放在 XML 中，各司其职。
*   **DTO (Data Transfer Object)**: 对于复杂的查询结果（尤其是多表 JOIN），通常需要创建 DTO 来封装返回的数据，而不是直接返回多个实体或 Map。在 XML 中定义对应的 `resultMap` 来映射到 DTO。
*   **分页插件与自定义 SQL**: 分页插件对自定义 SQL 同样生效，只要 Mapper 方法的第一个参数是 `IPage` 类型。

#### 5.2 `IService` 的常用方法与自定义扩展

`IService<T>` 接口及其实现类 `ServiceImpl<M extends BaseMapper<T>, T>` 为 Service 层提供了许多便利的方法，封装了对 `BaseMapper` 的调用，并增加了一些批量操作和链式操作的便捷性。

**常用 `IService` 方法回顾 (部分已在 3.1 节提及)：**

*   **保存**: `save(T entity)`, `saveBatch(Collection<T> entityList, int batchSize)`, `saveOrUpdate(T entity)`, `saveOrUpdateBatch(Collection<T> entityList, int batchSize)`
    *   `batchSize` 参数用于控制批量操作时每批提交的数量。
*   **删除**: `removeById(Serializable id)`, `removeByIds(Collection<? extends Serializable> idList)`, `removeByMap(Map<String, Object> columnMap)`, `remove(Wrapper<T> queryWrapper)`
*   **更新**: `updateById(T entity)`, `update(Wrapper<T> updateWrapper)`, `update(T entity, Wrapper<T> updateWrapper)`, `updateBatchById(Collection<T> entityList, int batchSize)`
*   **查询 (单个/列表)**: `getById(Serializable id)`, `getOne(Wrapper<T> queryWrapper, boolean throwEx)`, `listByIds(Collection<? extends Serializable> idList)`, `listByMap(Map<String, Object> columnMap)`, `list(Wrapper<T> queryWrapper)`, `list()`
    *   `getOne` 的 `throwEx` 参数：如果为 `true` 且查询结果不唯一，则抛异常。
*   **查询 (聚合/投影)**: `count()`, `count(Wrapper<T> queryWrapper)`, `listMaps(Wrapper<T> queryWrapper)`, `listObjs(Wrapper<T> queryWrapper, Function<? super Object, ?> mapper)` (可以对结果进行转换)
*   **分页**: `page(IPage<T> page, Wrapper<T> queryWrapper)`, `pageMaps(IPage<Map<String, Object>> page, Wrapper<T> queryWrapper)`
*   **链式查询/更新**: `lambdaQuery()`, `lambdaUpdate()` 返回链式操作器。

**自定义扩展 `IService`：**

通常，你会创建自己的 Service 接口继承 `IService<T>`，并在其实现类中添加项目特有的业务逻辑。

`ICustomUserService.java`:
```java
package com.example.yourproject.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.example.yourproject.entity.User;
import com.example.yourproject.dto.UserRegistrationDTO;

public interface ICustomUserService extends IService<User> {

    /**
     * 用户注册业务
     * @param registrationDTO 注册信息 DTO
     * @return 注册成功的用户实体
     * @throws BusinessException 如果注册失败 (如用户名已存在)
     */
    User registerNewUser(UserRegistrationDTO registrationDTO) throws BusinessException;

    /**
     * 修改用户密码
     * @param userId 用户ID
     * @param oldPassword 旧密码
     * @param newPassword 新密码
     * @return 是否成功
     */
    boolean changePassword(Long userId, String oldPassword, String newPassword);

    // ... 其他自定义业务方法
}
```

`CustomUserServiceImpl.java`:
```java
package com.example.yourproject.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.example.yourproject.entity.User;
import com.example.yourproject.mapper.UserMapper;
import com.example.yourproject.service.ICustomUserService;
import com.example.yourproject.dto.UserRegistrationDTO;
import org.springframework.beans.BeanUtils; // or MapStruct
import org.springframework.security.crypto.password.PasswordEncoder; // 假设使用 Spring Security
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional; // 事务管理

@Service
public class CustomUserServiceImpl extends ServiceImpl<UserMapper, User> implements ICustomUserService {

    // 已经注入了 baseMapper (即 UserMapper)
    // @Autowired
    // private PasswordEncoder passwordEncoder; // 假设注入了密码编码器

    @Override
    @Transactional // 重要的业务操作，需要事务保证
    public User registerNewUser(UserRegistrationDTO registrationDTO) throws BusinessException {
        // 1. 检查用户名是否存在
        if (this.count(new LambdaQueryWrapper<User>().eq(User::getName, registrationDTO.getUsername())) > 0) {
            throw new BusinessException("用户名已存在!");
        }

        // 2. DTO 转换为 Entity
        User newUser = new User();
        BeanUtils.copyProperties(registrationDTO, newUser); // 简单属性复制

        // 3. 密码加密 (示例)
        // newUser.setPassword(passwordEncoder.encode(registrationDTO.getPassword()));

        // 4. 设置其他默认值或业务逻辑 (例如，默认状态，创建时间由 MetaObjectHandler 填充)
        newUser.setStatus("ACTIVE");

        // 5. 保存用户 (调用 IService 的 save 方法)
        boolean saved = this.save(newUser);
        if (!saved) {
            throw new BusinessException("用户注册失败，请稍后重试。");
        }
        return newUser; // 返回的 newUser 对象会包含生成的主键 (如果主键策略支持回填)
    }

    @Override
    @Transactional
    public boolean changePassword(Long userId, String oldPassword, String newPassword) {
        User user = this.getById(userId);
        if (user == null) {
            throw new BusinessException("用户不存在!");
        }

        // 1. 验证旧密码 (示例)
        // if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
        //     throw new BusinessException("旧密码不正确!");
        // }

        // 2. 更新为新密码
        User userUpdate = new User();
        userUpdate.setId(userId);
        // userUpdate.setPassword(passwordEncoder.encode(newPassword));
        // (可选) 乐观锁版本号，如果 User 实体有 @Version，getById() 会查出来
        // userUpdate.setVersion(user.getVersion());

        return this.updateById(userUpdate);
    }
}
```
**`ServiceImpl` 的优势：**
*   它帮你处理了 `BaseMapper` 的注入 (通过 `baseMapper` 属性访问)。
*   它提供了许多基于 `BaseMapper` 方法的封装，使得 Service 层代码更简洁。
*   你可以直接在自定义 Service 实现类中调用 `this.save()`, `this.list()`, `this.count()` 等方法，这些方法最终会调用 `baseMapper` 的对应方法。

#### 5.3 ActiveRecord 模式 (可选，非主流)

MyBatis-Plus 支持 ActiveRecord (AR) 模式。在 AR 模式中，实体类自身继承 `com.baomidou.mybatisplus.extension.activerecord.Model<T extends Model<?>>` 类，从而使实体对象拥有了直接执行数据库操作的能力 (如 `user.insert()`, `user.selectById()`, `user.updateById()` 等)。

**启用 AR 模式：**

1.  让你的实体类继承 `Model<YourEntity>`:
    ```java
    import com.baomidou.mybatisplus.extension.activerecord.Model;
    // ... 其他注解

    @TableName("user_ar")
    public class UserAR extends Model<UserAR> { // 继承 Model<UserAR>

        @TableId(type = IdType.AUTO)
        private Long id;
        private String name;
        private Integer age;

        // getter/setter ...

        // (可选) 如果主键不叫 "id"，需要重写此方法
        // @Override
        // protected Serializable pkVal() {
        //     return this.id;
        // }
    }
    ```
2.  **不需要创建 Mapper 接口！** (AR 模式的核心思想之一)

**使用示例：**
```java
@Service
public class UserARService {

    public UserAR createUser(String name, Integer age) {
        UserAR user = new UserAR();
        user.setName(name);
        user.setAge(age);
        boolean success = user.insert(); // 直接调用实体对象的 insert 方法
        if (success) {
            System.out.println("User created with ID: " + user.getId()); // 主键会自动回填
            return user;
        }
        return null;
    }

    public UserAR findUser(Long id) {
        UserAR userQuery = new UserAR();
        // userQuery.setId(id); // 可以这样，然后 userQuery.selectById()
        // 或者更直接
        return new UserAR().selectById(id);
    }

    public List<UserAR> findAllUsersByName(String name) {
        return new UserAR().selectList(
            new LambdaQueryWrapper<UserAR>().like(UserAR::getName, name)
        );
    }

    public boolean updateUserAge(Long id, Integer newAge) {
        UserAR user = new UserAR().selectById(id);
        if (user != null) {
            user.setAge(newAge);
            return user.updateById();
        }
        return false;
    }

    public boolean deleteUser(Long id) {
        UserAR user = new UserAR();
        user.setId(id);
        return user.deleteById();
        // 或者 return new UserAR().deleteById(id);
    }
}
```

**AR 模式的优缺点：**

*   **优点**:
    *   代码更简洁，对于简单的 CRUD 操作，实体类本身就可以完成，减少了 Mapper 和 Service 层的样板代码。
    *   更贴近某些其他 ORM 框架 (如 Ruby on Rails ActiveRecord, Yii Framework AR) 的使用习惯。
*   **缺点**:
    *   **职责不清**: 实体类承担了数据存储和数据操作的双重职责，违反了单一职责原则，使得实体类变得“重”。
    *   **测试困难**: 业务逻辑与数据访问紧密耦合在实体类中，单元测试可能更难 mock。
    *   **不适合复杂查询**: 对于复杂的 JOIN、聚合等操作，AR 模式仍然需要依赖 Wrapper 或者手写 SQL (这时可能需要一个辅助的 Mapper)。
    *   **与传统分层架构的理念有所偏差**: 在经典的三层架构 (Controller-Service-DAO) 中，DAO/Mapper 层是明确的数据访问层。AR 模式模糊了这一界限。
    *   **在 MyBatis 生态中并非主流**: 大多数 MyBatis/MP 用户仍然习惯于使用 Mapper 接口的方式。这意味着社区资源、示例、以及一些基于 Mapper 的扩展可能对 AR 模式支持较少。

**结论**: AR 模式提供了一种不同的开发风格。对于小型项目或快速原型开发，它可能带来一些便利。但对于中大型项目、强调分层和可测试性的项目，**传统的 Mapper + Service 模式通常是更稳健和主流的选择。** 你可以根据项目需求和团队偏好来决定是否使用。

---

好的，我们继续探讨 MyBatis-Plus 的动态表名处理和枚举处理的最佳实践。这两个是实际项目中可能遇到的比较具体的问题。

---

#### 5.4 MP 的动态表名处理

在某些场景下，你可能需要根据不同的条件（如时间、租户 ID、用户分片键等）将数据操作到不同的表中，这些表的结构通常是相同的，只是表名不同。这就是动态表名的需求。

MyBatis-Plus 提供了对动态表名的支持，主要通过 `TableNameHandler` 接口和 `DynamicTableNameInnerInterceptor` 插件。

**核心组件：**

1.  **`com.baomidou.mybatisplus.extension.plugins.handler.TableNameHandler` 接口**:
    你需要实现此接口，并定义如何根据上下文动态地返回实际的表名。
    ```java
    package com.example.yourproject.handler;

    import com.baomidou.mybatisplus.extension.plugins.handler.TableNameHandler;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.stereotype.Component;

    import java.time.LocalDate;
    import java.time.format.DateTimeFormatter;

    @Slf4j
    @Component // 注册为 Spring Bean
    public class MyDynamicTableNameHandler implements TableNameHandler {

        // 使用 ThreadLocal 存储需要动态切换的表名后缀或其他标识
        // 注意：这只是一个示例，实际场景中如何传递动态参数需要仔细设计
        // 例如，可以通过 AOP 在 Service 方法调用前设置，或从请求上下文中获取
        private static final ThreadLocal<String> DYNAMIC_TABLE_SUFFIX = new ThreadLocal<>();

        public static void setTableSuffix(String suffix) {
            DYNAMIC_TABLE_SUFFIX.set(suffix);
        }

        public static String getTableSuffix() {
            return DYNAMIC_TABLE_SUFFIX.get();
        }

        public static void clearTableSuffix() {
            DYNAMIC_TABLE_SUFFIX.remove();
        }

        /**
         * 动态改变表名
         * @param sql       当前执行的 SQL
         * @param tableName 原始表名 (实体类上 @TableName 指定的，或按规则转换的)
         * @return 处理后的实际表名
         */
        @Override
        public String dynamicTableName(String sql, String tableName) {
            String suffix = getTableSuffix();
            if (suffix != null && !suffix.isEmpty()) {
                // 例如，原始表名是 "user_logs", 后缀是 "_202310"
                // 那么实际操作的表名将是 "user_logs_202310"
                String dynamicTableName = tableName + "_" + suffix;
                log.debug("DynamicTableName: Original='{}', Suffix='{}', Dynamic='{}'", tableName, suffix, dynamicTableName);
                return dynamicTableName;
            }

            // 如果没有设置动态后缀，则使用原始表名
            // 也可以在这里实现更复杂的逻辑，比如根据租户ID、用户ID分表等
            // if ("user_order".equals(tableName)) { // 只针对特定表
            //     Long userId = getCurrentUserId(); // 获取当前用户ID
            //     if (userId != null) {
            //         return tableName + "_" + (userId % 16); // 按用户ID取模分16张表
            //     }
            // }

            return tableName; // 默认返回原始表名
        }
    }
    ```
    *   `dynamicTableName(String sql, String tableName)` 方法是核心。参数 `tableName` 是 MP 根据实体类注解或命名规则解析出的“静态”表名。你需要在这个方法中返回实际要操作的表名。
    *   **如何传递动态参数 (如 `suffix`, `userId`) 是关键**。`ThreadLocal` 是一种常用方式，但需要确保在合适的时机设置和清除。其他方式包括从方法参数、请求上下文、AOP 切面等获取。

2.  **`com.baomidou.mybatisplus.extension.plugins.inner.DynamicTableNameInnerInterceptor` 插件**:
    这个插件负责拦截 SQL，并调用你实现的 `TableNameHandler` 来替换表名。

    **配置插件**:
    将其添加到 `MybatisPlusInterceptor` 中。
    ```java
    // 在 MybatisPlusPluginConfig.java 中的 mybatisPlusInterceptor() 方法内添加
    import com.baomidou.mybatisplus.extension.plugins.inner.DynamicTableNameInnerInterceptor;
    import com.example.yourproject.handler.MyDynamicTableNameHandler; // 引入你的 Handler
    import org.springframework.beans.factory.annotation.Autowired;
    // ...

    @Configuration
    public class MybatisPlusPluginConfig {

        @Autowired // 注入你自定义的 TableNameHandler
        private MyDynamicTableNameHandler myDynamicTableNameHandler;

        @Bean
        public MybatisPlusInterceptor mybatisPlusInterceptor() {
            MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();

            // 添加动态表名插件
            DynamicTableNameInnerInterceptor dynamicTableNameInterceptor = new DynamicTableNameInnerInterceptor();
            // 设置 TableNameHandler (可以是一个 Map，key 是静态表名，value 是对应的 Handler)
            // 如果只有一个 Handler 应用于所有表（或 Handler 内部判断），可以直接设置
            // dynamicTableNameInterceptor.setTableNameHandler(myDynamicTableNameHandler); // 直接设置一个默认的
            // 或者更精细地控制：
            dynamicTableNameInterceptor.setTableNameHandlerMap(new HashMap<String, TableNameHandler>() {{
                // key 可以是正则表达式匹配表名，也可以是精确表名
                // put("user_logs", myDynamicTableNameHandler); // 只对 user_logs 表使用此 Handler
                // put(".*_log.*", myDynamicTableNameHandler); // 对所有包含 _log_ 的表使用
                // 如果不指定 key，则默认对所有表都尝试调用 handler (如果 handler 内部有判断逻辑)
                // MP 3.4.2+ 版本后，如果只配置一个全局的handler，可以直接在构造函数传入，或setTableNameHandler。
                // 如果需要为不同表或不同模式的表名配置不同的handler，才使用 setTableNameHandlerMap。
                // 这里假设 MyDynamicTableNameHandler 内部会判断是否需要处理
            }});
            // 修正：对于全局应用一个handler的场景，更推荐的是在构造DynamicTableNameInnerInterceptor时传入
            // 或者，如果DynamicTableNameInnerInterceptor构造时未传入handler，它会尝试从Spring容器中获取唯一的TableNameHandler Bean。
            // 所以，如果 MyDynamicTableNameHandler 已经 @Component，这里甚至可以不显式 set。
            // 最新的推荐做法，如果你的 MyDynamicTableNameHandler 已经 @Component:
            // DynamicTableNameInnerInterceptor dynamicTableNameInterceptor = new DynamicTableNameInnerInterceptor();
            // (MP 会自动从 Spring 容器中查找并注入 TableNameHandler Bean)
            // 如果有多个 TableNameHandler Bean, 才需要显式指定，例如：
            // Map<String, TableNameHandler> handlerMap = new HashMap<>();
            // handlerMap.put("user_logs", userLogsTableNameHandler);
            // handlerMap.put("order_details", orderDetailsTableNameHandler);
            // dynamicTableNameInterceptor.setTableNameHandlerMap(handlerMap);
            // 如果只有一个，且已注册为Bean, 插件会自动查找

            interceptor.addInnerInterceptor(dynamicTableNameInterceptor);

            // 添加其他插件...
            // interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));

            return interceptor;
        }
    }
    ```
    **注意 `setTableNameHandlerMap` 和直接注入 `TableNameHandler` Bean 的行为**:
    *   如果 `DynamicTableNameInnerInterceptor` 构造时**没有**传入 `TableNameHandler`，并且**没有**调用 `setTableNameHandlerMap` 或 `setTableNameHandler`，它会尝试从 Spring 容器中查找一个**唯一**的 `TableNameHandler` 类型的 Bean 并使用。
    *   如果存在多个 `TableNameHandler` Bean，你需要通过 `setTableNameHandlerMap` 来指定哪个表名（或正则）使用哪个 Handler。
    *   如果只配置一个全局的 `TableNameHandler`，确保它被 `@Component` 注解，并且是唯一的，插件通常能自动找到。

**使用示例：**
假设我们要按月分表存储用户日志 (`user_logs_YYYYMM`)。

1.  实体类 `UserLog`，`@TableName("user_logs")` (静态基础表名)。
2.  实现 `MyDynamicTableNameHandler`，其中 `getTableSuffix()` 返回如 `"202310"` 的后缀。
3.  配置 `DynamicTableNameInnerInterceptor`。
4.  在 Service 方法执行前，设置动态表名后缀：
    ```java
    @Service
    public class UserLogService extends ServiceImpl<UserLogMapper, UserLog> {

        public void saveLogForCurrentMonth(UserLog logEntry) {
            String currentMonthSuffix = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMM"));
            MyDynamicTableNameHandler.setTableSuffix(currentMonthSuffix);
            try {
                this.save(logEntry); // SQL 会被插件修改为操作 user_logs_YYYYMM 表
            } finally {
                MyDynamicTableNameHandler.clearTableSuffix(); // 非常重要：操作完成后清除 ThreadLocal
            }
        }

        public List<UserLog> getLogsForMonth(String yearMonthSuffix) { // yearMonthSuffix 例如 "202310"
            MyDynamicTableNameHandler.setTableSuffix(yearMonthSuffix);
            try {
                // 使用 Wrapper 查询
                return this.list(new LambdaQueryWrapper<UserLog>().orderByDesc(UserLog::getLogTime));
            } finally {
                MyDynamicTableNameHandler.clearTableSuffix();
            }
        }
    }
    ```

**注意事项和最佳实践：**

*   **`ThreadLocal` 的管理**: 如果使用 `ThreadLocal` 传递动态表名参数，务必在 `finally` 块中调用 `clear()` 方法，防止内存泄漏或在后续请求中错误地使用旧的表名。AOP (切面) 是管理 `ThreadLocal` 设置和清除的更优雅方式。
*   **性能**: SQL 解析和表名替换会引入少量性能开销。
*   **DDL 管理**: 动态创建的表（如按月分表）需要有相应的 DDL 管理机制（如定时任务创建下个月的表）。
*   **查询跨动态表**: 如果需要查询多个动态表的数据 (例如，查询最近三个月的日志)，动态表名插件本身不直接支持这种跨表聚合。你可能需要：
    *   多次调用，每次设置不同的表名后缀，然后在应用层合并结果。
    *   编写一个特殊的 Mapper 方法，其 SQL 使用 `UNION ALL` 来查询多个实际表名（这时可能需要一种方式在 `TableNameHandler` 中临时禁用动态表名替换，或者这个特定 SQL 不经过动态表名插件）。
    *   使用数据库的分区表功能（如果数据库支持），这通常是处理这类按时间范围划分数据的更标准和高效的方式。
*   **复杂 SQL (JOIN, 子查询)**: 插件会尽力处理，但对于非常复杂的 SQL，其表名替换的准确性需要仔细测试。有时可能需要在 `TableNameHandler` 中对特定的 SQL 或表名进行特殊处理。
*   **缓存**: 如果使用了 MyBatis 的二级缓存，动态表名可能会影响缓存的命中和管理，因为缓存通常与静态的 `namespace + statementId` 关联。你需要考虑动态表名对缓存策略的影响。

---

#### 5.5 枚举处理的最佳实践

在 Java 中使用枚举类型可以增强代码的可读性和类型安全。MyBatis-Plus 提供了对枚举类型的良好支持，允许你方便地将枚举映射到数据库中的值 (通常是数字或字符串)。

**MP 处理枚举的几种方式：**

1.  **默认行为 (无特殊配置，枚举未实现 `IEnum`，未使用 `@EnumValue`)**:
    *   **数据库列为数字类型 (INT, TINYINT)**: MP 默认会将枚举的 `ordinal()` (枚举常量的声明顺序，从 0 开始) 存入数据库。**不推荐，因为枚举顺序改变会导致数据错乱。**
    *   **数据库列为字符串类型 (VARCHAR)**: MP 默认会将枚举的 `name()` (枚举常量的名称字符串) 存入数据库。这种方式相对安全，但可能不够灵活（如想存自定义编码）。

2.  **实现 `com.baomidou.mybatisplus.annotation.IEnum<T>` 接口 (推荐)**:
    让你的枚举类实现 `IEnum<T>` 接口 (其中 `T` 是你希望存储到数据库的值的类型，如 `Integer`, `String`)，并实现 `getValue()` 方法。
    ```java
    import com.baomidou.mybatisplus.annotation.IEnum;
    import com.fasterxml.jackson.annotation.JsonValue; // (可选) 用于Jackson序列化

    public enum UserStatusEnum implements IEnum<Integer> {
        ACTIVE(1, "激活"),
        INACTIVE(0, "未激活"),
        LOCKED(2, "锁定");

        private final int code; // 实际存储到数据库的值
        private final String description;

        UserStatusEnum(int code, String description) {
            this.code = code;
            this.description = description;
        }

        @Override
        public Integer getValue() { // 实现 IEnum 接口，返回要存入数据库的值
            return this.code;
        }

        // (可选) 如果希望 Jackson 序列化时也使用 code 值
        // @JsonValue
        // public Integer getCode() {
        //     return code;
        // }

        public String getDescription() {
            return description;
        }

        // (可选) 提供一个静态方法用于从数据库值反向查找枚举 (虽然MP通常会自动处理)
        public static UserStatusEnum fromCode(Integer code) {
            if (code == null) return null;
            for (UserStatusEnum status : UserStatusEnum.values()) {
                if (status.getValue().equals(code)) {
                    return status;
                }
            }
            throw new IllegalArgumentException("Unknown UserStatusEnum code: " + code);
        }
    }
    ```
    *   **行为**: MP 会自动使用 `IEnum` 的 `getValue()` 方法的返回值进行数据库存储和查询参数绑定。从数据库读取时，也会根据数据库的值找到对应的枚举常量。
    *   **需要配置 `mybatis-plus.type-enums-package`**: 在 `application.yml` 中配置枚举类所在的包路径，MP 会自动扫描并为这些实现了 `IEnum` 的枚举注册 `MybatisEnumTypeHandler`。
        ```yaml
        mybatis-plus:
          type-enums-package: com.example.yourproject.enums
        ```

3.  **使用 `@com.baomidou.mybatisplus.annotation.EnumValue` 注解**:
    如果你的枚举类由于某些原因不能实现 `IEnum` 接口 (例如，是第三方库的枚举)，可以在枚举类中用 `@EnumValue` 注解标记一个属性，该属性的值将作为实际存储到数据库中的值。
    ```java
    import com.baomidou.mybatisplus.annotation.EnumValue;

    public enum GenderEnum {
        MALE(1, "男"),
        FEMALE(0, "女"),
        UNKNOWN(-1, "未知");

        @EnumValue // 标记这个字段的值是存入数据库的
        private final int codeAsDBValue; // 属性名可以任意，但通常有意义
        private final String displayName;

        GenderEnum(int code, String name) {
            this.codeAsDBValue = code;
            this.displayName = name;
        }

        public int getCodeAsDBValue() { return codeAsDBValue; }
        public String getDisplayName() { return displayName; }
    }
    ```
    *   **行为**: MP 会使用被 `@EnumValue` 注解的属性的值进行数据库操作。
    *   同样建议配置 `mybatis-plus.type-enums-package`，MP 会为这类枚举注册 `EnumTypeHandler`。

4.  **全局配置默认枚举处理器 (不常用，除非有特殊需求)**:
    可以通过 `mybatis-plus.configuration.default-enum-type-handler` 指定一个全局的默认枚举处理器类。但通常通过实现 `IEnum` 或使用 `@EnumValue` 配合包扫描就足够了。

**最佳实践总结：**

1.  **强烈推荐让枚举类实现 `IEnum<T>` 接口**。这是 MP 最推荐、最灵活且功能最完善的方式。它不仅处理了数据库的存取，还有助于在其他地方（如前端交互、参数校验）统一使用枚举的值。
2.  如果无法修改枚举类使其实现 `IEnum` (如第三方枚举)，则使用 `@EnumValue` 注解。
3.  **务必配置 `mybatis-plus.type-enums-package`**，让 MP 能够自动发现并正确处理你的枚举类型。
4.  **避免依赖枚举的 `ordinal()`** 进行数据库存储，因为它非常脆弱，一旦枚举常量顺序改变，数据就会错乱。
5.  如果数据库列是字符串类型，存储枚举的 `name()` 是一种可接受的简单方式，但不如 `IEnum` 或 `@EnumValue` 灵活（例如，如果想存储一个简短的代码而不是完整的常量名）。
6.  在实体类中直接使用枚举类型作为属性：
    ```java
    public class User {
        private String username;
        private UserStatusEnum status; // 直接使用枚举类型
        private GenderEnum gender;
        // ...
    }
    ```
    MP 会根据配置的处理器自动进行转换。
7.  **查询时使用枚举**:
    在 Wrapper 中可以直接使用枚举常量作为查询条件的值。
    ```java
    // new LambdaQueryWrapper<User>().eq(User::getStatus, UserStatusEnum.ACTIVE);
    // userService.list(new LambdaQueryWrapper<User>().eq(User::getGender, GenderEnum.FEMALE));
    ```
    MP 会正确地将枚举转换为其数据库存储值 (通过 `IEnum#getValue()` 或 `@EnumValue` 标记的属性值) 进行比较。

通过遵循这些实践，你可以清晰、安全且高效地在 MyBatis-Plus 项目中使用枚举类型。

---

我们已经探讨了 MP 的动态表名处理和枚举处理的最佳实践。这些都是在实际开发中非常实用的技巧。

至此，关于 MyBatis-Plus 的核心功能和一些进阶技巧我们已经覆盖了很多。