好的，我们来详细讲解如何在 Spring Boot 项目中快速集成和使用 MyBatis。Spring Boot 社区提供了 `mybatis-spring-boot-starter`，极大地简化了这个过程。

### 2. Spring Boot 集成 MyBatis (怎么快速开始)

#### 2.1 依赖引入 (`mybatis-spring-boot-starter`)

要在 Spring Boot 项目中使用 MyBatis，首先需要在你的 `pom.xml` (如果是 Maven 项目) 或 `build.gradle` (如果是 Gradle 项目) 文件中添加必要的依赖。

**对于 Maven 项目 (`pom.xml`)：**

```xml
<dependencies>
    <!-- MyBatis Spring Boot Starter -->
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>3.0.3</version> <!-- 请使用最新的稳定版本 -->
    </dependency>

    <!-- 数据库驱动 (以 MySQL 为例) -->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- Spring Boot Web Starter (如果需要构建 Web 应用) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Spring Boot Test Starter (用于测试) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

**关键点：**

*   `mybatis-spring-boot-starter`: 这是核心依赖。它会自动引入 `mybatis`、`mybatis-spring` 以及 Spring Boot 相关的自动配置类。
*   **数据库驱动**: 你需要根据你使用的数据库类型添加相应的 JDBC 驱动。例如：
    *   MySQL: `mysql-connector-j` (最新的 groupId 和 artifactId)
    *   PostgreSQL: `postgresql`
    *   Oracle: 通常需要从 Oracle 官网下载或使用 `com.oracle.database.jdbc:ojdbcX` (X 是版本号)
    *   SQL Server: `mssql-jdbc`
*   **版本号**: 建议总是查看 [MyBatis-Spring-Boot-Starter 的 GitHub 仓库](https://github.com/mybatis/spring-boot-starter) 或 Maven 中央仓库来获取最新的稳定版本。目前（截至我最后更新时）`3.0.x` 系列是针对 Spring Boot 3.x 的。

**对于 Gradle 项目 (`build.gradle`)：**

```gradle
dependencies {
    implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.3' // 请使用最新的稳定版本
    runtimeOnly 'com.mysql:mysql-connector-j' // 以 MySQL 为例
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

#### 2.2 核心配置 (`application.yml` 或 `application.properties`)

引入依赖后，接下来需要在 Spring Boot 的配置文件中配置 MyBatis 和数据源。通常使用 `application.yml` (YAML 格式) 或 `application.properties`。我这里以 `application.yml` 为例，因为它结构更清晰。

**`src/main/resources/application.yml`:**

```yaml
spring:
  # --- 数据源配置 (DataSource Configuration) ---
  datasource:
    url: jdbc:mysql://localhost:3306/your_database_name?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
    username: your_username
    password: your_password
    driver-class-name: com.mysql.cj.jdbc.Driver # MySQL 8+ 驱动类名
    # HikariCP 连接池配置 (Spring Boot 默认使用 HikariCP, 可选配置)
    hikari:
      connection-timeout: 30000 # 连接超时时间 (毫秒)
      idle-timeout: 600000     # 空闲连接超时时间 (毫秒)
      maximum-pool-size: 10    # 最大连接数
      minimum-idle: 5          # 最小空闲连接数

mybatis:
  # --- MyBatis 核心配置 ---
  # 指定 Mapper XML 文件的位置 (非常重要)
  # Ant-style path patterns are supported.
  # 默认值: classpath*:/mapper/**/*.xml (如果你的 XML 文件放在 resources/mapper/ 目录下，并且后缀是 .xml，这个可以不配)
  mapper-locations: classpath:mapper/**/*.xml # 例如: classpath:com/example/mapper/**/*.xml

  # 指定实体类别名扫描包 (可选, 但推荐)
  # 这样在 XML 中可以直接使用类名作为 type, 而不是完整的包名.
  type-aliases-package: com.example.yourproject.model # 替换为你的实体类所在的包

  # 指定 MyBatis 配置文件路径 (可选, 如果你需要更复杂的 MyBatis 配置)
  # config-location: classpath:mybatis-config.xml

  # --- 其他 MyBatis 可选配置 ---
  configuration:
    # 开启驼峰命名自动映射 (数据库下划线 -> Java 驼峰)
    map-underscore-to-camel-case: true
    # 配置日志实现 (SLF4J, STDOUT_LOGGING, LOG4J, LOG4J2, JDK_LOGGING, COMMONS_LOGGING, NO_LOGGING)
    # Spring Boot 项目通常默认使用 SLF4J (通过 Logback 或 Log4j2)
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
    # 延迟加载总开关 (默认 false)
    # lazy-loading-enabled: true
    # 积极加载总开关 (默认 false, 与 lazy-loading-enabled 互斥, 通常不一起用)
    # aggressive-lazy-loading: false
    # 是否开启二级缓存 (默认 true, 但需要配合 mapper 文件的 <cache/> 标签才真正生效)
    # cache-enabled: true

# (可选) 如果你的 Mapper 接口和 XML 文件不在同一个包下，或者你想明确指定扫描路径
# mybatis.type-handlers-package: com.example.yourproject.typehandler # 自定义 TypeHandler 包
# mybatis.mapper-scan-package: com.example.yourproject.mapper # 如果不使用 @MapperScan, 可以在这里配置

# (可选) 日志配置, 方便查看 MyBatis 执行的 SQL
logging:
  level:
    com.example.yourproject.mapper: DEBUG # 将你的 Mapper 接口所在的包路径替换掉，设置为 DEBUG 可以看到执行的 SQL
    # 或者更通用地:
    # org.apache.ibatis: DEBUG # 查看 MyBatis 内部日志
    # java.sql.Connection: DEBUG
    # java.sql.Statement: DEBUG
    # java.sql.PreparedStatement: DEBUG # 这个能看到 PrepareStatement 的 SQL 和参数
    # java.sql.ResultSet: TRACE # (非常详细，谨慎开启)
```

**关键配置项解释：**

*   **`spring.datasource.*`**:
    *   `url`: JDBC 连接 URL。
    *   `username`, `password`: 数据库用户名和密码。
    *   `driver-class-name`: JDBC 驱动类名。Spring Boot 通常能自动检测，但显式配置更保险。
    *   `hikari.*`: HikariCP 连接池的配置。Spring Boot 默认集成并推荐 HikariCP，性能优秀。这些配置可以根据实际需求调整。

*   **`mybatis.*`**:
    *   **`mapper-locations`**: **极其重要**。指定 MyBatis Mapper XML 文件的位置。可以使用 Ant 风格的路径匹配。
        *   `classpath:` 表示从类路径下查找。
        *   `classpath*:` 表示从所有类路径下查找（包括依赖的 jar 包）。
        *   `**/` 表示任意层级的目录。
        *   例如：`classpath:mapper/**/*.xml` 会扫描 `src/main/resources/mapper/` 目录下（及其子目录）所有 `.xml` 文件。
    *   **`type-aliases-package`**: 指定实体类（POJO）所在的包。MyBatis 会自动为这个包下的类注册别名，别名为类名首字母小写（除非使用 `@Alias` 注解）。这样在 XML 中引用 Java 类型时可以直接用别名，如 `User` 而不是 `com.example.yourproject.model.User`。
    *   `config-location`: 如果你需要使用更高级的 MyBatis 配置（比如插件、自定义拦截器、更复杂的 `typeAliases` 或 `typeHandlers` 等），可以创建一个 `mybatis-config.xml` 文件，并在这里指定其路径。但很多配置项也可以通过 `mybatis.configuration.*` 在 `application.yml` 中完成。
    *   `configuration.map-underscore-to-camel-case`: 非常实用。当数据库表字段是下划线命名（如 `user_name`），而 Java 实体类属性是驼峰命名（如 `userName`）时，设置为 `true` 可以让 MyBatis 自动进行映射，无需在 `resultMap` 中手动指定 `column` 和 `property`。
    *   `configuration.log-impl`: 配置 MyBatis 使用的日志实现。Spring Boot 项目通常与 SLF4J 集成得很好，所以 `org.apache.ibatis.logging.slf4j.Slf4jImpl` 是一个好选择。如果未配置，MyBatis 会按顺序尝试加载并使用可用的日志库。

*   **`logging.level.*`**: 配置日志级别，对于调试 MyBatis 非常有用。将你的 Mapper 接口所在的包路径设置为 `DEBUG`，就可以在控制台看到 MyBatis 执行的 SQL 语句、参数以及影响的行数。`java.sql.PreparedStatement: DEBUG` 也可以看到预编译的 SQL 和绑定的参数。

#### 2.3 Mapper 接口与 XML 映射文件

MyBatis 的核心是 Mapper 接口和对应的 XML 映射文件（或者使用注解）。

**1. 创建实体类 (POJO - Plain Old Java Object)**

假设我们有一个 `User` 实体。

`src/main/java/com/example/yourproject/model/User.java`:

```java
package com.example.yourproject.model;

import java.io.Serializable;
import java.time.LocalDateTime;

// 建议实现 Serializable 接口，尤其是在使用缓存或分布式系统时
public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String username;
    private String email;
    private LocalDateTime createdAt;

    // Getters and Setters
    // (Lombok @Data 或 @Getter @Setter @ToString @NoArgsConstructor @AllArgsConstructor 也可以)
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    @Override
    public String toString() {
        return "User{" +
               "id=" + id +
               ", username='" + username + '\'' +
               ", email='" + email + '\'' +
               ", createdAt=" + createdAt +
               '}';
    }
}
```

**2. 创建 Mapper 接口**

Mapper 接口定义了数据操作的方法，不需要实现类，MyBatis 会通过动态代理自动生成实现。

`src/main/java/com/example/yourproject/mapper/UserMapper.java`:

```java
package com.example.yourproject.mapper;

import com.example.yourproject.model.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param; // 建议使用 @Param 处理多个参数

import java.util.List;

@Mapper // ① 标记这是一个 MyBatis Mapper 接口，Spring Boot 会扫描到它
public interface UserMapper {

    /**
     * 根据ID查询用户
     * @param id 用户ID
     * @return 用户对象，如果不存在则返回 null
     */
    User findById(Long id);

    /**
     * 查询所有用户
     * @return 用户列表
     */
    List<User> findAll();

    /**
     * 新增用户 (返回影响的行数)
     * @param user 用户对象
     * @return 影响的行数
     */
    int insertUser(User user);

    /**
     * 新增用户并返回自增主键 (需要特殊配置)
     * @param user 用户对象
     * @return 影响的行数
     */
    int insertUserAndGetId(User user);


    /**
     * 更新用户信息
     * @param user 用户对象
     * @return 影响的行数
     */
    int updateUser(User user);

    /**
     * 根据ID删除用户
     * @param id 用户ID
     * @return 影响的行数
     */
    int deleteUserById(Long id);

    /**
     * 根据用户名和邮箱查询用户 (示例多参数)
     * @param username 用户名
     * @param email 邮箱
     * @return 用户对象
     */
    User findByUsernameAndEmail(@Param("username") String username, @Param("email") String email);
}
```

**关键点：**

*   `@Mapper`: **非常重要**。这个注解告诉 Spring Boot 这是一个 MyBatis 的 Mapper 接口，需要被扫描并注册到 Spring 容器中。
    *   另一种方式是在启动类上使用 `@MapperScan("com.example.yourproject.mapper")` 来指定 Mapper 接口所在的包，这样 Mapper 接口上就不需要单独加 `@Mapper` 注解了。如果 Mapper 接口比较多，`@MapperScan` 更方便。
*   **方法签名**: 方法名可以任意取，但通常会与 XML 中的 `id` 对应。参数类型和返回类型需要与 SQL 语句和业务逻辑匹配。
*   `@Param`: 当 Mapper 方法有多个参数时，建议使用 `@Param("paramName")` 注解为每个参数指定一个名字。这样在 XML 中就可以通过 `#{paramName}` 来引用这个参数，避免了因参数顺序或数量变化导致的问题（尤其是在 Java 8 之前，参数名反射可能不准确）。如果只有一个简单类型参数（如 `Long id`）或一个 JavaBean 参数（如 `User user`），可以不加 `@Param`，MyBatis 会尝试自动匹配。

**3. 创建 Mapper XML 映射文件**

XML 文件包含了实际执行的 SQL 语句。通常，XML 文件的命名和路径会与 Mapper 接口对应，但这并非强制，关键是 `namespace` 要正确。

假设我们将 XML 文件放在 `src/main/resources/mapper/` 目录下。

`src/main/resources/mapper/UserMapper.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace 属性必须指向对应的 Mapper 接口的完全限定名 -->
<mapper namespace="com.example.yourproject.mapper.UserMapper">

    <!--
        resultMap 用于定义数据库列名与Java对象属性的映射关系。
        如果开启了 map-underscore-to-camel-case=true 且列名和属性名符合转换规则，
        简单的查询可以不显式定义 resultMap。
        但对于复杂映射、关联查询等，resultMap 非常有用。
    -->
    <resultMap id="BaseUserMap" type="com.example.yourproject.model.User">
        <!-- id 标签用于主键映射 -->
        <id column="id" property="id" jdbcType="BIGINT"/>
        <!-- result 标签用于普通列映射 -->
        <result column="username" property="username" jdbcType="VARCHAR"/>
        <result column="email" property="email" jdbcType="VARCHAR"/>
        <result column="created_at" property="createdAt" jdbcType="TIMESTAMP"/>
    </resultMap>

    <!-- id 属性必须与 Mapper 接口中的方法名一致 -->
    <!-- parameterType 可以省略, MyBatis 会自动推断 -->
    <!-- resultType 或 resultMap 指定返回结果的类型 -->
    <select id="findById" parameterType="long" resultMap="BaseUserMap">
        SELECT id, username, email, created_at
        FROM users
        WHERE id = #{id}
    </select>

    <select id="findAll" resultMap="BaseUserMap">
        SELECT id, username, email, created_at
        FROM users
        ORDER BY created_at DESC
    </select>

    <!--
        insert 标签
        useGeneratedKeys="true" 和 keyProperty="id" 用于获取数据库自增主键的值，并设置回传入的 User 对象的 id 属性。
        keyColumn (可选): 如果主键列名与 keyProperty 不一致时指定。
    -->
    <insert id="insertUser" parameterType="com.example.yourproject.model.User">
        INSERT INTO users (username, email, created_at)
        VALUES (#{username}, #{email}, #{createdAt})
    </insert>

    <insert id="insertUserAndGetId" parameterType="com.example.yourproject.model.User"
            useGeneratedKeys="true" keyProperty="id" keyColumn="id">
        INSERT INTO users (username, email, created_at)
        VALUES (#{username}, #{email}, #{createdAt})
    </insert>

    <update id="updateUser" parameterType="com.example.yourproject.model.User">
        UPDATE users
        SET username = #{username}, email = #{email}
        WHERE id = #{id}
    </update>

    <delete id="deleteUserById" parameterType="long">
        DELETE FROM users
        WHERE id = #{id}
    </delete>

    <select id="findByUsernameAndEmail" resultMap="BaseUserMap">
        SELECT id, username, email, created_at
        FROM users
        WHERE username = #{username} AND email = #{email}
        LIMIT 1
    </select>

</mapper>
```

**关键点：**

*   **DTD 声明**: XML 文件的开头必须有正确的 DTD 声明。
*   **`<mapper namespace="...">`**: `namespace` 属性的值**必须是与之绑定的 Mapper 接口的完全限定名** (例如 `com.example.yourproject.mapper.UserMapper`)。这是 MyBatis 将接口方法与 SQL 语句关联起来的关键。
*   **`<select>`, `<insert>`, `<update>`, `<delete>` 标签**:
    *   `id`: 必须与 Mapper 接口中对应的方法名一致。
    *   `parameterType`: 指定传入参数的类型。可以是基本类型、包装类型、JavaBean、Map，或者类型的别名。对于简单类型和 JavaBean，MyBatis 通常可以自动推断，所以此属性很多时候可以省略。
    *   `resultType`: 指定查询结果集映射成的 Java 类型（通常是实体类的完全限定名或别名）。用于简单的结果映射，当数据库列名与 Java 属性名一致（或通过 `map-underscore-to-camel-case` 自动转换）时使用。
    *   `resultMap`: 指向一个预先定义的 `<resultMap>` 的 `id`。用于更复杂的映射关系，比如列名与属性名不一致、关联查询、集合映射等。
*   **`#{paramName}`**: 这是 MyBatis 的参数占位符，表示一个**预编译参数 (PreparedStatement parameter)**。MyBatis 会使用 `?` 替换它，并安全地设置参数值，可以有效防止 SQL 注入。`paramName` 对应 Mapper 接口方法参数的名称（如果使用了 `@Param`，则对应 `@Param` 的值；如果是 JavaBean，则对应 JavaBean 的属性名）。
*   **`${paramName}`**: 这是**字符串替换**占位符。MyBatis 会直接将 `${paramName}` 替换为参数的值，**不进行预编译处理，存在 SQL 注入风险**，应谨慎使用。通常用于动态表名、列名、`ORDER BY` 子句等无法使用预编译参数的场景。
*   **`<resultMap>`**: 定义了数据库结果集的列如何映射到 Java 对象的属性。
    *   `id`: `resultMap` 的唯一标识。
    *   `type`: 目标 Java 类型的完全限定名或别名。
    *   `<id>`: 标记主键列的映射。
    *   `<result>`: 标记普通列的映射。
    *   `column`: 数据库表的列名。
    *   `property`: Java 对象的属性名。
    *   `jdbcType`: 数据库列的 JDBC 类型（可选，但有时有助于 MyBatis 进行正确的类型转换）。
*   **`useGeneratedKeys="true" keyProperty="id"` (用于 `insert`)**:
    *   `useGeneratedKeys="true"`: 告诉 MyBatis 这个 `insert` 语句会生成主键（通常是数据库自增 ID）。
    *   `keyProperty="id"`: 将生成的主键值设置回传入的参数对象（`User user`）的 `id` 属性。
    *   `keyColumn="id"` (可选): 如果数据库中主键列的名称与 `keyProperty` 指定的 Java 属性不一致，需要用此属性指定数据库中的主键列名。

**4. 在 Service 中使用 Mapper**

现在你可以在你的 Service 类中注入 `UserMapper` 并调用其方法了。

`src/main/java/com/example/yourproject/service/UserService.java`:

```java
package com.example.yourproject.service;

import com.example.yourproject.mapper.UserMapper;
import com.example.yourproject.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional; // 事务管理

import java.time.LocalDateTime;
import java.util.List;

@Service
public class UserService {

    private final UserMapper userMapper;

    @Autowired // 构造器注入
    public UserService(UserMapper userMapper) {
        this.userMapper = userMapper;
    }

    public User getUserById(Long id) {
        return userMapper.findById(id);
    }

    public List<User> getAllUsers() {
        return userMapper.findAll();
    }

    @Transactional // 开启事务
    public User createUser(String username, String email) {
        User user = new User();
        user.setUsername(username);
        user.setEmail(email);
        user.setCreatedAt(LocalDateTime.now());
        // userMapper.insertUser(user); // 不返回 ID
        userMapper.insertUserAndGetId(user); // 会将自增 ID 设置回 user 对象
        return user; // user 对象现在包含自增的 ID
    }

    @Transactional
    public int updateUserEmail(Long id, String newEmail) {
        User user = userMapper.findById(id);
        if (user != null) {
            user.setEmail(newEmail);
            return userMapper.updateUser(user);
        }
        return 0; // 或者抛出异常
    }

    @Transactional
    public int deleteUser(Long id) {
        return userMapper.deleteUserById(id);
    }

    public User findUserByCredentials(String username, String email) {
        return userMapper.findByUsernameAndEmail(username, email);
    }
}
```

**运行你的 Spring Boot 应用：**

确保你的数据库服务正在运行，并且数据库、表已创建。然后运行 Spring Boot 的主启动类。如果一切配置正确，你的应用就能通过 MyBatis 与数据库进行交互了。

至此，你就完成了 Spring Boot 与 MyBatis 的基本集成！

接下来，我们可以深入探讨 MyBatis 的核心功能，比如动态 SQL、高级结果映射、缓存等。