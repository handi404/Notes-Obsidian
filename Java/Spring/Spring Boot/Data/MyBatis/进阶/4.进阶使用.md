探讨 MyBatis 与 Spring Boot 的进阶使用。这些技巧可以帮助你更高效、更优雅地在 Spring Boot 项目中运用 MyBatis。

---

### 4. MyBatis 与 Spring Boot 进阶使用

#### 4.1 注解方式配置 SQL (替代 XML)

虽然 XML 映射文件是 MyBatis 的传统和强大特性，尤其适合复杂 SQL 和动态 SQL，但对于一些简单的 CRUD 操作，或者开发者更偏好将 SQL 与 Java 代码放在一起时，MyBatis 也支持使用注解来配置 SQL。

**核心注解：**

*   `@Select`: 用于配置查询 SQL。
*   `@Insert`: 用于配置插入 SQL。
*   `@Update`: 用于配置更新 SQL。
*   `@Delete`: 用于配置删除 SQL。
*   `@Options`: 用于配置一些额外的选项，如获取自增主键、指定缓存等。常与 `@Insert`, `@Update` 配合使用。
*   `@Result`: 用于单个列到属性的映射，相当于 XML 中的 `<result>`。
*   `@Results`: `@Result` 注解的集合，用于定义一个 `ResultMap`，相当于 XML 中的 `<resultMap>`。
*   `@ResultMap`: 引用在 XML 中定义的 `resultMap` 的 ID (注解也可以和 XML 混合使用)。
*   `@SelectProvider`, `@InsertProvider`, `@UpdateProvider`, `@DeleteProvider`: 用于构建动态 SQL。你需要提供一个类和一个方法，该方法返回要执行的 SQL 字符串。

**示例：**

`src/main/java/com/example/yourproject/mapper/UserAnnotationMapper.java`:

```java
package com.example.yourproject.mapper;

import com.example.yourproject.model.User;
import org.apache.ibatis.annotations.*; // 引入 MyBatis 注解

import java.util.List;

@Mapper // 确保被 Spring Boot 扫描到
public interface UserAnnotationMapper {

    @Select("SELECT id, username, email, created_at FROM users WHERE id = #{id}")
    @Results(id = "userResultMap", value = { // 定义一个 ResultMap, id 可以在其他地方引用
            @Result(property = "id", column = "id", id = true), // id=true 表示主键
            @Result(property = "username", column = "username"),
            @Result(property = "email", column = "email"),
            @Result(property = "createdAt", column = "created_at")
    })
    User findById(Long id);

    @Select("SELECT id, username, email, created_at FROM users")
    @ResultMap("userResultMap") // 引用上面定义的 userResultMap
    List<User> findAll();

    @Insert("INSERT INTO users(username, email, created_at) VALUES(#{username}, #{email}, #{createdAt})")
    @Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id") // 获取自增主键
    int insertUser(User user);

    @Update("UPDATE users SET username=#{username}, email=#{email} WHERE id=#{id}")
    int updateUser(User user);

    @Delete("DELETE FROM users WHERE id = #{id}")
    int deleteUserById(Long id);

    // 动态 SQL 示例 (使用 Provider)
    @SelectProvider(type = UserSqlProvider.class, method = "findActiveUsersByNameSql")
    @ResultMap("userResultMap")
    List<User> findActiveUsersByName(@Param("username") String username);

    // Provider 类 (通常是静态内部类或独立的类)
    class UserSqlProvider {
        public String findActiveUsersByNameSql(@Param("username") String username) {
            // 使用 MyBatis 内置的 SQL 构建器，更推荐
            return new org.apache.ibatis.jdbc.SQL() {{
                SELECT("id, username, email, created_at");
                FROM("users");
                WHERE("status = 'ACTIVE'");
                if (username != null && !username.isEmpty()) {
                    AND().WHERE("username LIKE CONCAT('%', #{username}, '%')");
                }
            }}.toString();

            // 或者手动拼接 (注意 SQL 注入风险，但这里参数是安全的)
            // StringBuilder sql = new StringBuilder("SELECT id, username, email, created_at FROM users WHERE status = 'ACTIVE'");
            // if (username != null && !username.isEmpty()) {
            //     sql.append(" AND username LIKE CONCAT('%', #{username}, '%')");
            // }
            // return sql.toString();
        }
    }
}
```

**注解 vs XML：**

*   **注解优点：**
    *   对于简单 SQL，更简洁，代码更集中。
    *   IDE 通常能更好地支持 Java 注解的导航和重构。
*   **注解缺点：**
    *   **复杂的动态 SQL 非常不方便**：虽然有 `@...Provider`，但编写和维护起来比 XML 中的动态 SQL 标签（如 `<if>`, `<foreach>`）要繁琐得多。SQL 和 Java 代码耦合更紧。
    *   **SQL 可读性和维护性下降**：当 SQL 语句很长或很复杂时，写在注解里会非常难看，也不利于 DBA 或 SQL 专家进行审查和优化。
    *   **功能受限**：一些高级的 XML 特性（如 `<cache-ref>` 引用其他命名空间的缓存配置）在注解中可能没有直接对应。
*   **Spring Boot 中的配置**：
    *   如果只使用注解，理论上可以不配置 `mybatis.mapper-locations`。
    *   但通常项目会混合使用，XML 用于复杂 SQL，注解用于简单 SQL。所以 `mapper-locations` 还是建议配置。

**最佳实践：**

*   **简单 CRUD 或固定查询**：可以使用注解，快速方便。
*   **复杂查询、动态 SQL、需要精细控制的 SQL**：强烈建议使用 XML 映射文件。
*   **一致性**：团队内部最好统一风格，或者明确何时使用注解，何时使用 XML。
*   **Provider 类中的 SQL 构建**：推荐使用 MyBatis 提供的 `org.apache.ibatis.jdbc.SQL` 工具类来构建 SQL，它比手动拼接字符串更安全、更易读。

---

#### 4.2 Type Handlers (自定义类型处理器)

Type Handler 用于在 Java 类型和 JDBC 类型之间进行转换。MyBatis 内置了许多标准的 Type Handler (如 `StringTypeHandler`, `IntegerTypeHandler`, `DateTypeHandler` 等)。但有时你需要处理一些特殊的类型转换，比如：

*   Java `enum` 类型与数据库中的 `VARCHAR` 或 `INT` 类型的映射。
*   将 Java 对象（如 `List<String>` 或自定义对象）存储为数据库中的单个字段（如 JSON 字符串、逗号分隔字符串）。
*   处理数据库特有的数据类型。

**如何创建 Type Handler：**

1.  实现 `org.apache.ibatis.type.TypeHandler` 接口，或者更方便地继承 `org.apache.ibatis.type.BaseTypeHandler<T>` (其中 `T` 是你的 Java 类型)。
2.  实现四个核心方法：
    *   `setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType)`: 将 Java 类型转换为 JDBC 类型，并设置到 `PreparedStatement`。
    *   `getNullableResult(ResultSet rs, String columnName)`: 从 `ResultSet` 按列名获取数据，并转换为 Java 类型。
    *   `getNullableResult(ResultSet rs, int columnIndex)`: 从 `ResultSet` 按列索引获取数据，并转换为 Java 类型。
    *   `getNullableResult(CallableStatement cs, int columnIndex)`: 从 `CallableStatement` 获取数据，并转换为 Java 类型。

**示例：将 Java `List<String>` 存储为数据库 `VARCHAR` (逗号分隔)：**

`src/main/java/com/example/yourproject/typehandler/StringListTypeHandler.java`:

```java
package com.example.yourproject.typehandler;

import org.apache.ibatis.type.BaseTypeHandler;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.MappedJdbcTypes;
import org.apache.ibatis.type.MappedTypes;
import org.springframework.util.StringUtils; // Spring Framework utility

import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

// @MappedJdbcTypes 指定对应的 JDBC 类型 (可选, 但推荐)
@MappedJdbcTypes(JdbcType.VARCHAR)
// @MappedTypes 指定此 Handler 适用的 Java 类型 (可选, 主要用于自动扫描注册时)
@MappedTypes(List.class)
public class StringListTypeHandler extends BaseTypeHandler<List<String>> {

    private static final String SEPARATOR = ",";

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, List<String> parameter, JdbcType jdbcType) throws SQLException {
        // 将 List<String> 转换为逗号分隔的字符串
        String joinedString = parameter.stream().collect(Collectors.joining(SEPARATOR));
        ps.setString(i, joinedString);
    }

    @Override
    public List<String> getNullableResult(ResultSet rs, String columnName) throws SQLException {
        String columnValue = rs.getString(columnName);
        return parseStringToList(columnValue);
    }

    @Override
    public List<String> getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        String columnValue = rs.getString(columnIndex);
        return parseStringToList(columnValue);
    }

    @Override
    public List<String> getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        String columnValue = cs.getString(columnIndex);
        return parseStringToList(columnValue);
    }

    private List<String> parseStringToList(String columnValue) {
        if (columnValue == null || columnValue.isEmpty()) {
            return Collections.emptyList();
        }
        return Arrays.asList(StringUtils.delimitedListToStringArray(columnValue, SEPARATOR));
    }
}
```

**注册 Type Handler：**

1.  **XML 配置 (`mybatis-config.xml`)**:
    ```xml
    <typeHandlers>
        <typeHandler handler="com.example.yourproject.typehandler.StringListTypeHandler"/>
        <!-- 如果 BaseTypeHandler 的泛型或 @MappedTypes 指定了 Java 类型，可以不指定 javaType -->
        <!-- <typeHandler javaType="java.util.List" jdbcType="VARCHAR" handler="com.example.yourproject.typehandler.StringListTypeHandler"/> -->
    </typeHandlers>
    ```

2.  **Spring Boot 自动扫描 (推荐)**:
    *   在 `application.yml` 中配置 `type-handlers-package`：
        ```yaml
        mybatis:
          type-handlers-package: com.example.yourproject.typehandler # MyBatis 会扫描此包下的 TypeHandler
          # ...
        ```
    *   确保 Type Handler 类上有 `@MappedJdbcTypes` 和/或 `@MappedTypes` 注解，MyBatis Starter 会自动注册它们。

3.  **Java Config (`ConfigurationCustomizer`)**:
    ```java
    @Configuration
    public class MyBatisTypeHandlerConfig {
        @Bean
        public ConfigurationCustomizer mybatisConfigurationCustomizer() {
            return configuration -> {
                configuration.getTypeHandlerRegistry().register(com.example.yourproject.typehandler.StringListTypeHandler.class);
                // 或者更精确地指定 Java 类型和 JDBC 类型
                // configuration.getTypeHandlerRegistry().register(java.util.List.class, org.apache.ibatis.type.JdbcType.VARCHAR, new StringListTypeHandler());
            };
        }
    }
    ```

**在 Mapper 中使用：**

一旦注册，MyBatis 会在进行类型转换时自动使用匹配的 Type Handler。
你也可以在 `<result>` 或参数中显式指定：
```xml
<result property="tags" column="tag_string" typeHandler="com.example.yourproject.typehandler.StringListTypeHandler"/>
<!-- 或者 -->
<result property="tags" column="tag_string" javaType="java.util.List" jdbcType="VARCHAR"/> <!-- MyBatis 会尝试找到匹配的 Handler -->

<!-- 参数 -->
<!-- INSERT INTO articles (title, tags) VALUES (#{title}, #{tags, typeHandler=com.example.yourproject.typehandler.StringListTypeHandler}) -->
```

---

#### 4.3 `RowBounds` 与 `PageHelper` 分页

MyBatis 本身提供了基于 `RowBounds` 的**逻辑分页**（内存分页），但更常用且推荐的是使用**物理分页**插件，如 `PageHelper`。

1.  **`RowBounds` (逻辑分页)**:
    *   `RowBounds` 对象作为参数传递给 `select` 方法。它有两个参数：`offset` (起始行，从0开始) 和 `limit` (返回的行数)。
    *   **原理**：MyBatis 仍然会查询出**所有**结果集，然后在内存中根据 `offset` 和 `limit` 进行截取。
    *   **缺点**：对于大数据量，性能极差，因为所有数据都被加载到内存中。**不推荐用于生产环境的大数据量分页。**
    *   **使用**:
        ```java
        // Mapper 接口
        List<User> findAllWithRowBounds(RowBounds rowBounds);
        // XML (不需要特殊处理)
        // <select id="findAllWithRowBounds" resultType="User"> SELECT * FROM users </select>
        // Service 调用
        // RowBounds rowBounds = new RowBounds(10, 5); // 从第11条开始，取5条
        // List<User> users = userMapper.findAllWithRowBounds(rowBounds);
        ```

2.  **`PageHelper` (物理分页插件 - 推荐)**:
    *   `PageHelper` 是一个非常流行的第三方 MyBatis 分页插件，它实现了**物理分页**。
    *   **原理**：它会拦截 SQL 执行，并根据不同的数据库类型，自动在原始 SQL 外层包装上分页查询语句 (如 MySQL 的 `LIMIT`, Oracle 的 `ROWNUM` 等)。只从数据库查询需要的数据页。
    *   **优点**：性能高，对业务代码侵入小。
    *   **使用步骤**:
        1.  **添加依赖 (`pom.xml`)**:
            ```xml
            <dependency>
                <groupId>com.github.pagehelper</groupId>
                <artifactId>pagehelper-spring-boot-starter</artifactId>
                <version>1.4.7</version> <!-- 请使用最新稳定版 -->
            </dependency>
            ```
            `pagehelper-spring-boot-starter` 会自动引入 `pagehelper` 并进行配置。

        2.  **配置 (`application.yml`)** (starter 会自动配置，但可以自定义):
            ```yaml
            pagehelper:
              # helper-dialect: mysql # 数据库方言，通常 PageHelper 能自动检测
              # reasonable: true     # 启用合理化时，如果 pageNum < 1 会查询第一页，如果 pageNum > pages 会查询最后一页。默认false。
              # support-methods-arguments: true # 支持通过 Mapper 接口参数来传递分页参数。默认false。
              # params: count=countSql # 用于从PageRowBounds中取出countSql不过度使用map作为查询参数时，可以使用该配置。
              # default-count: true # 是否在每次分页查询时执行 count 查询，获取总记录数。默认true。
              # auto-runtime-dialect: true # 运行时自动识别数据库方言
            ```

        3.  **在 Service 中使用**:
            ```java
            import com.github.pagehelper.PageHelper;
            import com.github.pagehelper.PageInfo; // 封装分页信息
            import org.springframework.stereotype.Service;
            // ...

            @Service
            public class UserService {
                @Autowired
                private UserMapper userMapper; // 假设 UserMapper 有一个 findAll 方法

                public PageInfo<User> findUsersByPage(int pageNum, int pageSize) {
                    // 1. 在执行 MyBatis 查询之前，调用 PageHelper.startPage
                    // 这行代码必须紧跟在真正的查询方法调用之前，且只对接下来执行的第一个 MyBatis 查询有效 (线程绑定)
                    PageHelper.startPage(pageNum, pageSize);
                    // PageHelper.startPage(pageNum, pageSize, "created_at desc"); // 也可以在这里指定排序

                    // 2. 执行正常的 MyBatis 查询
                    List<User> userList = userMapper.findAll(); // 这个 findAll 不需要任何特殊分页参数

                    // 3. 用 PageInfo 包装查询结果，PageInfo 包含了分页信息 (总记录数, 总页数, 当前页数据等)
                    // PageInfo.of(userList);
                    PageInfo<User> pageInfo = new PageInfo<>(userList);
                    return pageInfo;
                }

                // 如果需要更复杂的排序
                public PageInfo<User> findUsersByPageWithOrderBy(int pageNum, int pageSize, String orderBy) {
                    PageHelper.startPage(pageNum, pageSize).setOrderBy(orderBy); // "id asc, username desc"
                    List<User> userList = userMapper.findAll();
                    return new PageInfo<>(userList);
                }
            }
            ```
            **Controller 返回示例**:
            ```java
            @GetMapping("/users/paged")
            public ResponseEntity<PageInfo<User>> getUsersPaged(
                    @RequestParam(defaultValue = "1") int pageNum,
                    @RequestParam(defaultValue = "10") int pageSize) {
                PageInfo<User> userPage = userService.findUsersByPage(pageNum, pageSize);
                return ResponseEntity.ok(userPage);
            }
            ```
            `PageInfo` 对象包含了丰富的分页信息，如：
            *   `pageNum`: 当前页码
            *   `pageSize`: 每页数量
            *   `total`: 总记录数
            *   `pages`: 总页数
            *   `list`: 当前页的数据列表
            *   `isFirstPage`, `isLastPage`, `hasPreviousPage`, `hasNextPage` 等。

    *   **注意事项**:
        *   `PageHelper.startPage()` 只对紧随其后的**第一个**MyBatis 查询有效。
        *   确保 `PageHelper.startPage()` 在同一个线程中，在 DAO/Mapper 调用之前。
        *   避免在 `PageHelper.startPage()` 和实际查询之间执行其他数据库操作，这可能导致 `PageHelper` 失效或作用于错误的查询。
        *   如果查询结果被 MyBatis 的二级缓存命中，`PageHelper` 可能不会执行 count 查询，除非配置了强制 count。

---

#### 4.4 多数据源配置

在一些复杂应用中，可能需要连接和操作多个数据库。Spring Boot 结合 MyBatis 可以实现多数据源的配置。

**核心思路：**

1.  配置多个 `DataSource` Bean。
2.  为每个 `DataSource` 配置一个对应的 `SqlSessionFactory` Bean。
3.  为每个 `SqlSessionFactory` 配置一个对应的 `SqlSessionTemplate` Bean (或直接使用 `MapperFactoryBean` 指定 `sqlSessionFactory`)。
4.  指定不同的 Mapper 接口扫描路径，或者使用不同的注解来区分 Mapper 应该使用哪个 `SqlSessionFactory`。

**示例 (使用 `AbstractRoutingDataSource` 是一种更动态的方式，但这里先展示基础的多个固定数据源配置):**

**1. `application.yml` 配置多个数据源属性：**

```yaml
spring:
  # --- 主数据源 (Primary DataSource) ---
  datasource:
    primary: # 自定义前缀
      jdbc-url: jdbc:mysql://localhost:3306/db_primary?useUnicode=true&characterEncoding=utf-8
      username: root_primary
      password: pass_primary
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        pool-name: PrimaryHikariPool
        maximum-pool-size: 10
  # --- 次数据源 (Secondary DataSource) ---
    secondary: # 自定义前缀
      jdbc-url: jdbc:mysql://localhost:3307/db_secondary?useUnicode=true&characterEncoding=utf-8
      username: root_secondary
      password: pass_secondary
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        pool-name: SecondaryHikariPool
        maximum-pool-size: 5

# MyBatis 配置也可以针对不同数据源进行分组，但 SqlSessionFactory 的配置更关键
mybatis:
  # 通用配置 (如果某些配置是共享的)
  configuration:
    map-underscore-to-camel-case: true
  # 主要的 mapper-locations 和 type-aliases-package 可以在各自的 SqlSessionFactory 配置中指定
  # 或者在这里指定，然后在 Java Config 中细化
  # mapper-locations: classpath:mapper/**/*.xml
  # type-aliases-package: com.example.model
```

**2. Java Config 创建数据源、SqlSessionFactory、SqlSessionTemplate/MapperScannerConfigurer：**

```java
package com.example.yourproject.config;

import com.zaxxer.hikari.HikariDataSource;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;

import javax.sql.DataSource;

@Configuration
public class DataSourceConfig {

    // === 主数据源配置 ===
    @Primary // 标记为主数据源，当不指定时默认使用它
    @Bean(name = "primaryDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.primary") // 绑定 yml 中的属性
    public DataSource primaryDataSource() {
        // 使用 DataSourceBuilder 创建，Spring Boot 推荐方式，可以自动适配 HikariCP 等
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    }

    @Primary
    @Bean(name = "primarySqlSessionFactory")
    public SqlSessionFactory primarySqlSessionFactory(@Qualifier("primaryDataSource") DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        // 指定主数据源的 Mapper XML 文件位置
        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/primary/**/*.xml"));
        // 指定主数据源的实体类别名扫描包
        sessionFactory.setTypeAliasesPackage("com.example.yourproject.model.primary"); // 如果实体类也分开
        // (可选) 加载 MyBatis 全局配置文件
        // sessionFactory.setConfigLocation(new PathMatchingResourcePatternResolver().getResource("classpath:mybatis-config-primary.xml"));
        
        // (可选) 配置MyBatis的Configuration对象
        // org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        // configuration.setMapUnderscoreToCamelCase(true);
        // sessionFactory.setConfiguration(configuration);

        return sessionFactory.getObject();
    }

    @Primary
    @Bean(name = "primaryTransactionManager")
    public DataSourceTransactionManager primaryTransactionManager(@Qualifier("primaryDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    @Primary
    @Bean(name = "primarySqlSessionTemplate")
    public SqlSessionTemplate primarySqlSessionTemplate(@Qualifier("primarySqlSessionFactory") SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }

    // === 次数据源配置 ===
    @Bean(name = "secondaryDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    }

    @Bean(name = "secondarySqlSessionFactory")
    public SqlSessionFactory secondarySqlSessionFactory(@Qualifier("secondaryDataSource") DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/secondary/**/*.xml"));
        sessionFactory.setTypeAliasesPackage("com.example.yourproject.model.secondary");
        return sessionFactory.getObject();
    }

    @Bean(name = "secondaryTransactionManager")
    public DataSourceTransactionManager secondaryTransactionManager(@Qualifier("secondaryDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    @Bean(name = "secondarySqlSessionTemplate")
    public SqlSessionTemplate secondarySqlSessionTemplate(@Qualifier("secondarySqlSessionFactory") SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}

// === Mapper 接口扫描配置 ===
// 扫描主数据源的 Mapper
@Configuration
@MapperScan(basePackages = "com.example.yourproject.mapper.primary", // 主数据源 Mapper 接口包
            sqlSessionFactoryRef = "primarySqlSessionFactory", // 指定使用哪个 SqlSessionFactory
            sqlSessionTemplateRef = "primarySqlSessionTemplate") // 或者指定 SqlSessionTemplate
public class PrimaryMapperConfig {
}

// 扫描次数据源的 Mapper
@Configuration
@MapperScan(basePackages = "com.example.yourproject.mapper.secondary", // 次数据源 Mapper 接口包
            sqlSessionFactoryRef = "secondarySqlSessionFactory",
            sqlSessionTemplateRef = "secondarySqlSessionTemplate")
public class SecondaryMapperConfig {
}
```

**使用：**

*   将对应数据源的 Mapper 接口放在各自的 `basePackages` 下。
*   在 Service 中注入相应的 Mapper 即可。

**事务管理**：
对于多数据源的事务，如果事务操作只涉及单个数据源，那么使用对应数据源的 `DataSourceTransactionManager` 即可（通过 `@Transactional("primaryTransactionManager")` 或 `@Transactional("secondaryTransactionManager")` 指定）。

如果需要**跨多个数据源的分布式事务**，情况会复杂得多，需要引入 JTA 事务管理器 (如 Atomikos, Narayana)，并相应配置。这超出了 MyBatis 本身的范畴，更多是 Spring 事务管理和 JTA 的内容。

**动态数据源切换 (Dynamic DataSource Routing)**:
对于更灵活的场景，比如根据当前用户、租户或方法注解来动态切换数据源，可以使用 Spring提供的 `AbstractRoutingDataSource`。
1.  创建一个 `RoutingDataSource extends AbstractRoutingDataSource`。
2.  重写 `determineCurrentLookupKey()` 方法，返回一个用于查找实际数据源的 key。
3.  使用 AOP 或其他机制，在方法调用前设置这个 key (通常通过 `ThreadLocal`)。
4.  配置一个 `SqlSessionFactory` 使用这个 `RoutingDataSource`。
这种方式更为高级和灵活，但配置也更复杂。

---

#### 4.5 事务管理 (与 Spring `@Transactional` 协同工作)

MyBatis 本身有自己的事务管理API (`SqlSession.commit()`, `SqlSession.rollback()`)，但在与 Spring Boot 集成时，我们**强烈推荐使用 Spring 的声明式事务管理 (`@Transactional`)**。

**`mybatis-spring-boot-starter` 的作用：**

*   它会自动配置一个 `DataSourceTransactionManager` (如果项目中只有一个数据源，并且没有其他事务管理器)。
*   它会确保 MyBatis 的 `SqlSession` 参与到 Spring 管理的事务中。当 Spring 事务提交时，`SqlSession` 会被提交；回滚时，`SqlSession` 也会回滚。

**如何使用：**

就像我们之前讨论事务时提到的，在你的 Service 层方法上添加 `@Transactional` 注解即可。

```java
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
// ...

@Service
public class OrderService {
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private StockMapper stockMapper; // 假设这是另一个 Mapper

    @Transactional // 使用 Spring 的事务注解
    public void placeOrder(Order order, StockItem stockItem) {
        // 1. 创建订单 (orderMapper 操作)
        orderMapper.insertOrder(order);

        // 2. 更新库存 (stockMapper 操作)
        int updatedRows = stockMapper.decreaseStock(stockItem.getProductId(), stockItem.getQuantity());
        if (updatedRows == 0) {
            throw new RuntimeException("库存不足，下单失败！"); // 抛出运行时异常，Spring 事务会回滚
        }
        // 如果一切顺利，方法结束时，Spring 事务会自动提交
        // orderMapper 和 stockMapper 的操作会在同一个事务中
    }

    // 只读事务优化
    @Transactional(readOnly = true)
    public Order getOrderDetails(Long orderId) {
        return orderMapper.findById(orderId);
    }

    // 指定特定事务管理器 (用于多数据源场景)
    // 假设 orderMapper 使用 primaryTransactionManager, paymentMapper 使用 paymentTransactionManager
    // @Transactional("primaryTransactionManager") // 如果 OrderService 只操作主数据源
    // public void createPrimaryOrder(...) {}
}
```

**关键点：**

*   **Service 层**: `@Transactional` 通常应用在 Service 层方法上，这些方法封装了业务逻辑，可能涉及多个 Mapper 操作。
*   **传播行为 (Propagation)**: 理解 `@Transactional` 的 `propagation` 属性（如 `REQUIRED`, `REQUIRES_NEW`）对于控制事务边界非常重要，尤其是在 Service 方法相互调用时。
*   **回滚规则 (Rollback Rules)**: 默认情况下，Spring 只对 `RuntimeException` 和 `Error` 进行回滚。对于受检异常 (Checked Exception)，如果需要回滚，需使用 `rollbackFor` 属性。
*   **多数据源事务**:
    *   如果事务只涉及**单个数据源**，在 `@Transactional` 注解中指定对应的 `transactionManager` Bean 名称即可 (如 `@Transactional("secondaryTransactionManager")`)。
    *   如果事务需要跨越**多个数据源**并保证 ACID，就需要使用**分布式事务 (JTA)**。Spring Boot 支持集成 JTA 事务管理器如 Atomikos 或 Narayana。你需要添加相应的 starter (如 `spring-boot-starter-jta-atomikos`)，并进行配置。MyBatis 会自动参与 JTA 事务。JTA 事务通常性能开销较大，且配置复杂，应谨慎评估。微服务架构中更倾向于使用 Saga、事件驱动等最终一致性方案。

**总结：**
在 Spring Boot + MyBatis 环境中，Spring 的声明式事务管理是首选。`mybatis-spring-boot-starter` 已经很好地处理了 MyBatis `SqlSession` 与 Spring 事务的集成，开发者只需关注在 Service 层正确使用 `@Transactional` 注解即可。

---

这些进阶主题希望能帮助你更深入地理解和运用 MyBatis。MyBatis 的灵活性和对 SQL 的控制力使其在很多场景下依然是优秀的选择。