### 高级主题一：处理复杂的泛型与多态 DTO

当 API 的数据模型变得复杂时，如何确保文档依然精确、易懂，是衡量文档质量的重要标准。

#### 1. 泛型 DTO (Generic DTOs)

**场景**: 在现代后端开发中，我们经常会创建统一的响应包装类，例如 `Result<T>` 或 `ApiResponse<T>`，用来包裹实际的业务数据。

```java
// 一个通用的响应包装类
@Schema(description = "通用 API 响应体")
public class ApiResponse<T> {
    @Schema(description = "状态码", example = "200")
    private int code;
    @Schema(description = "响应消息", example = "操作成功")
    private String message;
    @Schema(description = "业务数据")
    private T data;
    // Getters and Setters...
}
```

**问题**: 如果一个接口返回 `ApiResponse<User>`，另一个返回 `ApiResponse<Product>`，`springdoc` 如何知道 `data` 字段的具体类型是 `User` 还是 `Product`？

**解决方案**: `springdoc-openapi` 非常智能，在大多数情况下，**它能通过分析 Controller 方法的返回类型自动推断出泛型的具体类型**。

**Controller 示例**:
```java
@RestController
@Tag(name = "泛型处理示例")
public class GenericController {

    @Operation(summary = "获取用户信息（使用泛型包装）")
    @GetMapping("/generic/user")
    public ApiResponse<User> getUser() {
        User user = new User(1L, "Alice");
        return new ApiResponse<>(200, "Success", user);
    }

    @Operation(summary = "获取产品信息（使用泛型包装）")
    @GetMapping("/generic/product")
    public ApiResponse<Product> getProduct() {
        Product product = new Product("P001", "Laptop");
        return new ApiResponse<>(200, "Success", product);
    }

    // --- DTOs ---
    @Schema(name="UserDTO", description = "用户信息") record User(Long id, String name) {}
    @Schema(name="ProductDTO", description = "产品信息") record Product(String sku, String name) {}
}
```

**效果**:
*   当你查看 `/generic/user` 接口的文档时，Swagger UI 会正确地显示其响应体 `data` 字段的结构是 `UserDTO`。
*   当你查看 `/generic/product` 接口的文档时，`data` 字段的结构则会显示为 `ProductDTO`。

> **要点/注意事项**:
> *   **自动推断是首选**: 相信 `springdoc` 的能力。只有当自动推断失效时（例如，在极其复杂的嵌套泛型或类型擦除边界情况下），才需要手动干预。
> *   **手动干预方式**: 如果需要覆盖或明确指定，可以在 `@ApiResponse` 中使用 `@Content` 和 `@Schema` 来强制指定实现类，但这在现代 `springdoc` 版本中已很少需要。

---

#### 2. 多态 DTO (Polymorphic DTOs)

**场景**: 假设你有一个接口，它可能返回多种不同类型的对象，这些对象都继承自同一个基类。例如，一个 `/pets` 接口可能返回一个 `Pet` 列表，其中包含 `Dog` 对象和 `Cat` 对象。

**问题**: 文档需要清晰地告诉前端，`Pet` 这个基类具体有哪些可能的子类型，以及每种自类型的具体字段是什么。

**解决方案**: 结合使用 Jackson 的多态注解 (`@JsonTypeInfo`, `@JsonSubTypes`) 和 OpenAPI 的 `@Schema` 注解。`springdoc` 会无缝集成这两者。

**核心思想**:
1.  在基类中，使用 `@JsonTypeInfo` 告诉 Jackson 如何在 JSON 中嵌入类型信息（通常是增加一个额外的字段，如 `"petType": "dog"`）。
2.  在基类中，使用 `@Schema` 的 `discriminatorProperty` 和 `oneOf` (或 `anyOf`) 属性来向 OpenAPI 描述这种多态关系。

**代码示例**:

**1. 定义基类和子类**
```java
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import io.swagger.v3.oas.annotations.media.Schema;

@Schema(
    description = "宠物基类",
    // 关键：声明判别器属性
    discriminatorProperty = "petType",
    // 关键：列出所有可能的子类实现
    oneOf = {Dog.class, Cat.class}
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "petType")
@JsonSubTypes({
    @JsonSubTypes.Type(value = Dog.class, name = "dog"),
    @JsonSubTypes.Type(value = Cat.class, name = "cat")
})
public abstract class Pet {
    @Schema(description = "宠物名称")
    public String name;
}

@Schema(description = "狗狗")
public class Dog extends Pet {
    @Schema(description = "吠叫音量（分贝）", example = "80")
    public double barkVolume;
}

@Schema(description = "猫咪")
public class Cat extends Pet {
    @Schema(description = "是否喜欢抓沙发", example = "true")
    public boolean likesScratching;
}
```

**2. 在 Controller 中使用**
```java
@RestController
@Tag(name = "多态处理示例")
public class PolymorphicController {

    @Operation(summary = "获取所有宠物")
    @GetMapping("/pets")
    public List<Pet> getAllPets() {
        Dog dog = new Dog();
        dog.name = "旺财";
        dog.barkVolume = 85.5;

        Cat cat = new Cat();
        cat.name = "咪咪";
        cat.likesScratching = true;

        return List.of(dog, cat);
    }
}
```
**效果**:
在 Swagger UI 中查看 `/pets` 接口的响应体时：
*   你会看到 `Pet` 模型。
*   在 `Pet` 模型的描述旁边，会出现一个下拉菜单，允许你选择查看 `Dog` 或 `Cat` 的具体 Schema。
*   请求和响应示例中，会根据你选择的子类型，展示带有 `petType` 字段（如 `"petType": "dog"`）的正确 JSON 结构。

这为调用者提供了极其清晰和准确的接口信息，完美解决了多态带来的文档模糊性问题。

---

### 高级主题二：API 分组 (Grouping)

**场景**: 一个大型单体应用可能包含多组完全不同的 API，例如：
*   面向最终用户的 Public API (`/api/v1/...`)
*   面向内部管理后台的 Admin API (`/admin/api/...`)
*   面向第三方合作伙伴的 Partner API (`/partner/v1/...`)

你希望在同一个项目中为它们生成**不同**的、可独立访问的 API 文档。

**解决方案**: 使用 `GroupedOpenApi` Bean 进行编程式分组。这是最灵活、最推荐的现代方式。

**步骤**:

1.  创建一个 `@Configuration` 配置类。
2.  在类中，为每个你想要创建的 API 组定义一个返回 `GroupedOpenApi` 类型的 `@Bean`。

**代码示例**:
```java
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiGroupingConfig {

    @Bean
    public GroupedOpenApi publicApi() {
        return GroupedOpenApi.builder()
                .group("1-public-api") // 组名，会出现在 URL 和 UI 下拉列表中
                .pathsToMatch("/api/v1/**") // 匹配此组的路径规则
                .displayName("前台用户 API") // 在 UI 下拉列表中显示的名称
                .build();
    }

    @Bean
    public GroupedOpenApi adminApi() {
        return GroupedOpenApi.builder()
                .group("2-admin-api")
                .pathsToMatch("/admin/api/**")
                .packagesToScan("com.example.myapp.admin") // 也可以按包名匹配
                .displayName("后台管理 API")
                .build();
    }
}
```

**效果**:
1.  **独立的文档端点**:
    *   Public API 的 JSON 文档: `http://localhost:8080/v3/api-docs/1-public-api`
    *   Admin API 的 JSON 文档: `http://localhost:8080/v3/api-docs/2-admin-api`
2.  **统一的 UI 入口**:
    *   访问 `http://localhost:8080/swagger-ui.html`。
    *   在页面的右上角，你会看到一个下拉选择框。
    *   你可以在这个下拉框中自由切换查看 "前台用户 API" 和 "后台管理 API" 的文档。

> **要点/注意事项**:
> *   `GroupedOpenApi.builder()` 提供了多种分组方式：`pathsToMatch`, `pathsToExclude`, `packagesToScan`, `packagesToExclude` 等，可以灵活组合使用。
> *   分组是管理复杂项目 API 文档的必备技能。

---

### 高级主题三：微服务架构中的 API 文档聚合

**场景**: 在微服务架构中，每个服务（如用户服务、订单服务）都各自暴露自己的 API 和 OpenAPI 文档。如何提供一个统一的入口，让开发者能在一个地方浏览所有服务的 API 文档？

**解决方案**: 利用 **API 网关 (如 Spring Cloud Gateway)** 进行文档聚合。

**架构图**:
```
                      +-------------------------+
Browser/Developer ->  |      API Gateway        | -> (路由) -> Microservice A
                      | (Swagger UI Aggregator) | -> (路由) -> Microservice B
                      +-------------------------+            -> ...
```

**核心思想**:
1.  每个下游微服务（A, B, ...）都独立集成 `springdoc-openapi`，并暴露自己的 `/v3/api-docs` 端点。
2.  API 网关也集成 `springdoc-openapi-starter-webflux-ui`。
3.  在 API 网关的配置文件中，配置 `springdoc.swagger-ui.urls` 属性，告诉网关的 Swagger UI 去哪里拉取下游服务的文档定义。

**实施步骤**:

**1. 下游微服务 (例如 `user-service`)**
*   正常添加 `springdoc-openapi-starter-webmvc-ui` 依赖。
*   正常编写 Controller。
*   确保 `http://user-service-host:port/v3/api-docs` 可以访问。

**2. API 网关 (使用 Spring Cloud Gateway)**
*   **添加依赖**:
    ```xml
    <dependency>
        <groupId>org.springdoc</groupId>
        <!-- 注意是 webflux，因为 Spring Cloud Gateway 是基于 WebFlux 的 -->
        <artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
        <version>2.5.0</version>
    </dependency>
    ```
*   **配置 `application.yml`**:
    ```yaml
    spring:
      application:
        name: api-gateway
      cloud:
        gateway:
          routes:
            # 路由到用户服务
            - id: user-service-route
              uri: lb://user-service # lb 表示使用负载均衡
              predicates:
                - Path=/user-api/**
              filters:
                - StripPrefix=1
            # 路由到订单服务
            - id: order-service-route
              uri: lb://order-service
              predicates:
                - Path=/order-api/**
              filters:
                - StripPrefix=1

    # springdoc 聚合配置 (核心)
    springdoc:
      swagger-ui:
        # 不自动发现，我们手动定义
        disable-openapi-default-url: true
        urls:
          - name: 用户服务 (User Service) # 在 UI 下拉列表中显示的名字
            url: /user-api/v3/api-docs # 网关路由到 user-service 的 /v3/api-docs
          - name: 订单服务 (Order Service)
            url: /order-api/v3/api-docs
          # 如果服务注册了上下文路径(context-path)，要加上
          # url: /user-api/user-service-context-path/v3/api-docs
    ```
**效果**:
*   启动所有微服务和 API 网关。
*   访问 API 网关的 Swagger UI 地址: `http://gateway-host:port/swagger-ui.html`。
*   你会看到一个和 API 分组时类似的下拉选择框。
*   在这个下拉框中，你可以选择 "用户服务" 或 "订单服务"，UI 会动态加载并显示对应服务的 API 文档。