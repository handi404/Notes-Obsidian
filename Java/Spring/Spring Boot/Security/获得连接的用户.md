这是一个非常实际且常用的需求。当你的端点（Endpoint，通常指 Controller 中的一个处理方法）被 Spring Security 保护起来后，意味着在执行你的业务逻辑之前，用户已经成功通过了认证。这时，你自然希望能够获取到当前登录用户的信息。

Spring Security 提供了多种优雅的方式来获取已认证的用户信息。以下是最常用且推荐的方法，我会从最便捷到更底层的方式进行介绍：

**1. 通过方法参数注入 (推荐用于 Controller 层)**

这是在 Controller 方法中最方便、最推荐的方式。Spring MVC 会自动为你注入当前认证用户的信息。

*   **注入 `Authentication` 对象:**
    你可以直接在Controller方法参数中声明 `org.springframework.security.core.Authentication` 类型的参数。

    ```java
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    public class UserController {

        @GetMapping("/api/me")
        public String getCurrentUser(Authentication authentication) {
            if (authentication != null && authentication.isAuthenticated()) {
                Object principal = authentication.getPrincipal();
                String username;

                if (principal instanceof UserDetails) {
                    username = ((UserDetails) principal).getUsername();
                } else {
                    username = principal.toString(); // 通常是用户名字符串
                }
                // 你还可以获取权限等信息
                // Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
                return "Current user: " + username;
            }
            return "No user authenticated"; // 理论上，如果端点受保护，这里不会执行
        }
    }
    ```
    *   **`authentication.getPrincipal()`**: 这是核心方法。
        *   如果你的 `UserDetailsService` 返回的是标准的 `UserDetails` 对象（或其自定义实现），那么 `getPrincipal()` 通常会返回这个 `UserDetails` 对象。你可以将其强制转换为 `UserDetails` 来获取用户名、权限等详细信息。
        *   在某些配置下（例如，如果认证信息不是来自 `UserDetailsService`，或者自定义了 `AuthenticationProvider`），`principal` 可能直接是一个用户名字符串，或者一个自定义的 Principal 对象。

*   **注入 `UserDetails` (通过 `@AuthenticationPrincipal`)**:
    如果你的 `UserDetailsService` 返回的是 `UserDetails` 的实现，你可以使用 `@AuthenticationPrincipal` 注解直接注入 `UserDetails` 对象，这更加简洁。

    ```java
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    public class UserController {

        @GetMapping("/api/me/details")
        public String getCurrentUserDetails(@AuthenticationPrincipal UserDetails userDetails) {
            if (userDetails != null) {
                // 如果你有自定义的UserDetails实现，例如 MyCustomUserDetails
                // if (userDetails instanceof MyCustomUserDetails) {
                //     MyCustomUserDetails customUser = (MyCustomUserDetails) userDetails;
                //     // 可以获取自定义的属性，比如 userId, email 等
                //     return "Current user: " + customUser.getUsername() + ", Email: " + customUser.getEmail();
                // }
                return "Current user: " + userDetails.getUsername() + ", Authorities: " + userDetails.getAuthorities();
            }
            return "No user authenticated";
        }
    }
    ```
    *   **`@AuthenticationPrincipal` 的强大之处**:
        *   它可以直接注入 `UserDetails`。
        *   如果你的 Principal 是一个自定义对象 (例如 `MyCustomUser implements UserDetails`)，你可以直接注入 `MyCustomUser myCustomUser`。
        *   它还支持SpEL表达式，例如 `@AuthenticationPrincipal(expression = "username") String username` 可以直接注入用户名。
        *   对于OAuth2/OIDC登录，你可以注入 `OAuth2User` 或 `OidcUser`: `@AuthenticationPrincipal OAuth2User oauth2User`。

*   **注入 `java.security.Principal`**:
    这是Java EE规范中的标准接口，Spring Security也支持。通常 `principal.getName()` 会返回用户名。

    ```java
    import java.security.Principal;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    public class UserController {

        @GetMapping("/api/me/principal")
        public String getCurrentUserPrincipal(Principal principal) {
            if (principal != null) {
                return "Current user (from Principal): " + principal.getName();
            }
            return "No user authenticated";
        }
    }
    ```
    这种方式相对简单，但获取的信息不如 `Authentication` 或 `UserDetails` 丰富。

**2. 通过 `SecurityContextHolder` (适用于任何地方，包括 Service 层)**

如果你不在Controller方法中，或者需要在Service层、工具类等地方获取当前用户信息，可以使用 `SecurityContextHolder`。

```java
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    public String getCurrentAuthenticatedUsername() {
        SecurityContext securityContext = SecurityContextHolder.getContext();
        Authentication authentication = securityContext.getAuthentication();

        if (authentication != null && authentication.isAuthenticated()) {
            Object principal = authentication.getPrincipal();
            if (principal instanceof UserDetails) {
                return ((UserDetails) principal).getUsername();
            } else if (principal instanceof String) { // 例如JWT直接存用户名
                return (String) principal;
            } else {
                // 对于OAuth2/OIDC, principal可能是OAuth2User或OidcUser
                // if (principal instanceof org.springframework.security.oauth2.core.user.OAuth2User) {
                //     return ((org.springframework.security.oauth2.core.user.OAuth2User) principal).getName();
                // }
                return principal.toString(); // 最后的备选方案
            }
        }
        return null; // 或者抛出异常，表示没有认证用户
    }

    public UserDetails getCurrentAuthenticatedUserDetails() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated() && authentication.getPrincipal() instanceof UserDetails) {
            return (UserDetails) authentication.getPrincipal();
        }
        return null;
    }
}
```
*   `SecurityContextHolder.getContext()`: 获取当前的 `SecurityContext`。
*   `securityContext.getAuthentication()`: 从 `SecurityContext` 中获取 `Authentication` 对象。
*   后续处理与方法1中获取到 `Authentication` 对象后类似。

**关键点和最佳实践：**

1.  **端点必须是安全的**: 这些方法只有在请求已经通过Spring Security的认证过滤器链，并且用户已成功认证后才能正确工作。如果端点是公开的 (`permitAll()`)，那么 `authentication` 对象可能是 `null`，或者是一个代表匿名用户的 `AnonymousAuthenticationToken`。
2.  **`principal` 的类型**: `authentication.getPrincipal()` 返回的对象的具体类型取决于你的认证配置。
    *   最常见的是 `org.springframework.security.core.userdetails.UserDetails` 的实现。
    *   如果使用了OAuth2/OIDC，可能是 `org.springframework.security.oauth2.core.user.OAuth2User` 或 `org.springframework.security.oauth2.core.oidc.user.OidcUser`。
    *   在某些JWT配置中，`principal` 可能仅仅是一个用户名字符串，或者一个包含 JWT 声明的自定义对象。
    *   因此，在使用前进行 `instanceof` 检查并进行类型转换是个好习惯。
3.  **自定义 `UserDetails`**: 强烈建议创建你自己的 `UserDetails` 实现，例如 `CustomUserDetails`，它除了标准接口方法外，还可以包含你的应用特有的用户信息（如用户ID、邮箱、昵称等）。这样，获取到 `UserDetails` 后，可以将其转换为你的自定义类型，方便地访问这些额外信息。
    ```java
    // 假设你有这样一个自定义UserDetails
    // public class CustomUserDetails implements UserDetails {
    //     private Long id;
    //     private String username;
    //     private String password;
    //     private String email;
    //     private Collection<? extends GrantedAuthority> authorities;
    //     // ...构造函数、getter、以及UserDetails的接口方法实现...
    //     public Long getId() { return id; }
    //     public String getEmail() { return email; }
    // }

    // 在Controller或Service中:
    // UserDetails userDetails = ... ; // 获取到UserDetails
    // if (userDetails instanceof CustomUserDetails) {
    //     CustomUserDetails customUser = (CustomUserDetails) userDetails;
    //     Long userId = customUser.getId();
    //     String email = customUser.getEmail();
    //     // ... 使用这些信息
    // }
    ```
4.  **`isAuthenticated()` 检查**: 在使用 `Authentication` 对象之前，通常最好检查 `authentication != null && authentication.isAuthenticated()`。对于受保护的端点，`isAuthenticated()` 通常为 `true`。
5.  **线程绑定**: `SecurityContextHolder` 默认使用 `ThreadLocal` 策略来存储 `SecurityContext`，这意味着 `SecurityContext`（以及其中的 `Authentication`）是与当前执行线程绑定的。这在大多数Web应用中工作良好。但在异步处理（如使用 `@Async` 或手动管理线程）时需要特别注意 `SecurityContext` 的传播。Spring Security 提供了 `DelegatingSecurityContextAsyncTaskExecutor` 和 `SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL)` 等机制来帮助处理异步场景。

**总结一下：**

*   **Controller层**: 优先使用方法参数注入，尤其是 `@AuthenticationPrincipal UserDetails userDetails` 或 `@AuthenticationPrincipal MyCustomUserDetails customUser`，非常简洁方便。
*   **Service层或其他组件**: 使用 `SecurityContextHolder.getContext().getAuthentication()`。

这些方法能够满足绝大多数获取已认证用户信息的场景。你可以根据你的具体需求和代码所处的层次选择最合适的方式。