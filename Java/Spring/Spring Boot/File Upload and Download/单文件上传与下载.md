### **1. 单文件上传实现 (Service 层重构)**

**1.1 创建 File Storage Service**

首先，我们创建一个 Service 接口和它的实现类来处理文件的存储逻辑。

*   在你的主应用包下（例如 `com.example.filedemo`），创建一个名为 `service` 的子包。
*   在 `service` 包下创建一个接口 `FileStorageService.java`:

    ```java
    package com.example.filedemo.service; // 替换为你的包名

    import org.springframework.web.multipart.MultipartFile;

    import java.io.IOException;
    import java.nio.file.Path;

    public interface FileStorageService {

        /**
         * 存储上传的文件
         * @param file 上传的文件
         * @return 存储后的文件名 (可能是新的唯一文件名)
         * @throws IOException 如果存储过程中发生IO错误
         */
        String storeFile(MultipartFile file) throws IOException;

        // 后续我们还会在这里添加加载/下载文件的方法
    }
    ```

*   在 `service` 包下创建一个实现类 `FileSystemStorageService.java` (我们先实现基于本地文件系统的存储):

    ```java
    package com.example.filedemo.service; // 替换为你的包名

    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.stereotype.Service;
    import org.springframework.util.StringUtils;
    import org.springframework.web.multipart.MultipartFile;

    import jakarta.annotation.PostConstruct; // Spring Boot 3.x 使用 jakarta
    import java.io.IOException;
    import java.io.InputStream;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.StandardCopyOption;
    import java.util.UUID;

    @Service
    public class FileSystemStorageService implements FileStorageService {

        private static final Logger logger = LoggerFactory.getLogger(FileSystemStorageService.class);

        // 从 application.properties 读取文件上传根路径
        @Value("${file.upload-dir:./uploads}") // 提供一个默认值，如果配置文件中没有
        private String uploadDirLocation;

        private Path rootLocation;

        // @PostConstruct 注解的方法会在Bean创建并完成依赖注入后立即执行
        // 用于进行一些初始化操作，比如创建上传目录
        @PostConstruct
        public void init() {
            this.rootLocation = Paths.get(uploadDirLocation);
            try {
                Files.createDirectories(rootLocation);
                logger.info("Upload directory created at: {}", rootLocation.toAbsolutePath());
            } catch (IOException e) {
                logger.error("Could not initialize storage location: {}", uploadDirLocation, e);
                throw new RuntimeException("Could not initialize storage location: " + uploadDirLocation, e);
            }
        }

        @Override
        public String storeFile(MultipartFile file) throws IOException {
            if (file.isEmpty()) {
                throw new IllegalArgumentException("Failed to store empty file.");
            }

            String originalFilename = StringUtils.cleanPath(file.getOriginalFilename()); // 清理文件名，防止路径遍历
            if (originalFilename.contains("..")) {
                // 更严格的检查，或者可以抛出自定义异常
                throw new IllegalArgumentException(
                        "Cannot store file with relative path outside current directory " + originalFilename);
            }

            // 生成唯一文件名
            String fileExtension = "";
            if (originalFilename.contains(".")) {
                fileExtension = originalFilename.substring(originalFilename.lastIndexOf("."));
            }
            String storedFilename = UUID.randomUUID().toString() + fileExtension;

            Path destinationFile = this.rootLocation.resolve(storedFilename).normalize().toAbsolutePath();

            if (!destinationFile.getParent().equals(this.rootLocation.toAbsolutePath())) {
                // 这是一个安全检查，确保目标路径仍然在我们的根上传目录下
                throw new IllegalArgumentException(
                        "Cannot store file outside current directory " + originalFilename);
            }

            try (InputStream inputStream = file.getInputStream()) {
                Files.copy(inputStream, destinationFile, StandardCopyOption.REPLACE_EXISTING);
                logger.info("Stored file: {} as: {}", originalFilename, storedFilename);
                return storedFilename; // 返回存储后的文件名
            } catch (IOException e) {
                logger.error("Failed to store file {}: {}", originalFilename, e.getMessage());
                throw new IOException("Failed to store file " + originalFilename, e);
            }
        }
    }
    ```

    **代码解释 (FileSystemStorageService):**
    *   `@Service`: 标记这是一个 Spring Service Bean。
    *   `@Value("${file.upload-dir:./uploads}")`: 从 `application.properties` 中读取 `file.upload-dir` 的值，如果不存在，则使用默认值 `./uploads`。
    *   `private Path rootLocation;`: 用于存储上传目录的根路径。
    *   `@PostConstruct public void init()`:
        *   这个方法会在 `FileSystemStorageService` Bean 初始化后自动调用。
        *   它将配置的字符串路径转换为 `Path` 对象。
        *   `Files.createDirectories(rootLocation)`: 创建上传根目录（如果不存在的话）。这比 `mkdirs()` 更健壮，因为它会创建所有不存在的父目录。
        *   如果创建目录失败，抛出运行时异常，阻止应用启动（因为文件存储是核心功能）。
    *   `storeFile(MultipartFile file)`:
        *   **参数校验:** 检查文件是否为空。
        *   `StringUtils.cleanPath(file.getOriginalFilename())`: 使用 Spring Framework 的 `StringUtils.cleanPath()` 方法来规范化文件名，并帮助防止路径遍历攻击 (例如，文件名包含 `../`)。
        *   **安全检查:** 再次检查原始文件名中是否包含 `..`，这是一种更深层次的防御。
        *   **生成唯一文件名:** 逻辑与之前 Controller 中的类似。
        *   `this.rootLocation.resolve(storedFilename)`: 在根目录下解析出目标文件的完整路径。
        *   `.normalize().toAbsolutePath()`: 规范化路径并获取绝对路径。
        *   **安全检查:** `if (!destinationFile.getParent().equals(this.rootLocation.toAbsolutePath()))` 这是一个重要的安全检查，确保最终的目标文件路径仍然在我们配置的 `uploadDirLocation` 内部，防止恶意构造的文件名试图将文件写到预期之外的目录。
        *   `try-with-resources` (使用 `file.getInputStream()`): 确保输入流在使用完毕后自动关闭。
        *   `Files.copy(inputStream, destinationFile, StandardCopyOption.REPLACE_EXISTING)`: 将文件内容复制到目标位置。`REPLACE_EXISTING` 表示如果同名文件已存在则覆盖。根据你的需求，你可能不希望覆盖，这时需要进一步处理文件名冲突。
        *   返回存储后的唯一文件名。
        *   抛出 `IOException` 以便 Controller 层可以捕获并处理。

**1.2 更新 application.properties (如果需要)**

在 `src/main/resources/application.properties` 中，我们可以明确指定上传目录：

```properties
# 文件上传配置
file.upload-dir=./my-uploads # 你可以自定义这个路径

# Spring Boot 默认开启 multipart 支持，所以 spring.servlet.multipart.enabled=true 通常不需要显式设置
# 单个文件的最大尺寸 (默认 1MB)
spring.servlet.multipart.max-file-size=10MB
# 一次请求中所有文件的总最大尺寸 (默认 10MB)
spring.servlet.multipart.max-request-size=100MB

# (可选) 当文件大小超过这个阈值时，会先写入磁盘临时文件，而不是内存 (默认 0，表示立即写入磁盘) 
# spring.servlet.multipart.file-size-threshold=2KB 
# (可选) 存储上传文件的临时目录，如果不指定，会使用 Servlet 容器的默认临时目录 
# spring.servlet.multipart.location=/tmp/myapp-uploads
```
如果你在 `@Value` 中使用了 `${file.upload-dir}`，那么这个配置就会生效。如果该配置项不存在，则会使用 `@Value` 中定义的默认值 (`./uploads`)。

**1.3 更新 FileUploadController**

现在修改 Controller，让它调用 `FileStorageService`。

```java
package com.example.filedemo.controller; // 替换为你的包名

import com.example.filedemo.service.FileStorageService; // 引入Service
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;
// import org.springframework.web.servlet.mvc.support.RedirectAttributes; // 如果需要重定向

@Controller
public class FileUploadController {

    private static final Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    private final FileStorageService fileStorageService; // 注入Service

    @Autowired // 构造器注入
    public FileUploadController(FileStorageService fileStorageService) {
        this.fileStorageService = fileStorageService;
    }

    // 显示上传页面的方法 (可选)
    @GetMapping("/")
    public String homepage() {
        // 如果使用 static/index.html，这个方法可以省略，或返回一个简单的提示
        // return "index"; // 如果是模板引擎视图
        return "forward:/index.html"; // 或者直接转发到静态页面
    }

    @PostMapping("/upload")
    public ResponseEntity<String> handleFileUpload(@RequestParam("file") MultipartFile file) {
                                                    // RedirectAttributes redirectAttributes) {

        if (file.isEmpty()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Please select a file to upload.");
        }

        try {
            String originalFilename = file.getOriginalFilename();
            String storedFilename = fileStorageService.storeFile(file); // 调用Service存储文件

            logger.info("Controller: Uploaded file: {}, saved as: {}", originalFilename, storedFilename);

            // redirectAttributes.addFlashAttribute("message",
            //         "You successfully uploaded '" + originalFilename + "' as '" + storedFilename + "'!");
            // return "redirect:/";
            return ResponseEntity.ok("You successfully uploaded '" + originalFilename + "' as '" + storedFilename + "'!");

        } catch (IllegalArgumentException e) { // 捕获Service中可能抛出的参数错误
            logger.warn("Controller: Invalid file upload request: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Invalid file: " + e.getMessage());
        } catch (IOException e) {
            logger.error("Controller: Failed to upload file: {}", file.getOriginalFilename(), e);
            // redirectAttributes.addFlashAttribute("errorMessage",
            //         "Failed to upload " + file.getOriginalFilename() + " => " + e.getMessage());
            // return "redirect:/";
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                 .body("Failed to upload " + file.getOriginalFilename() + ". Error: " + e.getMessage());
        }
    }
}
```

**Controller 代码改动解释：**
*   **依赖注入:** 通过构造器注入了 `FileStorageService` 的实例。这是推荐的依赖注入方式。
*   **调用 Service:** `handleFileUpload` 方法现在调用 `fileStorageService.storeFile(file)` 来实际处理文件存储。
*   **错误处理:** Controller 现在捕获 `IllegalArgumentException` (来自 Service 的参数校验) 和 `IOException` (来自文件操作)，并返回相应的 HTTP 状态码和消息。之前 Controller 中的文件操作逻辑（如创建目录、生成文件名）都移到了 Service 中。

**1.4 前端 (index.html) - 无需改动**

前端的 `index.html` 仍然保持不变，因为它只负责将文件发送到 `/upload` 端点。

**1.5 运行和测试上传功能 (同之前)**

1.  运行 Spring Boot 应用。
2.  打开浏览器访问 `http://localhost:8080/index.html` (或 `/`)。
3.  选择文件并上传。
4.  检查 `my-uploads` 目录（或你在 `application.properties` 中配置的目录）是否生成了文件。
5.  检查控制台日志，现在应该能看到来自 `FileSystemStorageService` 和 `FileUploadController` 的日志。

---

### **2. 单文件下载实现 (Service 层重构)**

现在我们来实现文件下载，同样遵循 Controller 调用 Service 的模式。

**2.1 更新 File Storage Service 接口**

在 `FileStorageService.java` 接口中添加加载文件为资源的方法：

```java
package com.example.filedemo.service;

import org.springframework.core.io.Resource; // 引入 Resource
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Path;

public interface FileStorageService {

    String storeFile(MultipartFile file) throws IOException;

    /**
     * 加载文件作为资源
     * @param filename 文件名
     * @return 代表文件的 Resource 对象
     * @throws java.io.FileNotFoundException 如果文件不存在或无法读取
     */
    Resource loadFileAsResource(String filename) throws IOException; // 使用 IOException 更通用

    /**
     * 获取文件的存储路径
     * @param filename 文件名
     * @return 文件的 Path 对象
     */
    Path loadFilePath(String filename); // 新增一个获取路径的方法，方便 Controller 设置 Content-Type
}
```

**2.2 更新 FileSystemStorageService 实现类**

在 `FileSystemStorageService.java` 中实现 `loadFileAsResource` 和 `loadFilePath` 方法：

```java
package com.example.filedemo.service;

// ... (imports 保持不变，可能需要添加 org.springframework.core.io.Resource 和 org.springframework.core.io.UrlResource)
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
// ... (其他 imports)
import java.net.MalformedURLException;
import java.io.FileNotFoundException; // 可以自定义异常或使用标准异常

// ... (class definition 和其他方法)
@Service
public class FileSystemStorageService implements FileStorageService {

    // ... (logger, uploadDirLocation, rootLocation, init(), storeFile() 方法保持不变)

    @Override
    public Path loadFilePath(String filename) {
        return rootLocation.resolve(filename);
    }

    @Override
    public Resource loadFileAsResource(String filename) throws IOException {
        try {
            Path filePath = loadFilePath(filename);
            Resource resource = new UrlResource(filePath.toUri());

            if (resource.exists() && resource.isReadable()) {
                return resource;
            } else {
                logger.warn("Could not read file: {} or file does not exist at path: {}", filename, filePath);
                // 可以抛出自定义的 "MyFileNotFoundException" 继承自 RuntimeException 或 IOException
                throw new FileNotFoundException("Could not read file: " + filename);
            }
        } catch (MalformedURLException e) {
            logger.error("Malformed URL for file: {}", filename, e);
            throw new FileNotFoundException("Could not read file (Malformed URL): " + filename + ". Error: " + e.getMessage());
        }
    }
}
```

**代码解释 (FileSystemStorageService - 下载部分):**
*   `loadFilePath(String filename)`: 简单地返回文件在存储目录中的完整路径。
*   `loadFileAsResource(String filename)`:
    *   `Path filePath = loadFilePath(filename);`: 获取文件的完整路径。
    *   `Resource resource = new UrlResource(filePath.toUri());`:
        *   将 `Path` 对象转换为 `URI`，然后使用 `UrlResource` 来创建 `Resource` 对象。`UrlResource` 可以访问文件系统中的文件（通过 `file:/` 协议的 URL）。
    *   `resource.exists() && resource.isReadable()`: 检查文件是否存在并且是可读的。
    *   如果文件不可读或不存在，记录警告并抛出 `FileNotFoundException` (或者你可以定义一个更具体的自定义异常)。
    *   `MalformedURLException`: 如果 `filePath.toUri()` 产生的 URL 格式不正确，则捕获此异常。

**2.3 创建 FileDownloadController (或在 FileUploadController 中添加下载方法)**

我们可以创建一个新的 Controller `FileDownloadController`，或者为了简单起见，在现有的 `FileUploadController` 中添加下载的端点。这里我们选择后者。

修改 `FileUploadController.java`：

```java
package com.example.filedemo.controller;

// ... (其他 imports)
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping; // 已有
import org.springframework.web.bind.annotation.PathVariable; // 用于从路径中获取文件名

import jakarta.servlet.http.HttpServletRequest; // 用于获取MIME类型
import java.io.IOException;
import java.nio.file.Files; // 用于探测MIME类型

// ... (class 和构造器)
@Controller
public class FileUploadController {
    // ... (logger, fileStorageService, constructor, homepage(), handleFileUpload() 方法保持不变)

    @GetMapping("/download/{filename:.+}") // :.+ 确保文件名中的点号不会被截断
    public ResponseEntity<Resource> downloadFile(@PathVariable String filename, HttpServletRequest request) {
        Resource resource;
        try {
            resource = fileStorageService.loadFileAsResource(filename);
        } catch (IOException e) {
            // 文件未找到或无法读取，可以返回 404
            logger.warn("File not found or unreadable for download: {}", filename, e);
            return ResponseEntity.notFound().build();
        }

        // 尝试确定文件的MIME类型
        String contentType = null;
        try {
            // 优先使用 Java NIO Files.probeContentType (Java 7+)
            Path filePath = fileStorageService.loadFilePath(filename); // 获取文件路径
            contentType = Files.probeContentType(filePath);
        } catch (IOException ex) {
            logger.info("Could not determine file type for: {}", filename);
        }

        // 如果无法确定，则使用默认的二进制流类型
        if (contentType == null) {
            contentType = "application/octet-stream";
        }
        logger.debug("Content type for {}: {}", filename, contentType);

        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(contentType))
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
                // .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"") // 如果希望浏览器尝试在线打开
                .body(resource);
    }
}
```

**Controller 代码改动解释 (下载部分):**
*   `@GetMapping("/download/{filename:.+}")`:
    *   处理 `/download/` 路径下的 GET 请求。
    *   `{filename:.+}`: 这是一个路径变量。`:.+` 是一个正则表达式，确保 Spring MVC 正确捕获包含点 `.` 的完整文件名 (例如 `image.jpg`)，否则点号后面的部分可能会被截断。
*   `@PathVariable String filename`: 将路径中的 `filename` 部分注入到方法参数中。
*   `HttpServletRequest request`: 注入 `HttpServletRequest` 对象，我们将用它来帮助确定文件的 MIME 类型。
*   **加载资源:** `resource = fileStorageService.loadFileAsResource(filename);` 调用 Service 加载文件。
*   **错误处理:** 如果 Service 抛出 `IOException` (例如 `FileNotFoundException`)，则返回 `ResponseEntity.notFound().build()` (HTTP 404)。
*   **确定 MIME 类型 (`Content-Type`):**
    *   `Path filePath = fileStorageService.loadFilePath(filename);`: 先获取文件的实际路径。
    *   `contentType = Files.probeContentType(filePath);`: **推荐方式。** 使用 Java 7 NIO 的 `Files.probeContentType(Path)` 方法来尝试根据文件内容或系统配置探测文件的 MIME 类型。这通常比仅依赖文件扩展名更准确。
    *   如果 `Files.probeContentType` 返回 `null` (表示无法确定)，则回退到 `application/octet-stream` 作为通用二进制类型。
*   **构建响应 (`ResponseEntity`):**
    *   `ResponseEntity.ok()`: 表示 HTTP 200 OK。
    *   `.contentType(MediaType.parseMediaType(contentType))`: 设置 `Content-Type` 响应头。
    *   `.header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")`:
        *   设置 `Content-Disposition` 响应头。
        *   `attachment`: 提示浏览器下载文件。
        *   `filename=\"" + resource.getFilename() + "\"`: 指定下载时建议的文件名。`resource.getFilename()` 会返回加载资源时的文件名（在我们的例子中，是存储时的唯一文件名）。
        *   如果希望浏览器尝试在线打开（如图片、PDF），可以使用 `inline` 代替 `attachment`。
    *   `.body(resource)`: 将 `Resource` 对象作为响应体。Spring Boot 会负责将资源内容流式传输给客户端。

**2.4 更新前端 (index.html) 以测试下载 (可选)**

为了方便测试下载，我们可以在 `index.html` 中添加一个区域来列出已上传（假设）的文件，并提供下载链接。这部分比较简单，我们暂时手动构造下载链接来测试。

*   你可以直接在浏览器地址栏输入下载链接，例如，如果你上传了一个文件并被保存为 `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.jpg`，那么下载链接就是 `http://localhost:8080/download/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.jpg`。

**2.5 运行和测试下载功能**

1.  **确保至少有一个文件已上传** 到你的 `my-uploads` (或配置的) 目录。记下它的文件名（UUID 格式的那个）。
2.  运行 Spring Boot 应用。
3.  打开浏览器，在地址栏输入下载链接，例如：
    `http://localhost:8080/download/YOUR_STORED_UNIQUE_FILENAME.EXT`
    （将 `YOUR_STORED_UNIQUE_FILENAME.EXT` 替换为你实际存储的文件名）。
4.  浏览器应该会开始下载该文件，或者如果配置了 `inline` 并且浏览器支持该类型，则会尝试显示它。
5.  检查下载的文件是否正确。
6.  尝试下载一个不存在的文件名，例如 `http://localhost:8080/download/nonexistentfile.txt`，应该会收到 404 Not Found 响应。

---

现在，我们有了一个更健壮的文件上传和下载实现，其中业务逻辑被清晰地分离到了 Service 层。

**总结一下这次重构的关键点：**

*   **Service 层封装核心逻辑：** `FileStorageService` 负责文件的实际存储和加载。
*   **Controller 负责调度：** `FileUploadController` 负责接收 HTTP 请求，调用 Service，并构建 HTTP 响应。
*   **配置化上传目录：** 通过 `application.properties` 和 `@Value` 实现。
*   **初始化逻辑：** 使用 `@PostConstruct` 在 Service 初始化时创建上传目录。
*   **更完善的文件名处理和安全考虑：** 在 Service 中使用 `StringUtils.cleanPath` 和路径检查。
*   **更准确的 MIME 类型检测：** 在下载时使用 `Files.probeContentType`。