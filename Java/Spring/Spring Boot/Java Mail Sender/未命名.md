### 一、核心思想：拥抱 Spring Boot Starter Mail

忘掉那些手动创建 `Session`、配置 `Properties` 的旧时代代码。在 2024 年及以后，开发新的 Java 邮件功能，**首选且唯一的推荐方案是 `spring-boot-starter-mail`**。

**为什么？**

1.  **自动配置 (Auto-Configuration)**：你只需要在配置文件中填写邮箱服务器信息，Spring Boot 会自动为你创建和配置核心的 `JavaMailSender` Bean。
2.  **高度抽象**：它提供了 `JavaMailSender` 接口和 `MimeMessageHelper` 辅助类，让你能用非常简洁的代码发送简单文本、HTML、附件和内联资源邮件，而无需关心底层的 `MimeMessage` 复杂结构。
3.  **无缝集成**：与 Spring 框架的其他部分（如异步 `@Async`、模板引擎 Thymeleaf）能完美集成，轻松实现高级功能。

---

### 二、实战演练：从零到一发送邮件

我们直接上手，三步搞定。

#### 第 1 步：引入依赖 (Maven)

在你的 `pom.xml` 中加入 Spring Boot 的邮件启动器。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

#### 第 2 步：核心配置 (application.yml)

在 `src/main/resources/application.yml` 中配置你的 SMTP 服务器信息。这里以 QQ 邮箱为例（请确保已开启 SMTP 服务并获取了授权码，而不是用你的登录密码）。

```yaml
spring:
  mail:
    host: smtp.qq.com
    port: 587 # 或 465，取决于是否使用SSL
    username: your-email@qq.com
    # 注意：这里填写的是授权码，不是邮箱密码！
    password: your-authorization-code 
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true # 建立加密连接
            required: true
#   protocol: smtps # 如果使用465端口(SSL)，可以加上这个
```

**关键配置项解析：**

*   `host`, `port`, `username`, `password`: SMTP 服务器的基础信息。
*   `spring.mail.properties.*`: 用于配置更底层的 Jakarta Mail 属性。
    *   `mail.smtp.auth`: `true` 表示需要登录验证。
    *   `mail.smtp.starttls.enable`: `true` 表示使用 STARTTLS 协议加密传输。这是一种主流的安全方式，它先建立一个普通连接，然后升级为加密连接。如果你的 SMTP 服务器使用 SSL（通常是 465 端口），则此项应为 `false`，并设置 `spring.mail.protocol=smtps`。

#### 第 3 步：编写发送代码

创建一个 Service 类来处理邮件发送逻辑。

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import java.io.File;

@Service
public class MailService {

    @Autowired
    private JavaMailSender mailSender;

    @Value("${spring.mail.username}")
    private String fromEmail;

    /**
     * 发送最简单的纯文本邮件
     * @param to      收件人
     * @param subject 主题
     * @param text    内容
     */
    public void sendSimpleMail(String to, String subject, String text) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(fromEmail);
        message.setTo(to);
        message.setSubject(subject);
        message.setText(text);
        mailSender.send(message);
    }

    /**
     * 发送复杂的邮件（HTML、附件、内联图片）
     * @param to          收件人
     * @param subject     主题
     * @param htmlContent HTML内容
     * @param filePath    附件路径 (可选)
     * @param inlinePath  内联图片路径 (可选)
     * @param rscId       内联图片ID (可选)
     */
    public void sendMimeMail(String to, String subject, String htmlContent, String filePath, String inlinePath, String rscId) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            // 使用 MimeMessageHelper，并设置 multipart=true 表示构建一个多部分邮件
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

            helper.setFrom(fromEmail);
            helper.setTo(to);
            helper.setSubject(subject);

            // 设置HTML内容, 第二个参数为true表示内容是HTML
            helper.setText(htmlContent, true);

            // 添加附件
            if (filePath != null) {
                FileSystemResource file = new FileSystemResource(new File(filePath));
                String fileName = file.getFilename();
                helper.addAttachment(fileName, file);
            }

            // 添加内联图片 (在HTML中通过 <img src='cid:rscId'> 引用)
            if (inlinePath != null && rscId != null) {
                FileSystemResource res = new FileSystemResource(new File(inlinePath));
                helper.addInline(rscId, res);
            }

            mailSender.send(message);
        } catch (MessagingException e) {
            // 生产环境中应记录日志或抛出自定义异常
            throw new RuntimeException("Failed to send email", e);
        }
    }
}
```

**代码亮点：**

*   **`JavaMailSender`**: 由 Spring Boot 自动配置好，直接 `@Autowired` 注入即可使用。
*   **`SimpleMailMessage`**: 用于发送简单的纯文本邮件，非常方便。
*   **`MimeMessageHelper`**: 发送复杂邮件的利器！构造函数中的 `true` 开启了 multipart 模式。
    *   `setText(html, true)`: 明确告诉 Helper 内容是 HTML。
    *   `addAttachment(fileName, file)`: 添加附件，简单直观。
    *   `addInline(contentId, resource)`: 添加内联资源（如图片）。HTML 中通过 `cid:` (Content-ID) 来引用它，例如 `<img src='cid:myLogo'>`。

---

### 三、知识扩展与应用（高级用法）

作为资深工程师，只知道如何发送是不够的，我们还要考虑性能、可维护性和安全性。

#### 1. 异步发送：提升用户体验

邮件发送是 I/O 密集型操作，可能会耗时几秒钟。在 Web 应用中，不能让用户请求一直等待邮件发送完成。

**解决方案：** 使用 Spring 的 `@Async`。

1.  **开启异步支持**：在你的启动类上添加 `@EnableAsync`。

    ```java
    @SpringBootApplication
    @EnableAsync
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication.run(MyApplication.class, args);
        }
    }
    ```

2.  **标记发送方法为异步**：在你的 `MailService` 的发送方法上添加 `@Async` 注解。

    ```java
    @Async
    public void sendMimeMail(...) {
        // ... 原有代码不变
    }
    ```

现在，当调用 `sendMimeMail` 时，Spring 会从线程池中取一个线程来执行它，主线程（例如处理 HTTP 请求的线程）会立刻返回。

#### 2. 模板引擎：分离内容与代码

没人愿意在 Java 代码里拼接复杂的 HTML 字符串。这难以维护且容易出错。

**解决方案：** 使用模板引擎，如 Thymeleaf 或 FreeMarker。

以 **Thymeleaf** 为例（Spring Boot 默认集成良好）：

1.  **引入依赖**：
    ```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
    ```

2.  **创建 HTML 模板** (`src/main/resources/templates/mail-template.html`)：
    ```html
    <!DOCTYPE html>
    <html xmlns:th="http://www.thymeleaf.org">
    <body>
        <h3>您好, <span th:text="${username}"></span>!</h3>
        <p>欢迎注册我们的服务，您的验证码是：<b th:text="${code}" style="color:blue;"></b></p>
        <p>祝好！</p>
        <img src='cid:logoImage' /> <!-- 引用内联图片 -->
    </body>
    </html>
    ```

3.  **在代码中渲染模板**：
    ```java
    @Autowired
    private TemplateEngine templateEngine; // 注入模板引擎

    // ... 在 MailService 中 ...
    public void sendMailWithTemplate(String to, String username, String code) {
        // 1. 创建上下文，并设置模板中需要的变量
        Context context = new Context();
        context.setVariable("username", username);
        context.setVariable("code", code);

        // 2. 使用模板引擎渲染HTML
        String htmlContent = templateEngine.process("mail-template", context);
        
        // 3. 调用之前的MIME邮件发送方法
        // 假设logo图片路径和ID已知
        sendMimeMail(to, "欢迎注册", htmlContent, null, "path/to/logo.png", "logoImage");
    }
    ```

#### 3. 单元测试：无需真实发送

如何测试邮件发送逻辑是否正确，而又不真的往邮箱里发一堆垃圾邮件？

**解决方案：** 使用内存中的 SMTP 服务器，如 **GreenMail**。

1.  **引入测试依赖**：
    ```xml
    <dependency>
        <groupId>com.icegreen</groupId>
        <artifactId>greenmail-spring</artifactId>
        <version>2.0.0</version> <!-- 请使用最新版 -->
        <scope>test</scope>
    </dependency>
    ```

2.  **编写测试类**：
    ```java
    import com.icegreen.greenmail.configuration.GreenMailConfiguration;
    import com.icegreen.greenmail.junit5.GreenMailExtension;
    import com.icegreen.greenmail.util.ServerSetupTest;
    import org.junit.jupiter.api.Test;
    import org.junit.jupiter.api.extension.RegisterExtension;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;

    import javax.mail.internet.MimeMessage;
    
    import static org.junit.jupiter.api.Assertions.assertEquals;
    import static org.junit.jupiter.api.Assertions.assertTrue;

    @SpringBootTest
    public class MailServiceTest {

        // 启动一个内存SMTP服务器
        @RegisterExtension
        static GreenMailExtension greenMail = new GreenMailExtension(ServerSetupTest.SMTP)
            .withConfiguration(GreenMailConfiguration.aConfig().withUser("your-email@qq.com", "your-authorization-code"))
            .withPerMethodLifecycle(false);

        @Autowired
        private MailService mailService;

        @Test
        void testSendSimpleMail() throws Exception {
            String to = "test@example.com";
            String subject = "Test Subject";
            String text = "Hello Test";

            mailService.sendSimpleMail(to, subject, text);

            // GreenMail可以验证收到的邮件
            MimeMessage[] receivedMessages = greenMail.getReceivedMessages();
            assertEquals(1, receivedMessages.length);

            MimeMessage receivedMessage = receivedMessages[0];
            assertEquals(subject, receivedMessage.getSubject());
            assertEquals(to, receivedMessage.getAllRecipients()[0].toString());
            assertTrue(receivedMessage.getContent().toString().contains(text));
        }
    }
    ```
    *注：`@SpringBootTest` 会加载 `application.yml` 配置，GreenMail 会自动覆盖 `host` 和 `port`，让邮件发到内存服务器中。*

#### 4. 安全性与最佳实践

*   **凭证管理**：**绝不**将密码或授权码硬编码在代码或 `application.yml` 中。应使用环境变量、Docker Secrets、Kubernetes Secrets 或云服务商的密钥管理服务（如 AWS Secrets Manager, HashiCorp Vault）来注入。
*   **连接安全**：始终优先使用 `STARTTLS` (587端口) 或 `SSL/TLS` (465 端口)，绝不使用明文传输。
*   **OAuth 2 认证**：对于 Gmail、Outlook 365 等现代邮箱服务，推荐使用 OAuth 2.0 进行认证，而不是简单的用户名/密码。这更安全，因为它授予的是有时效性的、范围受限的访问令牌。Spring Security 提供了对 OAuth 2 的良好支持。

---

### 四、原理与演进：Jakarta Mail vs. JavaMail

你可能在旧代码或文章中看到 `javax.mail`。这是什么？

*   **JavaMail**：最初的 Java 邮件 API 规范，由 Sun/Oracle 维护，包名为 `javax.mail`。
*   **Jakarta Mail**：随着 Java EE 迁移到 Eclipse 基金会并更名为 Jakarta EE，JavaMail 也随之迁移，并更名为 **Jakarta Mail**。为了避免法律问题和明确归属，包名从 `javax.mail` 变成了 `jakarta.mail`。

**`spring-boot-starter-mail` 在 Spring Boot 3.x 之后，已经默认使用 `jakarta.mail`。** 这就是“先进最新”的体现。如果你在维护一个旧的 Spring Boot 2.x 项目，它用的还是 `javax.mail`。升级时需要注意这个包名的变化。

**调用链条：**
`你的代码` -> `Spring JavaMailSender` (抽象层) -> `Jakarta Mail API` (标准实现) -> `SMTP 协议` (网络通信)

---

### 总结

现代 Java 邮件发送已经非常成熟和简单。

1.  **首选 `spring-boot-starter-mail`**，享受自动配置和高级抽象。
2.  使用 `MimeMessageHelper` 处理 HTML、附件等复杂邮件。
3.  通过 `@Async` 实现**异步发送**，优化性能和用户体验。
4.  结合 **Thymeleaf** 等模板引擎，实现内容与代码分离，提高可维护性。
5.  利用 **GreenMail** 进行可靠的**单元测试**。
6.  时刻注意**安全**，妥善管理凭证，使用加密连接。
7.  了解从 `javax.mail` 到 `jakarta.mail` 的演进，保持知识更新。