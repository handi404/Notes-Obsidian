在 Java Spring Boot 项目中自定义运行时异常并处理，可以按照以下步骤进行：

### 1. 创建自定义运行时异常类
定义一个继承自 `RuntimeException` 的异常类，包含错误码和消息。

```java
public class BusinessException extends RuntimeException {
    private final String errorCode;

    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
```

**进阶版（使用枚举管理错误码）**：

```java
public enum ErrorCode {
    INVALID_REQUEST("ERR_001", "Invalid request"),
    RESOURCE_NOT_FOUND("ERR_002", "Resource not found");

    private final String code;
    private final String message;

    ErrorCode(String code, String message) {
        this.code = code;
        this.message = message;
    }

    // Getters
    public String getCode() { return code; }
    public String getMessage() { return message; }
}

public class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }
}
```

### 2. 抛出异常示例
在 Service 层或需要的地方抛出异常：

```java
public User getUserById(Long id) {
    return userRepository.findById(id)
            .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND));
}
```

### 3. 创建全局异常处理器
使用 `@RestControllerAdvice` 捕获异常并统一处理响应。

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        ErrorCode errorCode = ex.getErrorCode();
        ErrorResponse response = new ErrorResponse(errorCode.getCode(), errorCode.getMessage());
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }

    // 处理其他异常
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllExceptions(Exception ex) {
        ErrorResponse response = new ErrorResponse("ERR_000", "Internal server error");
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

### 4. 定义错误响应体
创建 POJO 类表示错误响应结构：

```java
public class ErrorResponse {
    private String code;
    private String message;

    // 构造方法、Getters和Setters
    public ErrorResponse(String code, String message) {
        this.code = code;
        this.message = message;
    }

    // Getters
    public String getCode() { return code; }
    public String getMessage() { return message; }
}
```

### 5. 实现国际化（可选）
结合Spring的 `MessageSource` 实现多语言错误消息：

**配置 MessageSource**：

```properties
# application.properties
spring.messages.basename=messages
```

**创建消息文件**（如 `messages.properties`）：

```properties
error.invalid_request=Invalid request data.
error.resource_not_found=Requested resource not found.
```

**修改异常处理器**：

```java
@Autowired
private MessageSource messageSource;

@ExceptionHandler(BusinessException.class)
public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex, WebRequest request) {
    String message = messageSource.getMessage(ex.getErrorCode().getMessageKey(), null, request.getLocale());
    ErrorResponse response = new ErrorResponse(ex.getErrorCode().getCode(), message);
    return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
}
```

### 6. 处理验证异常示例
集成 Spring 验证框架，处理参数校验异常：

```java
@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
    String errorMessage = ex.getBindingResult().getAllErrors().stream()
            .map(DefaultMessageSourceResolvable::getDefaultMessage)
            .findFirst()
            .orElse("Validation failed");
    ErrorResponse response = new ErrorResponse("ERR_003", errorMessage);
    return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
}
```

### 总结
- **自定义异常**：继承 `RuntimeException`，封装错误码和消息。
- **全局处理**：使用 `@RestControllerAdvice` 和 `@ExceptionHandler` 统一处理异常，返回结构化的错误响应。
- **错误码管理**：推荐使用枚举或常量类集中管理，避免硬编码。
- **国际化**：通过 `MessageSource` 动态获取多语言错误消息。
- **扩展性**：可针对不同异常类型定制处理逻辑，保持响应格式统一。

此方案确保业务异常清晰可控，提升 API 的友好性和可维护性。

### 我要和这段kotlin代码效果一样的Java代码 ： 
```kotlin
@ResponseStatus(HttpStatus.NOT_FOUND) 
data class TaskNotFoundException(override val message: String): RuntimeException()
```

以下是与你提供的 Kotlin 代码等效的 Java 实现：

```java
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class TaskNotFoundException extends RuntimeException {
    
    // 显式调用父类构造函数传递 message
    public TaskNotFoundException(String message) {
        super(message);
    }

    // 可选：若需要其他构造函数
    public TaskNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

**代码解析**：

1. **注解 `@ResponseStatus`**
   - 与 Kotlin 版本完全一致，当抛出该异常时，Spring 会自动返回 HTTP 404 状态码
   - `HttpStatus.NOT_FOUND` 对应 HTTP 404 状态码

2. **继承结构**
   - 继承自 `RuntimeException`（与 Kotlin 的 `: RuntimeException()` 等效）

3. **构造函数**
   - 显式调用父类构造函数 `super(message)` 来设置异常消息
   - 可选添加带 `cause` 参数的构造函数（链式异常处理）

**使用示例**：
```java
// 在 Controller/Service 层抛出
public Task getTask(Long id) {
    return taskRepository.findById(id)
           .orElseThrow(() -> new TaskNotFoundException("Task not found with id: " + id));
}
```

**与 Kotlin 版本的等效性**：
4. 都会自动生成 `getMessage()` 方法（继承自父类）
5. 都通过 `@ResponseStatus` 注解设置 HTTP 响应状态
6. 都可以直接作为业务异常抛出

**如果需要更接近 Kotlin data class 的特性**（自动生成 toString/equals 等方法），可以添加 Lombok 注解：
```java
@ResponseStatus(HttpStatus.NOT_FOUND)
@Getter // 可选
@AllArgsConstructor
public class TaskNotFoundException extends RuntimeException {
    private final String message;
}
```

不过对于异常类来说，通常不需要这些额外方法，保持基础实现即可满足大多数使用场景。

## 我试了在 postman 响应中没有 message

以下是逐步排查和解决问题的方案：

---

### **问题原因分析**
当直接使用 `@ResponseStatus` 标注异常时，Spring Boot 默认会返回指定的 HTTP 状态码，但**响应体（Body）是空的**。Kotlin 代码之所以能显示 `message`，是因为 Spring Boot 默认会将异常消息通过 `DefaultErrorAttributes` 处理，但 Java 中需要显式配置或使用统一异常处理器。

---

### **解决方案**
#### **方法 1：全局异常处理器（推荐）**
通过 `@RestControllerAdvice` 统一捕获异常，返回结构化错误响应。

1. **创建全局异常处理器类**：
    ```java
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.ExceptionHandler;
    import org.springframework.web.bind.annotation.RestControllerAdvice;

    @RestControllerAdvice
    public class GlobalExceptionHandler {

        @ExceptionHandler(TaskNotFoundException.class)
        public ResponseEntity<Map<String, Object>> handleTaskNotFoundException(TaskNotFoundException ex) {
            Map<String, Object> body = new LinkedHashMap<>();
            body.put("status", HttpStatus.NOT_FOUND.value());
            body.put("error", HttpStatus.NOT_FOUND.getReasonPhrase());
            body.put("message", ex.getMessage());
            return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
        }
    }
    ```

2. **验证结果**：
    - 在 Postman 中调用接口，会看到如下响应：
      ```json
      {
          "status": 404,
          "error": "Not Found",
          "message": "Task not found with id: 123"
      }
      ```

---

#### **方法 2：使用 `@ResponseStatus` + `reason` 属性**
直接通过注解指定消息，但**消息内容固定**（不推荐动态场景）。

1. **修改异常类**：
    ```java
    @ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Task not found")
    public class TaskNotFoundException extends RuntimeException {
        // 构造函数可以省略 message 参数
        public TaskNotFoundException() {
            super("Task not found");
        }
    }
    ```

2. **验证结果**：
    - 响应状态码为 `404`，响应体为：
      ```json
      {
          "timestamp": "2023-10-05T12:34:56.789+00:00",
          "status": 404,
          "error": "Not Found",
          "path": "/api/tasks/123"
      }
      ```
    - **缺点**：消息固定为 `reason` 的值，无法动态传递参数（如 `id`）。

---

#### **方法 3：启用 Spring Boot 默认错误消息**
通过配置 `server.error.include-message=always` 显示异常消息。

1. **修改 `application.properties`**：
    ```
    server.error.include-message=always
    //server.error.include-binding-errors: always
    //server.error.include-stacktrace: on_param
    ```

2. **抛出异常**：
    ```java
    public Task getTask(Long id) {
        return taskRepository.findById(id)
                .orElseThrow(() -> new TaskNotFoundException("Task not found with id: " + id));
    }
    ```

3. **验证结果**：
    - 响应状态码为 `404`，响应体为：
      ```json
      {
          "timestamp": "2023-10-05T12:34:56.789+00:00",
          "status": 404,
          "error": "Not Found",
          "message": "Task not found with id: 123",
          "path": "/api/tasks/123"
      }
      ```

---

### **最终推荐方案**
使用 **方法 1（全局异常处理器）**，原因：
4. **灵活性**：可自定义响应结构，支持动态消息。
5. **统一管理**：集中处理所有异常，避免代码重复。
6. **符合 RESTful 规范**：返回标准化的错误响应格式。

---

### **代码总结**
7. **异常类**：
    ```java
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public class TaskNotFoundException extends RuntimeException {
        public TaskNotFoundException(String message) {
            super(message);
        }
    }
    ```

8. **全局异常处理器**：
    ```java
    @RestControllerAdvice
    public class GlobalExceptionHandler {
        @ExceptionHandler(TaskNotFoundException.class)
        public ResponseEntity<Map<String, Object>> handleTaskNotFoundException(TaskNotFoundException ex) {
            Map<String, Object> body = new LinkedHashMap<>();
            body.put("status", HttpStatus.NOT_FOUND.value());
            body.put("error", HttpStatus.NOT_FOUND.getReasonPhrase());
            body.put("message", ex.getMessage());
            return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
        }
    }
    ```

9. **Service 层抛出异常**：
    ```java
    public Task getTask(Long id) {
        return taskRepository.findById(id)
                .orElseThrow(() -> new TaskNotFoundException("Task not found with id: " + id));
    }
    ```

---

### **验证结果**
在 Postman 中调用接口，响应如下：
```json
{
    "status": 404,
    "error": "Not Found",
    "message": "Task not found with id: 123"
}
```