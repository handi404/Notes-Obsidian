你可以借助 Jackson 的注解，告诉序列化时跳过 `password` 和 `tokens` 这两个属性。有两种常用的做法：

---

### 1. 在 `User` 类上统一忽略

```java
@Entity
@Table(name = "_user")
@JsonIgnoreProperties({"password", "tokens"})
public class User implements UserDetails {
    // …
    private String password;
    // …
    @OneToMany(mappedBy = "user")
    private List<Token> tokens;
    // …
}
```

这样，不管是哪个接口返回了 `User` 对象，Jackson 都会自动忽略这两个字段。

---

### 2. 只在 `Token` 的关联处忽略

如果你只想在 `Token` → `User` 的那条关联上忽略，而其他场景仍然能序列化 `password` 或 `tokens`，可以在 `Token` 实体的 `user` 字段上加：

```java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "user_id")
@JsonIgnoreProperties({"password", "tokens"})
private User user;
```

这样，当你从 Controller 返回 `List<Token>` 时，嵌入的 `user` JSON 就不会包含 `password` 和 `tokens`。

---

### 补充

- **注意**：如果你使用的是 Spring Data REST，也可能需要在 Repository 或配置中启用 Jackson 注解的生效。
    
- **调试**：可配合打开日志 `logging.level.org.springframework.http.converter.json=DEBUG`，看实际序列化时忽略了哪些属性。
    

这样就能在 Controller 中直接返回 `List<Token>`，并且自动过滤掉敏感字段，免去手写 DTO 的麻烦。


报错：No serializer found for class org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor and no properties discovered to create BeanSerializer

你之所以会看到这个 `ByteBuddyInterceptor` 的序列化错误，是因为 Jackson 在遇到 Hibernate 的 Lazy‑Proxy 时不知道该怎么把它转换成 JSON。常见的解决方案有下面几种，任选其一即可：

---

## 1. 在实体上忽略 Hibernate 的代理属性

在 `User` 或者 `Token` 类上加上：

```java
@JsonIgnoreProperties({
    "hibernateLazyInitializer",
    "handler",
    "password",
    "tokens"
})
@Entity
@Table(name = "_user")
public class User implements UserDetails {
    // …
}
```

或者如果只想在 `Token.user` 这个关联处忽略，放在 `Token` 的 `user` 字段上：

```java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "user_id")
@JsonIgnoreProperties({
    "hibernateLazyInitializer",
    "handler",
    "password",
    "tokens"
})
private User user;
```

这样，Jackson 在序列化时既会跳过 Hibernate 加进去的代理字段，也会过滤掉 `password` 和 `tokens`。

---

## 2. 注册 Hibernate 模块，让 Jackson 识别 Lazy‑Proxy

Spring Boot 项目里，你可以在配置类里注册官方的 `Hibernate5Module`（或 `Hibernate6Module`，取决于你用的 Hibernate 版本）：

```java
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.datatype.hibernate5.Hibernate5Module;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {
    @Bean
    public Module hibernate5Module() {
        Hibernate5Module module = new Hibernate5Module();
        // 禁止强制加载 LAZY 属性，否则会触发额外查询：
        module.disable(Hibernate5Module.Feature.FORCE_LAZY_LOADING);
        return module;
    }
}
```

这个模块会自动忽略掉 `hibernateLazyInitializer`、`handler` 等内部字段，也能让你的 `@JsonIgnoreProperties({"password","tokens"})` 正常生效。

---

## 3. 用 DTO／投影

如果你想更彻底地控制输出结构，也可以在 Repository 里直接用 Spring Data 投影（interface-based 或 class-based DTO）：

```java
public interface TokenView {
    Integer getId();
    String getToken();
    TokenType getTokenType();
    boolean isRevoked();
    boolean isExpired();
    UserInfo getUser();  // 嵌套投影，仅包含你想要的字段
}

public interface UserInfo {
    Integer getId();
    String getFirstname();
    String getLastname();
    String getEmail();
    Role getRole();
}

// Repository 方法
@Query("select t from Token t where t.user.id = :id")
List<TokenView> findAllTokensByUser(Integer id);
```

这样从根本上避免了实体和序列化的耦合。

---

### 推荐

如果项目规模不大，第一种“在实体上加 `@JsonIgnoreProperties`” 就能快速解决。若你后续还会遇到 Hibernate 代理的问题，推荐再配合第 2 种，把 `Hibernate5Module` 注入到 Jackson 里。

这样就能在 Controller 里直接返回 `List<Token>`（或投影接口）了：

```java
@GetMapping("/users/{id}/tokens")
public List<Token> getTokens(@PathVariable Integer id) {
    return tokenRepository.findAllTokensByUser(id);
}
```

返回的 JSON 里就不会有代理字段、password 或 tokens 了。