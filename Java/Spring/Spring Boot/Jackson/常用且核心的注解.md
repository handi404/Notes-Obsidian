继 `@JsonProperty` 之后，我们来系统地梳理一下 Jackson 中其他常用且核心的注解。这些注解共同构成了 Jackson 强大功能的基石，能帮你精细地控制 Java 对象与 JSON 之间的序列化和反序列化过程。

我会将它们大致分类，并用同样的方式进行讲解。

---

### 一、属性级别控制注解 (Property-Level Control)

这类注解通常用于控制单个 Java 属性如何被处理。

1.  **`@JsonIgnore`**
    *   **是什么**：标记一个属性或方法，使其在序列化和反序列化过程中被**完全忽略**。
    *   **为什么需要**：
        *   排除敏感信息（如密码，即使是 WRITE_ONLY，有时也想彻底忽略）。
        *   排除内部状态或计算得出的瞬时字段。
        *   避免因 getter/setter 命名不规范而意外引入的字段。
    *   **用法**：
        ```java
        public class User {
            public String name;
            @JsonIgnore
            private String internalToken; // 这个字段不会出现在JSON中，也不会从JSON中读取
        }
        ```

2.  **`@JsonInclude`**
    *   **是什么**：在类级别或属性级别指定包含属性的条件。
    *   **为什么需要**：控制 JSON 输出的简洁性，避免不必要的 `null` 或空值字段。
    *   **核心属性 `value` (或默认)**：
        *   `JsonInclude.Include.ALWAYS` (默认): 总是包含。
        *   `JsonInclude.Include.NON_NULL`: 仅当值不为 `null` 时包含。**（非常常用）**
        *   `JsonInclude.Include.NON_ABSENT`: 对于 `java.util.Optional` 或 `AtomicReference`，如果值是 "absent" (e.g., `Optional.empty()`) 则不包含。也适用于 `NON_NULL` 的情况。
        *   `JsonInclude.Include.NON_EMPTY`: 仅当值不为 `null` 且不为空 (如空字符串、空集合/Map) 时包含。
        *   `JsonInclude.Include.CUSTOM`: 配合 `valueFilter` 使用自定义逻辑。
        *   `JsonInclude.Include.USE_DEFAULTS`: 使用全局或父级配置。
    *   **用法**：
        ```java
        @JsonInclude(JsonInclude.Include.NON_NULL) // 类级别：所有属性默认为NON_NULL
        public class Article {
            private String title;
            private String content;

            @JsonInclude(JsonInclude.Include.NON_EMPTY) // 属性级别：覆盖类级别设置
            private List<String> tags;
        }
        ```
        在 Spring Boot 中，可以通过 `spring.jackson.default-property-inclusion=non_null` 全局配置。

3.  **`@JsonFormat`**
    *   **是什么**：指定属性（特别是日期、数字）序列化和反序列化时的格式。
    *   **为什么需要**：统一或自定义日期时间、数字的表示形式。
    *   **核心属性**：
        *   `shape`: 定义数据的基本形状，如 `JsonFormat.Shape.STRING` (日期转字符串), `JsonFormat.Shape.NUMBER` (日期转时间戳), `JsonFormat.Shape.BOOLEAN` (用于 `Boolean` / `boolean`)。
        *   `pattern`: 具体的格式化模式，如 `yyyy-MM-dd HH:mm:ss`。
        *   `locale`: 地区设置，影响某些格式化（如月份名称）。
        *   `timezone`: 时区设置，如 `GMT+8` 或 `Asia/Shanghai`。
    *   **用法**：
        ```java
        public class Event {
            @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX", timezone = "UTC")
            private OffsetDateTime eventTime;

            @JsonFormat(shape = JsonFormat.Shape.NUMBER_FLOAT, pattern = "#.##")
            private BigDecimal price;
        }
        ```
        **注意**：对于 Java 8 时间 API (JSR-310)，需要 `jackson-datatype-jsr310` 模块，Spring Boot 会自动引入。

4.  **`@JsonPropertyOrder`**
    *   **是什么**：在类级别指定属性在序列化为 JSON 时的输出顺序。
    *   **为什么需要**：当需要 JSON 字段保持特定顺序时（例如为了可读性或某些严格的外部系统要求）。
    *   **核心属性 `value` (数组)**：属性名称的有序列表。
    *   `alphabetic` (boolean): 如果为 `true`，未在 `value` 中列出的属性将按字母顺序排列。
    *   **用法**：
        ```java
        @JsonPropertyOrder({ "id", "name", "email" })
        public class Customer {
            private String email;
            private Long id;
            private String name;
        }
        // JSON 输出会是: {"id":..., "name":..., "email":...}
        ```

5.  **`@JsonAlias`**
    *   **是什么**：为一个属性在**反序列化**时定义一个或多个别名。
    *   **为什么需要**：
        *   API 版本迭代，字段名改变，但仍需兼容旧的字段名。
        *   接受来自不同来源但意义相同的字段名。
    *   **用法**：
        ```java
        public class Product {
            @JsonAlias({ "product_name", "item_name" }) // "product_name" 或 "item_name" 都能映射到 "name"
            private String name;
            private double price;
        }
        // JSON: {"product_name": "Laptop"} 或 {"item_name": "Laptop"} 都能反序列化
        ```

---

### 二、构造与设值注解 (Construction & Setting)

这类注解主要影响对象的创建和属性值的设置过程（反序列化）。

1.  **`@JsonCreator`**
    *   **是什么**：标记一个构造函数或静态工厂方法，Jackson 将使用它来创建对象实例进行反序列化。
    *   **为什么需要**：
        *   用于不可变对象 (immutable objects) 的反序列化。
        *   当有多个构造函数或需要使用静态工厂方法创建实例时。
        *   与 `@JsonProperty` 结合使用，明确指定构造参数对应的 JSON 字段。
    *   **模式 `mode`**:
        *   `JsonCreator.Mode.DEFAULT`: 自动检测（通常基于参数名或 `@JsonProperty`）。
        *   `JsonCreator.Mode.PROPERTIES`: 参数必须通过 `@JsonProperty` 显式绑定到 JSON 属性。**（推荐用于多参数构造函数）**
        *   `JsonCreator.Mode.DELEGATING`: 单参数构造函数，整个 JSON 对象（或值）被传递给该参数进行处理。
        *   `JsonCreator.Mode.DISABLED`: 禁用此构造函数/工厂方法。
    *   **用法**：
        ```java
        public class ImmutablePoint {
            private final int x;
            private final int y;

            @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
            public ImmutablePoint(@JsonProperty("x_coord") int x, @JsonProperty("y_coord") int y) {
                this.x = x;
                this.y = y;
            }
            // getters
        }
        ```

2.  **`@JsonSetter`**
    *   **是什么**：标记一个 setter 方法，或用于定制 setter 的行为（如处理 `null` 值）。可以用来覆盖默认的 setter 发现机制或指定不同的 JSON 属性名。
    *   **为什么需要**：
        *   当 setter 方法名不符合标准 JavaBean 规范时 (如 `assignValue(int v)` 而不是 `setValue(int v)`)。
        *   精细控制 `null` 值的处理。
    *   **核心属性**：
        *   `value`: 指定此 setter 对应的 JSON 属性名（类似 `@JsonProperty`）。
        *   `nulls`: 如何处理 JSON 中的 `null` 值。
            *   `Nulls.SET` (默认): 调用 setter 并传入 `null`。
            *   `Nulls.SKIP`: 如果 JSON 值为 `null`，则不调用此 setter。
            *   `Nulls.FAIL`: 如果 JSON 值为 `null`，则反序列化失败。
            *   `Nulls.AS_EMPTY`: 尝试将 `null` 转换为空等价值 (如空集合/字符串，0，false)，具体行为依赖于属性类型和配置。
        *   `contentNulls`: 类似 `nulls`，但用于容器类型（List, Map）的元素/值的 `null`。
    *   **用法**：
        ```java
        public class Config {
            private List<String> features = new ArrayList<>();

            @JsonSetter(value = "active_features", nulls = Nulls.AS_EMPTY)
            public void setFeatures(List<String> features) {
                this.features = features; // 如果 JSON 中 "active_features" 为 null，则 features 会被设为空列表
            }
        }
        ```

3.  **`@JacksonInject`**
    *   **是什么**：标记一个属性或构造/工厂方法参数，其值不是从 JSON 数据中获取，而是由 Jackson 在反序列化时**注入**。
    *   **为什么需要**：注入上下文信息、配置或其他在 JSON 数据之外但在反序列化时需要的值。
    *   **核心属性 `value`**: 注入值的标识符。需要通过 `ObjectMapper.setInjectableValues()` 提供这些值。
    *   **用法**：
        ```java
        public class ContextualData {
            @JacksonInject("requestId") // "requestId" 将被注入
            private String requestId;
            private String payload;

            // ... getters, setters
        }
        // 使用时:
        // InjectableValues injects = new InjectableValues.Std().addValue("requestId", "ABC-123");
        // MyObject obj = objectMapper.reader(injects).forType(ContextualData.class).readValue(jsonString);
        ```
        在 Spring 中，可以通过自定义 `HandlerMethodArgumentResolver` 或 AOP 来实现类似注入。

---

### 三、类级别与全局行为注解 (Class-Level & Global Behavior)

1.  **`@JsonIgnoreProperties`**
    *   **是什么**：在类级别标记，用于指定在序列化或反序列化时要忽略的一组属性名称。
    *   **为什么需要**：
        *   批量忽略多个属性。
        *   `ignoreUnknown = true`: 非常有用，当 JSON 中包含 Java 对象没有的字段时，不抛出异常而是直接忽略它们。
        *   处理双向关联时，避免无限递归（虽然 `@JsonManagedReference` / `@JsonBackReference` 或 `@JsonIdentityInfo` 更推荐）。
    *   **核心属性**：
        *   `value` (String[]): 要忽略的属性名列表。
        *   `ignoreUnknown` (boolean, 默认为 `false`): 是否忽略未在 Java 类中定义的属性。
        *   `allowGetters` (boolean, 默认为 `false`): 如果为 `true`，即使属性在忽略列表里，其 getter 仍然可能被调用（不常用）。
        *   `allowSetters` (boolean, 默认为 `false`): 类似 `allowGetters`，针对 setter。
    *   **用法**：
        ```java
        @JsonIgnoreProperties(value = { "password", "secretKey" }, ignoreUnknown = true)
        public class Account {
            public String username;
            private String password; // 会被忽略
            private String secretKey; // 会被忽略
            public String email;
        }
        // JSON: {"username":"test", "email":"t@e.com", "extraField":"ignored"} 不会报错
        ```
        Spring Boot 默认会将 `spring.jackson.deserialization.fail-on-unknown-properties=false`，等效于全局 `@JsonIgnoreProperties(ignoreUnknown = true)`。

2.  **`@JsonRootName`**
    *   **是什么**：当启用了 `SerializationFeature.WRAP_ROOT_VALUE` 或 `DeserializationFeature.UNWRAP_ROOT_VALUE` 时，用于指定序列化/反序列化时根级别包装的名称。
    *   **为什么需要**：某些 API 规范要求 JSON 对象被一个根键包裹。
    *   **用法**：
        ```java
        @JsonRootName("userDetails")
        public class User {
            public String name;
        }
        // 配合 ObjectMapper 配置:
        // objectMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);
        // objectMapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);
        // 序列化结果: {"userDetails": {"name": "John"}}
        // 反序列化时也需要这个包装
        ```

3.  **`@JsonAutoDetect`**
    *   **是什么**：在类级别细粒度控制 Jackson 如何自动发现属性（字段、getter、setter、creator）。
    *   **为什么需要**：当默认的可见性规则（通常是 public getters/setters/fields，具体取决于版本和配置）不符合需求时。
    *   **核心属性 (Visibility 枚举)**：`fieldVisibility`, `getterVisibility`, `setterVisibility`, `creatorVisibility`, `isGetterVisibility`。
        *   `JsonAutoDetect.Visibility.ANY`: 任何修饰符都可见。
        *   `JsonAutoDetect.Visibility.NONE`: 任何修饰符都不可见（除非显式注解）。
        *   `JsonAutoDetect.Visibility.PUBLIC_ONLY` (通常是默认): 仅 public 可见。
        *   `JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC`: ...
        *   `JsonAutoDetect.Visibility.DEFAULT`: 继承全局设置。
    *   **用法**：
        ```java
        @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY, // 所有字段都参与序列化/反序列化
                        getterVisibility = JsonAutoDetect.Visibility.NONE, // 忽略所有getter
                        setterVisibility = JsonAutoDetect.Visibility.NONE)  // 忽略所有setter
        public class PojoWithFields {
            private String id;
            String name; // package-private 也会被序列化
            protected int value; // protected 也会
        }
        ```

---

### 四、处理继承与多态 (Inheritance & Polymorphism)

1.  **`@JsonTypeInfo`**
    *   **是什么**：在处理继承关系时，指示如何在 JSON 中包含类型信息，以便反序列化时能正确实例化子类。通常用在父类或接口上。
    *   **为什么需要**：当反序列化一个声明为父类/接口类型的属性，但实际可能是任何一个子类实例时。
    *   **核心属性**：
        *   `use`: 类型标识符的机制。
            *   `JsonTypeInfo.Id.CLASS`: 使用完整的类名 (`com.example.Dog`)。
            *   `JsonTypeInfo.Id.MINIMAL_CLASS`: 使用最短的唯一类名 (`.Dog` 如果在同一个包下没有歧义)。
            *   `JsonTypeInfo.Id.NAME`: 使用 `@JsonTypeName` 定义的逻辑名称。**（推荐）**
            *   `JsonTypeInfo.Id.CUSTOM`: 自定义类型解析。
        *   `include`: 类型信息如何包含在 JSON 中。
            *   `JsonTypeInfo.As.PROPERTY`: 作为一个额外的属性 (e.g., `{"@type": "dog", "name": "Buddy"}`)。
            *   `JsonTypeInfo.As.WRAPPER_OBJECT`: 类型名作为包装对象的键 (e.g., `{"dog": {"name": "Buddy"}}`)。
            *   `JsonTypeInfo.As.WRAPPER_ARRAY`: 类型名作为包装数组的第一个元素 (e.g., `["dog", {"name": "Buddy"}]`)。
            *   `JsonTypeInfo.As.EXTERNAL_PROPERTY`: 类型信息作为与实际数据同级的外部属性（需要特殊结构）。
        *   `property`: 当 `include` 是 `PROPERTY` 或 `EXTERNAL_PROPERTY` 时，类型信息的属性名 (默认为 `@class` 或 `@type`，取决于 `use` 的值)。
        *   `visible` (boolean): 类型信息属性是否在反序列化后也作为 Java 对象的属性可见。
        *   `defaultImpl`: 如果类型信息缺失或无法识别，默认实例化的类。
    *   **用法**：
        ```java
        @JsonTypeInfo(
            use = JsonTypeInfo.Id.NAME,
            include = JsonTypeInfo.As.PROPERTY,
            property = "type" // JSON中会有一个 "type" 字段来指明具体子类
        )
        @JsonSubTypes({ // 列出所有可能的子类及其名称
            @JsonSubTypes.Type(value = Dog.class, name = "dog"),
            @JsonSubTypes.Type(value = Cat.class, name = "cat")
        })
        public abstract class Animal {
            public String name;
        }

        @JsonTypeName("dog") // 与 @JsonSubTypes.Type 中的 name 对应
        public class Dog extends Animal {
            public int boneCount;
        }

        @JsonTypeName("cat")
        public class Cat extends Animal {
            public boolean likesCream;
        }
        ```

2.  **`@JsonSubTypes`**
    *   **是什么**：与 `@JsonTypeInfo` 配合使用，显式列出所有已知的子类型及其逻辑名称或类。
    *   **用法**：见 `@JsonTypeInfo` 示例。

3.  **`@JsonTypeName`**
    *   **是什么**：在子类上定义一个逻辑类型名称，当 `@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)` 时使用。
    *   **用法**：见 `@JsonTypeInfo` 示例。

---

### 五、处理对象引用与循环依赖 (References & Cycles)

1.  **`@JsonManagedReference` 和 `@JsonBackReference`**
    *   **是什么**：用于解决双向关联（父子关系）导致的序列化无限循环问题。
        *   `@JsonManagedReference`: 标记“正向”或父级部分，会被正常序列化。
        *   `@JsonBackReference`: 标记“反向”或子级部分，在序列化时不会被包含进来，以打破循环。但在反序列化时，它会从父级那里正确链接回来。
    *   **为什么需要**：防止 `StackOverflowError`。
    *   **用法**：
        ```java
        public class User {
            public String name;
            @JsonManagedReference // User 是 "owner" of items
            public List<Item> items = new ArrayList<>();
        }

        public class Item {
            public String itemName;
            @JsonBackReference // Item "belongs to" a User
            public User owner;
        }
        ```

2.  **`@JsonIdentityInfo`**
    *   **是什么**：更通用的解决对象图循环依赖和共享引用的方法。它通过为对象分配 ID 来实现。第一次遇到对象时，会完整序列化并带上 ID；后续再遇到相同对象时，只序列化其 ID。
    *   **为什么需要**：处理复杂的对象图，不仅仅是简单的父子关系，也包括多对多或更复杂的循环。
    *   **核心属性**：
        *   `generator`: ID 生成策略。
            *   `ObjectIdGenerators.IntSequenceGenerator`: 基于整数序列。
            *   `ObjectIdGenerators.PropertyGenerator`: 使用对象的一个属性作为 ID。
            *   `ObjectIdGenerators.UUIDGenerator`: 使用 UUID。
        *   `property`: ID 在 JSON 中显示的属性名 (默认为 `@id`)。
        *   `scope`: ID 的作用域（通常是类）。
    *   **用法**：
        ```java
        @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id")
        public class Employee {
            public int id;
            public String name;
            public List<Employee> reports = new ArrayList<>(); // 可能有循环引用
            // ...
        }
        ```

---

### 六、特殊值处理与视图 (Special Value Handling & Views)

1.  **`@JsonValue`**
    *   **是什么**：标记一个**无参方法**或**字段**，表示该对象的整个 JSON 表示就是这个方法/字段的返回值。
    *   **为什么需要**：当你想将一个复杂对象序列化为一个简单的值时（如枚举序列化为特定字符串，或一个对象只用其 ID 表示）。
    *   **用法**：
        ```java
        public enum Distance {
            KILOMETER("km"), MILE("miles");

            private String unit;
            Distance(String unit) { this.unit = unit; }

            @JsonValue // 序列化时会调用这个方法
            public String getUnit() { return unit; }
        }
        // Distance.KILOMETER 会序列化为 "km"
        ```
        ```java
        public class UserId {
            private final String idValue;
            public UserId(String id) { this.idValue = id; }

            @JsonValue
            public String getIdValue() { return idValue; }
        }
        // new UserId("user123") 会序列化为 "user123"
        ```

2.  **`@JsonRawValue`**
    *   **是什么**：标记一个属性（通常是 String 类型），其值会被**原样**作为 JSON（而不是 JSON 字符串）插入到输出中。
    *   **为什么需要**：当你有一个属性本身就包含了一段合法的 JSON 字符串，并且你希望它直接嵌入到最终的 JSON 结构中，而不是被转义成一个 JSON 字符串值。
    *   **用法**：
        ```java
        public class ConfigHolder {
            public String name;
            @JsonRawValue // rawJsonContent 必须是合法的JSON片段
            public String rawJsonContent = "{\"enabled\": true, \"count\": 10}";
        }
        // 序列化结果: {"name": "someName", "rawJsonContent": {"enabled": true, "count": 10}}
        // 注意 rawJsonContent 的值没有被引号包裹和转义
        ```

3.  **`@JsonView`**
    *   **是什么**：允许你定义一个 Java 对象属性的多个“视图”，在序列化时根据当前激活的视图来决定哪些属性被包含。
    *   **为什么需要**：当同一个对象需要在不同场景下（如公共 API vs 内部使用 vs 管理界面）暴露不同子集的属性时。
    *   **用法**：
        *   首先定义视图类（通常是空接口或静态内部类）：
            ```java
            public class Views {
                public static class Public {}
                public static class Internal extends Public {} // Internal 视图包含 Public 视图
                public static class Admin extends Internal {}
            }
            ```
        *   在 POJO 属性上使用 `@JsonView`：
            ```java
            public class User {
                @JsonView(Views.Public.class) // 在 Public, Internal, Admin 视图中都可见
                public String username;

                @JsonView(Views.Internal.class) // 仅在 Internal, Admin 视图中可见
                public String email;

                @JsonView(Views.Admin.class) // 仅在 Admin 视图中可见
                private String ssn;
            }
            ```
        *   序列化时指定视图：
            ```java
            // ObjectMapper objectMapper = ...;
            // User user = ...;
            // String publicJson = objectMapper.writerWithView(Views.Public.class).writeValueAsString(user);
            // publicJson 会包含 username
            // String internalJson = objectMapper.writerWithView(Views.Internal.class).writeValueAsString(user);
            // internalJson 会包含 username 和 email
            ```
        在 Spring MVC/WebFlux 中，可以直接在 `@RestController` 方法上使用 `@JsonView` 注解，或者在返回的 `ResponseEntity` 中指定。

---

### 七、其他实用注解

1.  **`@JsonUnwrapped`**
    *   **是什么**：标记一个属性（通常是另一个 POJO），在序列化/反序列化时，将其属性“解包”或“扁平化”到父对象的层级。
    *   **为什么需要**：避免不必要的 JSON 嵌套层级，使结构更扁平。
    *   **用法**：
        ```java
        public class Address {
            public String street;
            public String city;
        }

        public class Person {
            public String name;
            @JsonUnwrapped // Address 的属性会直接出现在 Person 的JSON中
            public Address address;
        }
        // Person p = new Person(); p.name = "John"; p.address = new Address(); p.address.street = "123 Main"; p.address.city = "Anytown";
        // 序列化结果: {"name": "John", "street": "123 Main", "city": "Anytown"}
        ```

2.  **`@JsonAnyGetter` 和 `@JsonAnySetter`**
    *   **是什么**：
        *   `@JsonAnyGetter`: 标记一个返回 `Map<String, Object>` 的方法。这个 Map 中的键值对会被序列化为 JSON 的顶级属性。
        *   `@JsonAnySetter`: 标记一个接受两个参数 `(String name, Object value)` 的方法。当 JSON 中出现未在 Java 类中显式定义的属性时，这些属性会通过此方法被设置到一个内部 Map 中。
    *   **为什么需要**：处理动态的、非预先定义的属性集。
    *   **用法**：
        ```java
        public class FlexibleBean {
            public String name;
            private Map<String, Object> properties = new HashMap<>();

            @JsonAnyGetter // 序列化时，properties map中的内容会成为顶级字段
            public Map<String, Object> getProperties() {
                return properties;
            }

            @JsonAnySetter // 反序列化时，未匹配的字段会进入这里
            public void add(String key, Object value) {
                properties.put(key, value);
            }
        }
        // FlexibleBean bean = new FlexibleBean(); bean.name = "MyBean"; bean.getProperties().put("attr1", "value1");
        // 序列化: {"name":"MyBean", "attr1":"value1"}
        // JSON: {"name":"MyBean", "customField":123} -> customField 会被 add("customField", 123) 处理
        ```

---

**核心要点与 Spring Boot 结合：**

*   **Spring Boot 自动配置 `ObjectMapper`**：Spring Boot 会自动配置一个 `ObjectMapper` Bean。上述所有注解都会被这个默认的 `ObjectMapper` 识别和处理。
*   **全局配置 vs. 注解**：
    *   许多 Jackson 行为可以通过 `application.properties` 或 `application.yml` 全局配置 (e.g., `spring.jackson.property-naming-strategy`, `spring.jackson.default-property-inclusion`, `spring.jackson.deserialization.fail-on-unknown-properties`)。
    *   注解通常用于**覆盖全局配置**或进行更细粒度的控制。
*   **Jackson Modules**：Spring Boot 会自动注册常用的 Jackson 模块，如：
    *   `jackson-datatype-jdk8`: 支持 `Optional` 等。
    *   `jackson-datatype-jsr310`: 支持 Java 8 Date/Time API (`LocalDate`, `LocalDateTime` 等)。
    *   `jackson-module-parameter-names`: 支持通过构造函数/方法参数名进行反序列化（需要 Java 8 `-parameters` 编译选项）。
*   **自定义 `ObjectMapper`**：如果需要更深度的定制，可以提供一个 `Jackson2ObjectMapperBuilderCustomizer` Bean，或者完全替换 `ObjectMapper` Bean。

这些是 Jackson 中最核心和常用的一批注解。掌握它们能让你在 Spring Boot (及其他 Java 环境) 中游刃有余地处理 JSON 数据。它们的设计非常灵活，能够满足从简单到复杂场景的各种需求。