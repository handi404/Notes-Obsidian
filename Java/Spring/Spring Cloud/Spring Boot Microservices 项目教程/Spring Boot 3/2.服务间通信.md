在本 **Spring Boot 微服务教程** 系列的第 2 部分中，我们将使用 Spring Cloud OpenFeign 库实现 Order Service 和 Inventory Service 之间的同步通信。

Spring Cloud OpenFeign 库使用提供与 Spring Boot 和 Spring Cloud 的 OpenFeign 集成。它提供了一个声明式 REST 客户端，使在我们的代码中使用 REST 端点变得容易。

我们将使用 [Spring Cloud OpenFeign](https://spring.io/projects/spring-cloud-openfeign) 库实现 Order Service 和 Inventory Service 之间的同步通信。

## 将 Spring Cloud OpenFeign 添加到 Order 服务

首先，让我们将 Spring Cloud OpenFeign Starter 添加到 Order Service 的 pom.xml 文件中。

**pom.xml**

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

我们还需要将 spring-cloud-dependencies bom 依赖项添加到 pom.xml 文件中的 `<dependencyManagement>` 部分。

```
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

这是你的 pom.xml 最后的样子：

**pom.xml**

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>microservices-new</artifactId>
        <groupId>com.programming.techie</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>order-service</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-mysql</artifactId>
        </dependency>
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-testcontainers</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>mysql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <version>5.3.2</version>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

## 为 Inventory Service 创建 FeignClient

由于我们将从 Order Service 调用 Inventory Service，因此我们需要在 order-service 内的 client 包中创建一个名为 InventoryClient.java 的类。

**客户/InventoryClient.java**

```
package com.programmingtechie.orderservice.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(value = "inventory", url = "${inventory.url}")
public interface InventoryClient {
    @RequestMapping(method = RequestMethod.GET, value = "/api/inventory")
    boolean isInStock(@RequestParam String skuCode, @RequestParam Integer quantity);
}
```

请注意，@FeignClient 注释具有一个名为 URL 的属性，该属性指向 application.properties 文件中的 inventory.url 属性

```
inventory.url=http://localhost:8082
```

通过外部化此属性，我们可以在测试中或启动时动态替换它。

来到该方法，我们有调用路径 /api/inventory 的 @RequestMapping 注解。

现在我们必须从 Order Service 的 placeOrder() 方法调用 **isInStock（）** 方法。

如果客户端返回 true，那么我们将下订单并成功保存到数据库中，否则，我们将抛出 Runtime 异常

下面是 OrderService 类的最终逻辑的外观。

**OrderService.java**

```
package com.programmingtechie.orderservice.service;

import com.programmingtechie.orderservice.client.InventoryClient;
import com.programmingtechie.orderservice.dto.OrderRequest;
import com.programmingtechie.orderservice.model.Order;
import com.programmingtechie.orderservice.repository.OrderRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
@RequiredArgsConstructor
@Transactional
public class OrderService {

    private final OrderRepository orderRepository;
    private final InventoryClient inventoryClient;

    public void placeOrder(OrderRequest orderRequest) {
        boolean inStock = inventoryClient.isInStock(orderRequest.skuCode(), orderRequest.quantity());
        if (inStock) {
            var order = mapToOrder(orderRequest);
            orderRepository.save(order);
        } else {
            throw new RuntimeException("Product with Skucode " + orderRequest.skuCode() + "is not in stock");
        }
    }

    private static Order mapToOrder(OrderRequest orderRequest) {
        Order order = new Order();
        order.setOrderNumber(UUID.randomUUID().toString());
        order.setPrice(orderRequest.price());
        order.setQuantity(orderRequest.quantity());
        order.setSkuCode(orderRequest.skuCode());
        return order;
    }
}
```

在我们继续测试我们的实现之前，我们必须添加 @EnableFeignClients 注解以启用 Feign Client Capabilities

**OrderServiceApplication.java**

```
package com.programmingtechie.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

}
```

## 使用 Postman 进行手动测试

现在是时候使用 Postman 测试我们的实施了，确保您同时启动 Order Service 和 Inventory Service，并调用 Order Service 的 Place Order 端点。

让我们订购数量为 100 的 skuCode iphone\_15，因为在第 -1 部分中，我们初始化了数量为 100 的所有 skuCode，此产品应该有库存，我们的订单应该通过。

现在，让我们将数量更改为 101，这次我们的 Order 调用应该失败，并出现 500 错误。

如果您观察日志，则应看到以下异常消息：

```
java.lang.RuntimeException: Product with Skucode iphone_15is not in stock
```

## 更新集成测试

现在，如果您在 order 服务中运行我们的集成测试，您将注意到它们不再成功运行，因为我们正在调用 Inventory Service。

为了使这些测试成功，我们必须使用一个名为 Wiremock 的库，它提供了一个模拟服务器环境，通过进行一些模拟 HTTP 调用来测试我们的 Order Service。

通过使用 Wiremock，我们可以验证我们的 Order Service 是否使用正确的 URL Params/Request Body/Path Variables 调用库存服务。我们还可以对响应进行存根，并测试我们的服务如何响应各种场景。

要启用 wiremock，我们需要将以下依赖项添加到 Order Service 的 pom.xml 文件中

**pom.xml**

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
    <scope>test</scope>
</dependency>
```

以下是更新集成测试的样子：

**OrderServiceApplicationTests.java**

```
package com.programmingtechie.orderservice;

import com.programmingtechie.orderservice.stub.InventoryStubs;
import io.restassured.RestAssured;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.springframework.cloud.contract.wiremock.AutoConfigureWireMock;
import org.testcontainers.containers.MySQLContainer;

import static org.hamcrest.MatcherAssert.assertThat;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWireMock(port = 0)
class OrderServiceApplicationTests {

    @ServiceConnection
    static MySQLContainer mySQLContainer = new MySQLContainer("mysql:8.3.0");
    @LocalServerPort
    private Integer port;

    @BeforeEach
    void setup() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = port;
    }

    static {
        mySQLContainer.start();
    }

    @Test
    void shouldSubmitOrder() {
        String submitOrderJson = """
                {
                     "skuCode": "iphone_15",
                     "price": 1000,
                     "quantity": 1
                }
                """;

        InventoryStubs.stubInventoryCall("iphone_15", 1);
        var responseBodyString = RestAssured.given()
                .contentType("application/json")
                .body(submitOrderJson)
                .when()
                .post("/api/order")
                .then()
                .log().all()
                .statusCode(201)
                .extract()
                .body().asString();

        assertThat(responseBodyString, Matchers.is("Order Placed Successfully"));
    }
}
```

**application.properties**

```
inventory.url=http://localhost:${wiremock.server.port}
```

**InventoryStubs.java**

```
package com.programmingtechie.orderservice.stub;

import lombok.experimental.UtilityClass;

import static com.github.tomakehurst.wiremock.client.WireMock.*;

@UtilityClass
public class InventoryStubs {

    public void stubInventoryCall(String skuCode, Integer quantity) {
        stubFor(get(urlEqualTo("/api/inventory?skuCode=" + skuCode + "&quantity=" + quantity))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withHeader("Content-Type", "application/json")
                        .withBody("true")));
    }
}
```

## 结论

这就是本教程的第 -2 部分的内容，在下一部分中，我们将学习如何使用 Netflix Eureka 实现服务发现。