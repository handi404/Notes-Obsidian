

### 简介

在本 Spring Boot 微服务教程系列中，您将学习如何使用 Spring Boot 和 Spring Cloud 开发微服务架构的应用程序，并使用 Docker 和 Kubernetes 进行部署。

本教程系列将涵盖多个概念和微服务架构模式，以下是每部分将要涉及的主题：

- 第 1 部分介绍了使用 Spring Boot 3 构建基于 REST 的应用程序并遵循一些最佳实践。
- 本教程系列的第 2 部分涵盖了使用 Spring Cloud Open Feign 的同步服务间通信模式。
- 第 3 部分介绍了使用 Spring Cloud Netflix Eureka 的 Service Discovery 模式
- 第 4 部分介绍了使用 Spring Cloud Gateway 的 API 网关模式
- 第 5 部分介绍了使用 Keycloak 的微服务安全
- 第 6 部分介绍了使用 Spring Cloud CircuitBreaker 和 Resilience4J 的 Circuit Breaker 模式
- 第 7 部分介绍了使用 Kafka 的事件驱动架构模式
- 第 8 部分介绍了可观测性模式，我们将实现使用 Open Telemetry 和 Grafana Tempo 的分布式跟踪，我们将实现日志聚合模式以使用 Grafana Loki 查看我们服务的日志，我们将使用 Prometheus 收集指标，并使用 Grafana 在仪表板中可视化指标
- 在第 9 部分，我们将使用 Docker 容器化所有应用程序。我们将了解如何使用 Docker Compose 运行我们的应用程序
- 在第 10 部分，我们将将我们的 Docker Compose 工作负载迁移到 Kubernetes

## 应用概述

我们将构建一个简单的电子商务应用程序，客户可以在其中订购产品。我们的应用程序包含以下服务：

- Product Service
- Order Service
- Inventory Service
- Notification Service

为了专注于 Spring Cloud 和微服务的原则，我们将开发具有基本功能的服务，而不是创建功能齐全的电子商务服务。

## 下载源代码

您可以通过 Github 下载此项目的源代码 - https://github.com/SaiUpadhyayula/spring-boot-microservices/tree/initial-setup

## 项目架构图

以下是本教程系列将要介绍的项目的架构图

## 创建我们的第一个微服务：产品服务

让我们开始创建我们的第一个微服务（产品服务）。如前所述，我们将保持此服务简单，仅包括最重要的功能。

我们将公开一个 REST API 端点，用于创建和读取产品。

| **服务操作** | **HTTP 方法** | **服务端点** |
| --- | --- | --- |
| 创建产品 | POST | /api/product/ |
| 查看所有产品 | GET | /api/product/ |

产品服务 REST 操作

创建项目，请访问 start.spring.io，并根据以下配置创建我们的项目：

以下是你需要添加的依赖项：

- Lombok
- Spring Web
- Testcontainers
- Spring Data MongoDB
- Java 21
- Maven 作为构建工具

我们将使用 MongoDB 作为 Product 服务的数据库后端

添加必要的配置后，点击生成按钮，源代码应下载到您的机器上。

解压源代码，并在您喜欢的 IDE 中打开。

打开项目后，运行以下命令来构建项目：

```
mvn clean verify
```

应用程序应成功构建，没有任何错误。

### 使用 Docker 和 Docker Compose 下载 MongoDB

我们将使用 Docker 来安装此项目所需的软件，如数据库、消息队列和其他所需软件。

如果您的机器上没有安装 Docker，您可以在此链接下载：https://docs.docker.com/get-docker/

一旦安装了 Docker，在根目录下创建一个名为 docker-compose.yml 的文件：

```bash
version: '4'
services:
  mongo:
    image: mongo:7.0.5
    container_name: mongo
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: password
      MONGO_INITDB_DATABASE: product-service
    volumes:
      - ./docker/mongodb/data:/data/db
```

我们需要在 application.properties 文件中配置 MongoDB URI 详情：

```
spring.data.mongodb.uri=mongodb://root:password@localhost:27017/product-service?authSource=admin
```

> 如果您不了解如何使用 MongoDB 和 Spring Boot，去看 Spring Boot MongoDB REST API 教程

### 创建创建和读取端点

让我们创建以下模型类，它作为产品的领域。

**Product.java**

```
package com.programmingtechie.productservice.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.math.BigDecimal;

@Document(value = "product")
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
public class Product {

    @Id
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
}
```

接下来，让我们为 Product 类创建 Spring Data MongoDB 接口 - ProductRepository.java

**产品仓库.java**

```
package com.programming.techie.productservice.repository;

import com.programming.techie.productservice.model.Product;
import org.springframework.data.mongodb.repository.MongoRepository;

public interface ProductRepository extends MongoRepository<Product, String> {
}
```

现在让我们创建服务类 - ProductService.java，它包含我们产品服务的实际业务逻辑，负责从数据库中创建和读取产品。

**产品服务.java**

```
package com.programmingtechie.productservice.service;

import com.programmingtechie.productservice.dto.ProductRequest;
import com.programmingtechie.productservice.dto.ProductResponse;
import com.programmingtechie.productservice.model.Product;
import com.programmingtechie.productservice.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class ProductService {

    private final ProductRepository productRepository;

    public void createProduct(ProductRequest productRequest) {
        Product product = Product.builder()
                .name(productRequest.name())
                .description(productRequest.description())
                .price(productRequest.price())
                .build();

        productRepository.save(product);
        log.info("Product {} is saved", product.getId());
    }

    public List<ProductResponse> getAllProducts() {
        List<Product> products = productRepository.findAll();

        return products.stream().map(this::mapToProductResponse).toList();
    }

    private ProductResponse mapToProductResponse(Product product) {
        return new ProductResponse(product.getId(), product.getName(),
                product.getDescription(), product.getPrice());
    }
}
```

接下来，我们需要一个控制器类，该类公开 POST 和 GET 端点以创建和读取产品。

**ProductRestController.java 产品控制器.java**

```
package com.programmingtechie.productservice.controller;

import com.programmingtechie.productservice.dto.ProductRequest;
import com.programmingtechie.productservice.dto.ProductResponse;
import com.programmingtechie.productservice.service.ProductService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/product")
@RequiredArgsConstructor
public class ProductController {

    private final ProductService productService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public void createProduct(@RequestBody ProductRequest productRequest) {
        productService.createProduct(productRequest);
    }

    @GetMapping
    @ResponseStatus(HttpStatus.OK)
    public List<ProductResponse> getAllProducts() {
        return productService.getAllProducts();
    }

}
```

产品控制器类使用 ProductRequest 和 ProductResponse 作为 DTOs，我们也要创建这些记录

**产品请求.java**

```
package com.programmingtechie.productservice.dto;

import java.math.BigDecimal;

public record ProductRequest(String name, String description, BigDecimal price) {
}
```

**ProductResponse.java**

```
package com.programmingtechie.productservice.dto;

import java.math.BigDecimal;

public record ProductResponse(String id, String name, String description, BigDecimal price) {
}
```

### 测试产品服务 API

让我们启动应用程序并测试我们的两个端点

我们将通过调用 URL http://localhost:8080/api/product 并使用 HTTP 方法 POST 来创建一个产品，这个 REST 调用应该返回状态码 201。

现在让我们向 URL - http://localhost:8080/api/product 发起一个 GET 调用，以测试创建的产品是否作为响应返回。

### 为产品服务编写集成测试

让我们编写几个集成测试来测试我们的创建产品和获取产品端点，对于集成测试，由于我们需要一个真实的 Mongo 数据库，我们将使用 TestContainers 来启动 MongoDB 容器作为测试的一部分。

如果你不知道 Testcontainers，你可以在这里了解更多：https://testcontainers.com/

在编写测试之前，我们需要向我们的 pom.xml 文件中添加一个依赖项：

```
<dependency>
    <groupId>io.rest-assured</groupId>
    <artifactId>rest-assured</artifactId>
    <version>5.3.2</version>
</dependency>
```

我们添加了 rest-assured 依赖项，因为我们需要在运行集成测试时调用端点需要一个真实的 HTTP 客户端。

让我们使用以下代码创建集成测试：

**ProductServiceApplicationTests.java**

```
package com.programmingtechie.productservice;

import com.programmingtechie.productservice.dto.ProductRequest;
import io.restassured.RestAssured;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.testcontainers.containers.MongoDBContainer;

import java.math.BigDecimal;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ProductServiceApplicationTests {

    @ServiceConnection
    static MongoDBContainer mongoDBContainer = new MongoDBContainer("mongo:7.0.7");
    @LocalServerPort
    private Integer port;

    @BeforeEach
    void setup() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = port;
    }

    static {
        mongoDBContainer.start();
    }

    @Test
    void shouldCreateProduct() throws Exception {
        ProductRequest productRequest = getProductRequest();

        RestAssured.given()
                .contentType("application/json")
                .body(productRequest)
                .when()
                .post("/api/product")
                .then()
                .log().all()
                .statusCode(201)
                .body("id", Matchers.notNullValue())
                .body("name", Matchers.equalTo(productRequest.name()))
                .body("description", Matchers.equalTo(productRequest.description()))
                .body("price", Matchers.is(productRequest.price().intValueExact()));
    }

    private ProductRequest getProductRequest() {
        return new ProductRequest("iPhone 13", "iPhone 13", BigDecimal.valueOf(1200));
    }

}
```

## 创建第二个微服务 - 订单服务

现在让我们创建我们的第二个微服务，订单服务，这个服务只包含一个端点，用于提交订单。

| **服务操作** | **端点方法** | **服务端点** |
| --- | --- | --- |
| 下订单 | POST | /api/order |

订单服务操作

访问 start.spring.io 网站来创建项目

创建项目，以下为所需依赖项：

- Spring Web
- Lombok
- Spring Data JPA
- MySQL Driver
- Flyway Migration
- Testcontainers
- 我们还将使用 Java 21 为此服务，并使用 Maven 作为构建工具。

在 Order 服务中，我们将使用 MySQL 数据库，所以让我们继续使用 docker-compose 下载 MySQL。

创建一个包含以下内容的 docker-compose.yml 文件：

```
version: '4'
services:
  mysql:
    image: mysql:8.3.0
    container_name: mysql
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: mysql
    volumes:
      - ./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql
      - ./docker/mysql/data:/var/lib/mysql
```

我们需要在 MySQL 数据库启动时创建数据库模式，为此我们添加了以下行：./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql，这要求 docker 将 SQL 文件从'mysql'文件夹复制到 docker-entrypoint-initdb.d 位置并执行该 SQL 文件。

如果我们不添加上述步骤，那么我们需要手动创建数据库。

现在让我们通过在 application.properties 文件中添加以下属性来配置我们的项目以使用 MySQL：

```bash
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/order_service
spring.datasource.username=root
spring.datasource.password=mysql
spring.jpa.hibernate.ddl-auto=none
server.port=8081
```
- 我们使用 spring.jpa.hibernate.ddl-auto 属性设置为 none，因为我们不想让 Hibernate 创建数据库表和管理迁移，我们将使用 Flyway 库来处理这些。
- 注意我们正在 8081 端口上运行 order-service 应用程序，因为 product-service 已经在 8080 端口上运行

### Flyway 数据库迁移

如前所述，我们将使用 Flyway 来执行数据库迁移，该项目的必要依赖已经添加。以下是 Flyway 的依赖项：

```
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-mysql</artifactId>
</dependency>
```

通过使用 Flyway，我们可以提供必要的 SQL 脚本，这些脚本将在我们需要更改数据库模式时执行。我们需要将这些脚本放在 src/main/resources/db/migration 文件夹下。

Flyway 将在该特定文件夹下查找脚本，并且 Flyway 还将遵循特定的命名约定来识别 SQL 脚本，我们需要将文件命名为以下格式：

**V<编号>\_\_文件名.sql**

示例：V1\_\_init.sql，V2\_\_add\_products.sql 等。

注意，在 SQL 文件名中的数字需要为每次要运行的数据库迁移递增。

让我们创建以下文件以创建订单表

**V1\_\_init.sql**

```
CREATE TABLE `t_orders`
(
    `id`          bigint(20) NOT NULL AUTO_INCREMENT,
    `order_number` varchar(255) DEFAULT NULL,
    `sku_code`  varchar(255),
    `price`    decimal(19, 2),
    `quantity` int(11),
    PRIMARY KEY (`id`)
);
```

在运行迁移之前，让我们创建必要的模型类和提交订单端点。

注意：我最近简化了一些逻辑和表结构。我移除了订单行项目表及其相关逻辑，以使整个逻辑更简单。因此，您可能会发现与包含对订单行项目表引用的第一版文章相比存在一些差异。

**Order.java**

```
package com.programmingtechie.orderservice.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;

@Entity
@Table(name = "t_orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String orderNumber;
    private String skuCode;
    private BigDecimal price;
    private Integer quantity;
}
```

**OrderRepository.java**

```
package com.programmingtechie.orderservice.repository;

import com.programmingtechie.orderservice.model.Order;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderRepository extends JpaRepository<Order, Long> {
}
```

**OrderService.java**

```
package com.programmingtechie.orderservice.service;

import com.programmingtechie.orderservice.dto.OrderRequest;
import com.programmingtechie.orderservice.model.Order;
import com.programmingtechie.orderservice.repository.OrderRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
@RequiredArgsConstructor
@Transactional
public class OrderService {

    private final OrderRepository orderRepository;

    public void placeOrder(OrderRequest orderRequest) {
        var order = mapToOrder(orderRequest);
        orderRepository.save(order);
    }

    private static Order mapToOrder(OrderRequest orderRequest) {
        Order order = new Order();
        order.setOrderNumber(UUID.randomUUID().toString());
        order.setPrice(orderRequest.price());
        order.setQuantity(orderRequest.quantity());
        order.setSkuCode(orderRequest.skuCode());
        return order;
    }
}
```

**OrderController.java**

```
package com.programmingtechie.orderservice.controller;

import com.programmingtechie.orderservice.dto.OrderRequest;
import com.programmingtechie.orderservice.service.OrderService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/order")
@RequiredArgsConstructor
public class OrderController {

    private final OrderService orderService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String placeOrder(@RequestBody OrderRequest orderRequest) {
        orderService.placeOrder(orderRequest);
        return "Order Placed Successfully";
    }
}
```

**OrderRequest.java**

```
package com.programmingtechie.orderservice.dto;

import java.math.BigDecimal;

public record OrderRequest(Long id, String skuCode, BigDecimal price, Integer quantity) {
}
```

### 通过 Postman 测试应用程序

现在我们来测试我们的端点，使用 Postman 之前，让我们通过运行 OrderServiceApplication.java 类来启动我们的应用程序

如下截图所示，让我们向 URL http://localhost:8081/api/order 发送一个 POST 请求：

请求应该成功，HTTP 状态码为 201 Created，响应体中应包含文本“订单已成功放置”。

### 编写订单服务的集成测试

让我们来编写 OrderService 的集成测试。

**OrderServiceApplicationTests.java**

```
package com.programmingtechie.orderservice;

import io.restassured.RestAssured;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.testcontainers.containers.MySQLContainer;

import static org.hamcrest.MatcherAssert.assertThat;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class OrderServiceApplicationTests {

    @ServiceConnection
    static MySQLContainer mySQLContainer = new MySQLContainer("mysql:8.3.0");
    @LocalServerPort
    private Integer port;

    @BeforeEach
    void setup() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = port;
    }

    static {
        mySQLContainer.start();
    }

    @Test
    void shouldSubmitOrder() {
        String submitOrderJson = """
                {
                     "skuCode": "iphone_15",
                     "price": 1000,
                     "quantity": 1
                }
                """;

        var responseBodyString = RestAssured.given()
                .contentType("application/json")
                .body(submitOrderJson)
                .when()
                .post("/api/order")
                .then()
                .log().all()
                .statusCode(201)
                .extract()
                .body().asString();

        assertThat(responseBodyString, Matchers.is("Order Placed Successfully"));
    }
}
```

## 创建第三个微服务 - 库存服务

现在让我们创建第三个微服务——库存服务。访问 start.spring.io 并选择以下依赖项：

- Spring Web
- Spring Data JPA
- Lombok
- Flyway
- MySQL JDBC Driver
- Test Containers
- Java 21 and Maven as Build tool

库存服务仅公开了 1 个端点，类似于订单服务，以下是端点的简要概述：

| **服务操作** | **端点方法** | **服务端点**   |
| --- | --- | --- |
| GET 库存     | GET          | /api/inventory |

库存服务的 REST 操作

由于我们还在库存服务中使用 MySQL 数据库，因此我们需要首先更新 mysql/init.sql 文件，以包含创建库存数据库的 SQL 命令。

**mysql/init.sql**

```
CREATE DATABASE IF NOT EXISTS order_service;
CREATE DATABASE IF NOT EXISTS inventory_service;
```

现在让我们配置 **application.properties** 文件，以设置与 MySQL 数据库交互的 Spring Data JPA 和 Hibernate 属性：

**application.yml**

```
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/inventory_service
spring.datasource.username=root
spring.datasource.password=mysql
spring.jpa.hibernate.ddl-auto=none
server.port=8082
```

我们使用几乎与订单服务相同的配置，唯一不同的是我们将运行库存服务在 8082 端口。

让我们在 src/main/resources/db/migration 文件夹下也创建 Flyway 迁移脚本，这里我们将创建 2 个脚本：  
\- V1\_\_init.sql  
\- V2\_\_add\_inventory.sql

如其名称所示，V1\_\_init.sql 文件创建了 t\_inventory 表

**V1\_\_init.sql**

```
CREATE TABLE `t_inventory`
(
    `id`       bigint(20) NOT NULL AUTO_INCREMENT,
    `sku_code`  varchar(255) DEFAULT NULL,
    `quantity` int(11)      DEFAULT NULL,
    PRIMARY KEY (`id`)
);
```

**V2\_\_add\_inventory.sql**

```
insert into t_inventory (quantity, sku_code)
values (100, 'iphone_15'),
       (100, 'pixel_8'),
       (100, 'galaxy_24'),
       (100, 'oneplus_12');
```

现在让我们继续编写实现获取库存端点的必要代码。

**Inventory.java**

```
package com.programmingtechie.inventoryservice.model;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import jakarta.persistence.*;

@Entity
@Table(name = "t_inventory")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class Inventory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String skuCode;
    private Integer quantity;
}
```

**InventoryRepository.java**

```
package com.programmingtechie.inventoryservice.repository;

import com.programmingtechie.inventoryservice.model.Inventory;
import org.springframework.data.jpa.repository.JpaRepository;

public interface InventoryRepository extends JpaRepository<Inventory, Long> {
    boolean existsBySkuCodeAndQuantityIsGreaterThanEqual(String skuCode, int quantity);
}
```

**InventoryService.java**

```
package com.programmingtechie.inventoryservice.service;

import com.programmingtechie.inventoryservice.repository.InventoryRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class InventoryService {

    private final InventoryRepository inventoryRepository;

    @Transactional(readOnly = true)
    public boolean isInStock(String skuCode, Integer quantity) {
        return inventoryRepository.existsBySkuCodeAndQuantityIsGreaterThanEqual(skuCode, quantity);
    }
}
```

**InventoryController.java**

```
package com.programmingtechie.inventoryservice.controller;

import com.programmingtechie.inventoryservice.service.InventoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/inventory")
@RequiredArgsConstructor
public class InventoryController {

    private final InventoryService inventoryService;

    @GetMapping
    @ResponseStatus(HttpStatus.OK)
    public boolean isInStock(@RequestParam String skuCode, @RequestParam Integer quantity) {
        return inventoryService.isInStock(skuCode, quantity);
    }
}
```

现在让我们通过运行 InventoryServiceApplication.class 来启动应用程序，你应该看到以下日志，表明数据库迁移已成功执行。

```
Successfully applied 2 migrations to schema \`inventory_service\`, now at version v2 (execution time 00:00.033s)
```

### 使用 Postman 进行测试

现在让我们打开 Postman 并调用 http://localhost:8082/api/inventory?skuCode=iphone\_15&quantity=100 这个端点，注意我们在请求参数中传递了多个 SKUCodes。

### 编写集成测试

让我们为库存服务编写集成测试。

**InventoryServiceApplicationTests.java**

```
package com.programmingtechie.inventoryservice;

import com.jayway.jsonpath.JsonPath;
import io.restassured.RestAssured;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.testcontainers.containers.MySQLContainer;

import static org.hamcrest.Matchers.is;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class InventoryServiceApplicationTests {

    @ServiceConnection
    static MySQLContainer mySQLContainer = new MySQLContainer("mysql:8.3.0");
    @LocalServerPort
    private Integer port;

    @BeforeEach
    void setup() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = port;
    }

    static {
        mySQLContainer.start();
    }

    @Test
    void shouldReadInventory() {
        var response = RestAssured.given()
                .when()
                .get("/api/inventory?skuCode=iphone_15&quantity=1")
                .then()
                .log().all()
                .statusCode(200)
                .extract().response().as(Boolean.class);
        assertTrue(response);

        var negativeResponse = RestAssured.given()
                .when()
                .get("/api/inventory?skuCode=iphone_15&quantity=1000")
                .then()
                .log().all()
                .statusCode(200)
                .extract().response().as(Boolean.class);
        assertFalse(negativeResponse);

    }

}
```

## 结论

春 Boot 微服务教程系列第一部分到此结束，我们为应用程序创建了 3 个服务，从下一部分开始，我们将专注于将微服务设计模式应用到我们的应用程序中。

在下一部分，我们将学习使用 Spring Cloud OpenFeign 的同步服务间通信模式。