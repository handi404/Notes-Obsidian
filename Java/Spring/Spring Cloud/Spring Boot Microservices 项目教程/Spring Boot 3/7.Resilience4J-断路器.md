在本 Spring Boot 微服务教程的第 6 部分中，我们将学习如何通过实现 Circuit Breaker 模式在我们的项目中实现弹性。我们将库 **Resilience4J** 与 **Spring Cloud Circuit Breaker Resilience4J** 一起使用，在我们的项目中实现断路器模式

## 什么是熔断器模式？

Circuit Breaker 是实际分布式系统中广泛使用的最佳实践之一

考虑应用程序 **A** 对远程服务 **R** 进行同步调用的场景。如果服务 **R** 由于性能问题而变得不可用或响应非常缓慢，则这种情况也会对应用程序 **A** 产生负面影响。

如果应用程序 **A** 收到大量请求，那么将有很多线程处于 waiting 状态，等待 R 的响应，最终导致应用程序 **A** 崩溃。为避免此问题，我们可以使用断路器模式，其工作原理与我们家中使用的断路器非常相似，以保护电气设备免受功率尖峰的影响。如果出现功率尖峰，则断路器跳闸并停止电流。同样，在我们的例子中，当远程服务 **R** 不可用或响应非常缓慢时，我们可以引入一个 Circuit Breaker，它将在一段时间内停止对服务的调用。在此超时之后，断路器将再次开始逐渐允许对服务 **R** 的调用。

在我们的微服务项目中，我们可以在 API Gateway 和 Order Service 中引入这种 Circuit Breaker 机制。

API Gateway 是调用其他 3 个服务的主要服务，因此这将是使用 Circuit Breaker 的最佳位置，同样，我们也可以在 Order Service 中实现此功能，因为该服务正在调用 Inventory Service 来获取库存信息。

## 断路器模式中的不同状态

在任何给定的时间点，熔断器将处于不同的状态，例如：

- **Open** ：此状态表示 Circuit Breaker 已打开，并且通过 Circuit Breaker 的所有流量都将被阻止。
- **半开** ：在此状态下，断路器将开始逐渐允许流量流向远程服务 **R**
- **Closed** ：在此状态下，Circuit Breaker 将允许对服务的所有请求，这意味着服务 **R** 运行良好，没有任何问题。

## 在 API 网关中实施 Circuit Breaker

现在，让我们在 API Gateway 项目中实现此模式，为此，我将向 API Gateway 项目的 **pom.xml** 添加以下依赖项

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

第一个依赖项在我们的项目中添加了 **Resilience4J** 库，第二个依赖项添加了 Spring Boot Actuator，它为我们提供了有用的端点来获取有关我们应用程序的有用信息，例如 **Metrics** ，我们可以利用这些端点来检查 Resilience4J 断路器的状态。

添加上述依赖项后，我们需要将 **circuitBreaker（）** 方法添加到所有路由的 Route Configuration 中。

```
@Bean
    public RouterFunction<ServerResponse> productServiceRoute() {
        return GatewayRouterFunctions.route("product_service")
                .route(RequestPredicates.path("/api/product"), HandlerFunctions.http("http://localhost:8080"))
                .filter(circuitBreaker("productServiceCircuitBreaker", URI.create("forward:/fallbackRoute")))
                .build();
    }

    @Bean
    public RouterFunction<ServerResponse> productServiceSwaggerRoute() {
        return GatewayRouterFunctions.route("product_service_swagger")
                .route(RequestPredicates.path("/aggregate/product-service/v3/api-docs"), HandlerFunctions.http("http://localhost:8080"))
                .filter(circuitBreaker("productServiceSwaggerCircuitBreaker", URI.create("forward:/fallbackRoute")))
                .filter(setPath("/api-docs"))
                .build();
    }

    @Bean
    public RouterFunction<ServerResponse> orderServiceRoute() {
        return GatewayRouterFunctions.route("order_service")
                .route(RequestPredicates.path("/api/order"), HandlerFunctions.http("http://localhost:8081"))
                .filter(circuitBreaker("orderServiceCircuitBreaker", URI.create("forward:/fallbackRoute")))
                .build();
    }

    @Bean
    public RouterFunction<ServerResponse> orderServiceSwaggerRoute() {
        return GatewayRouterFunctions.route("order_service_swagger")
                .route(RequestPredicates.path("/aggregate/order-service/v3/api-docs"), HandlerFunctions.http("http://localhost:8081"))
                .filter(circuitBreaker("orderServiceSwaggerCircuitBreaker", URI.create("forward:/fallbackRoute")))
                .filter(setPath("/api-docs"))
                .build();
    }

    @Bean
    public RouterFunction<ServerResponse> inventoryServiceRoute() {
        return GatewayRouterFunctions.route("inventory_service")
                .route(RequestPredicates.path("/api/inventory"), HandlerFunctions.http("http://localhost:8082"))
                .filter(circuitBreaker("inventoryServiceCircuitBreaker", URI.create("forward:/fallbackRoute")))
                .build();
    }

    @Bean
    public RouterFunction<ServerResponse> inventoryServiceSwaggerRoute() {
        return GatewayRouterFunctions.route("inventory_service_swagger")
                .route(RequestPredicates.path("/aggregate/inventory-service/v3/api-docs"), HandlerFunctions.http("http://localhost:8082"))
                .filter(circuitBreaker("inventoryServiceSwaggerCircuitBreaker", URI.create("forward:/fallbackRoute")))
                .filter(setPath("/api-docs"))
                .build();
    }

    @Bean
    public RouterFunction<ServerResponse> fallbackRoute() {
        return route("fallbackRoute")
                .GET("/fallbackRoute", request -> ServerResponse.status(HttpStatus.SERVICE_UNAVAILABLE).body("Service Unavailable, please try again later"))
                .build();
    }
```

您可以看到， **circuitBreaker（）** 方法采用一个 ID（一个字符串），然后是一个 URL 参数，该参数指向一个回退端点，当 CircuitBreaker **处于打开** 状态时，当请求被阻止时将显示该端点

我们有 **fallbackRoute（）** Bean，它被定义为路径 **\- /fallbackRoute** 的回退路由，它将 HTTP 503 Service Unavailable 响应发送回客户端。

为我们的路由添加此配置后，我们现在必须在项目中为打开的 **application.properties** 文件配置 Resilience4J：

```
#Resilinece4j Properties
resilience4j.circuitbreaker.configs.default.registerHealthIndicator=true
resilience4j.circuitbreaker.configs.default.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.configs.default.slidingWindowSize=10
resilience4j.circuitbreaker.configs.default.failureRateThreshold=50
resilience4j.circuitbreaker.configs.default.waitDurationInOpenState=5s
resilience4j.circuitbreaker.configs.default.permittedNumberOfCallsInHalfOpenState=3
resilience4j.circuitbreaker.configs.default.automaticTransitionFromOpenToHalfOpenEnabled=true
resilience4j.circuitbreaker.configs.default.minimum-number-of-calls=5
```

上述属性确保在我们的项目中配置了 Resilience4J。

## Enable Circuit Breaker for Timeouts（启用超时断路器）

我们可以启用 Circuit Breaker 来实现超时，当远程服务需要很长时间才能响应时，为此我们所要做的就是添加以下属性：

```
resilience4j.timelimiter.configs.default.timeout-duration=3s
```

使用此配置时，当远程服务发回响应的时间超过 3 秒时，断路器将处于打开状态。

## 实施重试

有时，服务可能由于小网络问题（或任何其他小问题）而不可用，在这些情况下，最好重试调用，而不是直接激活断路器。因此，Resilience4J 库允许我们通过添加以下配置来实现重试：

```
#Resilience4J Retry Properties
resilience4j.retry.configs.default.max-attempts=3
resilience4j.retry.configs.default.wait-duration=2s
```

上述配置将重试最多 3 次，两次重试之间等待 5 秒。

## 在 Order 服务中实现 Circuit Breaker

现在让我们在 Order Service 中也实现 Circuit Breaker，因为我们正在对该服务中的 inventory 服务进行同步调用。

为此，我将在项目的 **pom.xml** 中添加以下依赖项：

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

之后，让我们在 application.properties 文件中添加 Resilience4J 的配置，如下所示：

```
#Resilinece4j Properties
resilience4j.circuitbreaker.instances.inventory.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.inventory.event-consumer-buffer-size=10
resilience4j.circuitbreaker.instances.inventory.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.instances.inventory.slidingWindowSize=5
resilience4j.circuitbreaker.instances.inventory.failureRateThreshold=50
resilience4j.circuitbreaker.instances.inventory.waitDurationInOpenState=5s
resilience4j.circuitbreaker.instances.inventory.permittedNumberOfCallsInHalfOpenState=3
resilience4j.circuitbreaker.instances.inventory.automaticTransitionFromOpenToHalfOpenEnabled=true
resilience4j.circuitbreaker.instances.inventory.minimum-number-of-calls=5

#Resilience4J Timeout Properties
resilience4j.timelimiter.instances.inventory.timeout-duration=3s

#Resilience4J Retry Properties
resilience4j.retry.instances.inventory.max-attempts=3
resilience4j.retry.instances.inventory.wait-duration=5s
```

之后，要在特定的端点上启用 Circuit Breaker，我们可以添加 @CircuitBreaker 注解，类似地启用重试，我们可以分别添加 @Retry 注解。

我们可以在 Inventory Client 类中添加上述注释，这是添加必要注释后类的样子：

```
package com.techie.microservices.order.client;

import groovy.util.logging.Slf4j;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.service.annotation.GetExchange;

@Slf4j
public interface InventoryClient {

    Logger log = LoggerFactory.getLogger(InventoryClient.class);

    @GetExchange("/api/inventory")
    @CircuitBreaker(name = "inventory", fallbackMethod = "fallbackMethod")
    @Retry(name = "inventory")
    boolean isInStock(@RequestParam String skuCode, @RequestParam Integer quantity);

    default boolean fallbackMethod(String code, Integer quantity, Throwable throwable) {
        log.info("Cannot get inventory for skucode {}, failure reason: {}", code, throwable.getMessage());
        return false;
    }
}
```

在上面的类中，你可以注意到我们定义了一个名为 **fallbackMethod** 的方法，每当 Circuit Breaker **打开** 时，它就会执行。

要实现 Timeout，我们可以将 RestClient 配置为具有连接并通过 requestFactory（） 方法读取超时。RestClientConfig.java 类如下所示：

```
package com.techie.microservices.order.config;

import com.techie.microservices.order.client.InventoryClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.ClientHttpRequestFactories;
import org.springframework.boot.web.client.ClientHttpRequestFactorySettings;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestClient;
import org.springframework.web.client.support.RestClientAdapter;
import org.springframework.web.service.invoker.HttpServiceProxyFactory;

import java.time.Duration;

@Configuration
public class RestClientConfig {

    @Value("${inventory.url}")
    private String inventoryServiceUrl;

    @Bean
    public InventoryClient inventoryClient() {
        RestClient restClient = RestClient.builder()
                .baseUrl(inventoryServiceUrl)
                .requestFactory(getClientRequestFactory())
                .build();
        var restClientAdapter = RestClientAdapter.create(restClient);
        var httpServiceProxyFactory = HttpServiceProxyFactory.builderFor(restClientAdapter).build();
        return httpServiceProxyFactory.createClient(InventoryClient.class);
    }

    private ClientHttpRequestFactory getClientRequestFactory() {
        ClientHttpRequestFactorySettings clientHttpRequestFactorySettings = ClientHttpRequestFactorySettings.DEFAULTS
                .withConnectTimeout(Duration.ofSeconds(3))
                .withReadTimeout(Duration.ofSeconds(3));
        return ClientHttpRequestFactories.get(clientHttpRequestFactorySettings);
    }
}
```

## 测试断路器模式

要在 API 网关中测试 Circuit Breaker，请确保 Product、Order 或 Inventory Service 等服务之一不可用，然后调用相应的服务。

您应该会看到一个错误 - **服务不可用，请稍后再试** ，状态 **为 HTTP\_503**

您也可以对 Order Service 项目尝试相同的作，方法是停止 Inventory Service。

为了测试 Timeout 和 Retry，我们可以通过添加类似 Thread.sleep（） 的东西来模拟请求的延迟，你可以观察到在这些情况下 Circuit Breaker 也会被激活。

## 结论

在这篇中，您了解了 Circuit Breaker 模式、为什么以及何时使用它。我们还学习了如何使用 Resilience4J 和 Spring Cloud Circuit Breaker 等库启用该模式。

在 Spring Boot 微服务教程系列的下一部分中，我们将学习如何使用 Kafka 实现异步通信。
