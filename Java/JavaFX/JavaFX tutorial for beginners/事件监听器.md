[[绑定（Binding）和监听（Listener）机制]]
# 
- [[#1. 常见的事件类型|1. 常见的事件类型]]
- [[#2. 使用事件监听器|2. 使用事件监听器]]
	- [[#2. 使用事件监听器#2.1 使用 Lambda 表达式|2.1 使用 Lambda 表达式]]
		- [[#2.1 使用 Lambda 表达式#Button 点击事件监听器|Button 点击事件监听器]]
		- [[#2.1 使用 Lambda 表达式#ChoiceBox 选择事件监听器|ChoiceBox 选择事件监听器]]
		- [[#2.1 使用 Lambda 表达式#鼠标点击事件监听器|鼠标点击事件监听器]]
	- [[#2. 使用事件监听器#2.2 使用方法引用|2.2 使用方法引用]]
- [[#3. 自定义事件处理器类|3. 自定义事件处理器类]]
- [[#4. 事件冒泡和捕获|4. 事件冒泡和捕获]]
- [[#总结|总结]]

在 JavaFX 中，事件监听器用于处理用户交互和界面上的事件，如按钮点击、鼠标移动、键盘按键等。事件监听器是通过将事件处理器（通常是一个 Lambda 表达式或方法引用）注册到 UI 组件上来实现的。当特定事件发生时，JavaFX 会调用相应的事件处理器。

### 1. 常见的事件类型

JavaFX 中有多种事件类型，以下是一些常见的事件：

- **`ActionEvent`**: 主要用于按钮点击、菜单选择、文本框提交等操作。
- **`MouseEvent`**: 处理鼠标点击、移动、拖动、滚轮等事件。
- **`KeyEvent`**: 处理键盘按键事件。
- **`WindowEvent`**: 处理窗口相关的事件，如窗口关闭、打开、最小化等。

### 2. 使用事件监听器

事件监听器通常通过 `setOnX` 方法来注册，`X` 代表具体的事件类型。例如，`setOnAction`、`setOnMouseClicked` 等。

#### 2.1 使用 Lambda 表达式
JavaFX 事件监听器通常以 Lambda 表达式的方式使用，这种方式简洁且易读。下面是几个例子：

##### Button 点击事件监听器
```java
Button button = new Button("Click Me");
button.setOnAction(event -> {
    System.out.println("Button clicked!");
});
```
- 当用户点击按钮时，`setOnAction` 方法中的 Lambda 表达式会执行，输出 "Button clicked!"。

##### ChoiceBox 选择事件监听器
```java
ChoiceBox<String> choiceBox = new ChoiceBox<>();
choiceBox.getItems().addAll("Option 1", "Option 2", "Option 3");
choiceBox.setOnAction(event -> {
    String selected = choiceBox.getValue();
    System.out.println("Selected: " + selected);
});
```
- 当用户在 `ChoiceBox` 中选择一个选项时，`setOnAction` 方法会触发，并打印所选的选项。

##### 鼠标点击事件监听器
```java
Rectangle rectangle = new Rectangle(100, 100);
rectangle.setOnMouseClicked(event -> {
    System.out.println("Rectangle clicked at " + event.getSceneX() + ", " + event.getSceneY());
});
```
- 当用户点击 `Rectangle` 时，`setOnMouseClicked` 方法会触发，并打印出点击的位置坐标。

#### 2.2 使用方法引用
除了 Lambda 表达式，你还可以使用方法引用来指定事件处理器。方法引用通常用于逻辑较复杂或需要复用的处理方法。

```java
button.setOnAction(this::handleButtonClick);

private void handleButtonClick(ActionEvent event) {
    System.out.println("Button clicked!");
}
```
- `this::handleButtonClick` 是方法引用，当按钮被点击时，会调用 `handleButtonClick` 方法。

### 3. 自定义事件处理器类

如果你的事件处理逻辑比较复杂，还可以创建一个单独的类来实现 `EventHandler` 接口。

```java
public class CustomEventHandler implements EventHandler<ActionEvent> {
    @Override
    public void handle(ActionEvent event) {
        System.out.println("Custom handler executed!");
    }
}

// 使用自定义事件处理器
button.setOnAction(new CustomEventHandler());
```

- `CustomEventHandler` 实现了 `EventHandler` 接口，并重写了 `handle` 方法。当事件发生时，JavaFX 会调用 `handle` 方法。

### 4. 事件冒泡和捕获
JavaFX 支持事件冒泡（Bubbling）和事件捕获（Capturing）机制。

- **冒泡**：事件从最具体的节点向上传递到根节点。
- **捕获**：事件从根节点向下传递到最具体的节点。

你可以通过 `addEventHandler` 或 `addEventFilter` 来处理这些事件。例如：

```java
scene.addEventFilter(MouseEvent.MOUSE_CLICKED, event -> {
    System.out.println("Mouse clicked in capturing phase");
});

scene.addEventHandler(MouseEvent.MOUSE_CLICKED, event -> {
    System.out.println("Mouse clicked in bubbling phase");
});
```

### 总结
事件监听器在 JavaFX 中扮演着重要角色，它让你能够响应用户的各种交互操作。通过 Lambda 表达式、方法引用和自定义事件处理器类，你可以灵活地处理 JavaFX 中的各种事件，构建交互性强的应用程序。