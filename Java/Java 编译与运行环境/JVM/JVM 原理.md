---
categories:
- [Java,编译与运行]
title: JVM 原理
date: 2025-05-24
index_img: img/java/JVM.jpg
sticky: 60
tags:
- java
- JVM
---
**JVM 原理**：垃圾回收机制 (ZGC, Shenandoah)、类加载、内存模型等。

**掌握 JVM 是从“会用 Java” 到 “精通 Java” 的必经之路，也是你作为一名资深工程师的核心竞争力所在。**

别担心，这并不像听上去那么遥不可及。我会带你一步步揭开 JVM 的神秘面纱。

想象一下，你是一位顶级的 F 1 赛车手（Java 开发者）。你不仅要会开车（写代码），更要懂得引擎（JVM）是如何工作的，这样你才能在关键时刻压榨出赛车的极限性能，并在赛车出问题时快速判断出是引擎、轮胎还是空气动力学套件的问题。

这趟 JVM 的深度探索之旅，我会分为三个部分：

1.  **宏观蓝图：JVM 是什么，它在干什么？**
2.  **核心揭秘：深入 JVM 的内部构造（内存、GC、类加载）**
3.  **实战应用：如何利用 JVM 知识解决实际问题（调优、排错）**

---

### 一、宏观蓝图：JVM - Java 跨平台的基石与管家

**JVM (Java Virtual Machine)** 的核心使命有两个：

1.  **跨平台的心脏**：你写的 `.java` 文件，经过编译器（`javac`）编译后，变成了 `.class` 文件（字节码）。这个字节码是一种中间语言，它不面向任何具体的操作系统。JVM 就是那个能在 Windows, Linux, macOS 等不同系统上运行这种字节码的“虚拟机”。它抹平了底层操作系统的差异，实现了 “**一次编译，到处运行 (Write Once, Run Anywhere)**”。
2.  **全自动的内存管家**：C/C++ 程序员最头疼的就是手动管理内存（`malloc` / `free`），一不小心就会内存泄漏或程序崩溃。Java 程序员则幸福得多，因为 JVM 内置了**自动内存管理**和**垃圾回收（Garbage Collection, GC）** 机制。你只管 `new` 对象，JVM 会在你“看不见”的地方，默默地帮你回收那些不再使用的对象，让你可以专注于业务逻辑。

---

### 二、核心揭秘：深入 JVM 的内部构造

我们将 JVM 拆解为三大核心模块来理解：**内存区域**、**垃圾回收器**、**类加载机制**。

#### 1. JVM 内存区域（运行时数据区）

这是 JVM 的“工作空间”。你的代码、创建的对象、调用的方法，都在这里面。根据最新的 **Java 虚拟机规范 (Java SE 17/21)**，它主要分为以下几个区域：
![[jvm_memory_structure.svg]]

*(这是一个经典的 JVM 内存结构图，我为你解释每个部分)*

*   **① 堆 (Heap) - 所有线程共享**
    *   **作用**：**存放对象实例和数组的地方**。你代码里 `new` 出来的所有东西，几乎都在这里。
    *   **特点**：JVM 里最大的一块内存，也是 GC 的主要工作区域。
    *   **现代分代设计**：为了优化 GC 效率，堆通常被划分为两块：
        *   **新生代 (Young Generation)**：存放新创建的、生命周期短的对象。绝大多数对象都在这里“出生”，也在这里“死亡”。它又细分为：
            *   **Eden 区**：新对象的出生地。
            *   **Survivor 区 (S 0, S 1)**：经过一次 GC 后还存活的对象，会在这里“幸存”。对象会在 S 0 和 S 1 之间来回复制，每复制一次年龄加一。
        *   **老年代 (Old Generation)**：存放生命周期长的对象。当对象在新生代的年龄达到一定阈值（默认 15）后，就会被“晋升”到老年代。

*   **② 方法区 (Method Area) - 所有线程共享**
    *   **作用**：存放已被虚拟机加载的**类信息、常量、静态变量、即时编译器（JIT）编译后的代码**等数据。
    *   **重要演进（必知！）**：
        *   **JDK 7 及之前**：方法区由“永久代 (Permanent Generation)”实现，它在堆里，大小固定，容易引发 `OutOfMemoryError: PermGen space`。
        *   **JDK 8 及之后**：**永久代被彻底移除**，取而代之的是“**元空间 (Metaspace)**”。元空间使用的是**本地内存（Native Memory）**，而非虚拟机内存。这解决了 PermGen 的大小限制问题，只要你的物理内存足够，理论上元空间就可以一直扩展。这是现代 JVM 的一个巨大变化。

*   **③ 虚拟机栈 (VM Stack) - 线程私有**
    *   **作用**：每个线程在创建时都会创建一个虚拟机栈。当一个方法被调用时，JVM 会为它创建一个“**栈帧 (Stack Frame)**”，用来存储**局部变量**、**操作数栈**、**方法出口**等信息。方法调用开始，栈帧入栈；方法调用结束，栈帧出栈。
    *   **常见异常**：如果线程请求的栈深度大于虚拟机所允许的深度，会抛出 `StackOverflowError`（比如无限递归）；如果栈可以动态扩展，但在扩展时无法申请到足够的内存，会抛出 `OutOfMemoryError`。

*   **④ 程序计数器 (Program Counter Register) - 线程私有**
    *   **作用**：一块很小的内存空间，可以看作是当前线程所执行的字节码的**行号指示器**。多线程切换时，CPU 需要知道回来后从哪里继续执行，靠的就是它。这是唯一一个在 Java 虚拟机规范中没有规定任何 `OutOfMemoryError` 情况的区域。

*   **⑤ 本地方法栈 (Native Method Stack) - 线程私有**
    *   **作用**：与虚拟机栈类似，但它是为调用 `native` 方法（由 C/C++ 等语言实现的方法）服务的。

#### 2. 垃圾回收 (Garbage Collection, GC)

GC 是 JVM 的明星功能。它的核心是回答两个问题：**“哪些内存需要回收？”** 和 **“如何回收？”**

*   **如何判断对象已死？**
    *   **可达性分析算法 (Reachability Analysis)**：这是当前主流的算法。从一系列被称为 **“GC Roots”** 的根对象（如虚拟机栈中引用的对象、方法区中静态属性引用的对象等）开始向下搜索，搜索走过的路径称为引用链。如果一个对象到任何 GC Roots 都没有引用链相连，那它就是“不可达”的，即可以被回收。

*   **如何回收？（GC 算法）**
    *   **标记-清除 (Mark-Sweep)**：先标记出所有需要回收的对象，然后统一回收。缺点是会产生大量内存碎片。
    *   **标记-复制 (Mark-Copy)**：将内存分为两块，每次只用一块。GC 时将存活的对象复制到另一块，然后把已使用的一块全部清空。新生代 GC 常用的算法，优点是高效、无碎片，缺点是浪费一半内存。
    *   **标记-整理 (Mark-Compact)**：标记过程同上，但后续不是直接清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。老年代 GC 常用的算法。

*   **现代垃圾回收器（划重点！）**
    > 你不需要记住所有回收器的所有细节，但你需要知道它们各自的特点和适用场景，尤其是 G 1 和 ZGC。

    *   **Serial / Serial Old**：单线程收集器，古老，简单高效（在单核 CPU 环境下），但会产生较长的“Stop-The-World (STW)”（GC 期间所有用户线程暂停）。基本已淘汰。
    *   **Parallel Scavenge / Parallel Old**：多线程并行收集器，关注**吞吐量**（CPU 用于运行用户代码的时间 / 总时间）。是 JDK 8 默认的回收器组合，适合后台计算等对停顿时间不敏感的应用。
    *   **CMS (Concurrent Mark Sweep)**：以获取**最短回收停顿时间**为目标的收集器。并发执行，STW 时间很短。但有缺点：对 CPU 资源敏感、有浮动垃圾、会产生内存碎片。**在 JDK 9 中被标记为废弃，在 JDK 14 中被移除**。了解即可，新项目不应使用。
    *   **G 1 (Garbage-First)**：**现代 JVM 的里程碑**。它将堆划分为多个大小相等的独立区域 (Region)，并跟踪每个 Region 的回收价值。它会优先回收价值最大的 Region（Garbage-First 的由来）。G 1 是一款面向服务端的垃圾收集器，**在 JDK 9 之后成为默认选项**，它在**可预测的停顿时间模型**和高吞吐量之间取得了很好的平衡。是目前应用最广泛的收集器之一。
    *   **ZGC / Shenandoah**：**面向未来的超低延迟收集器**。它们的目标是将 STW 时间控制在**毫秒甚至亚毫秒级别**，几乎完全并发。它们通过更复杂的技术（如着色指针、读屏障）实现。适合对响应时间有极致要求的大内存服务（如金融交易、实时竞价）。ZGC 从 JDK 15 开始成为生产可用 (Production Ready)。

#### 3. 类加载机制

JVM 不是一次性把所有类都加载进来，而是按需加载。这个过程就是类加载机制。

*   **加载过程**：加载 -> 连接（验证、准备、解析）-> 初始化
*   **双亲委派模型 (Parents Delegation Model)**：
    *   **是什么**：当一个类加载器收到类加载请求时，它首先不会自己去尝试加载，而是把这个请求**委派给父类加载器**去完成。每一层的加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器 (Bootstrap ClassLoader) 中。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。
    *   **为什么**：
        1.  **安全**：防止核心 API（如 `java.lang.String`）被用户自定义的同名类所篡改。
        2.  **避免重复加载**：父加载器已经加载过的类，子加载器就不会再加载了。

---

### 三、实战应用：JVM 知识的价值所在

了解理论是为了更好地实践。以下是 JVM 知识能直接帮助你解决的问题：

1.  **内存溢出 (OOM) 问题排查**：
    *   `OutOfMemoryError: Java heap space`：堆内存不足。通常是创建了大量对象，或者有对象被长期引用无法回收（内存泄漏）。
    *   `OutOfMemoryError: Metaspace`：元空间不足。通常是加载了过多的类，或动态生成了大量类（如 CGLIB）。
    *   **工具**：使用 `jmap` 命令生成堆转储快照（heap dump），再用 **VisualVM** 或 **MAT (Memory Analyzer Tool)** 等工具分析，可以清晰地看到是哪些对象占用了大量内存。

2.  **性能调优 (Tuning)**：
    *   **设置堆大小**：`-Xms` (初始堆大小) 和 `-Xmx` (最大堆大小) 是最常用的参数。通常建议将两者设置为相同，以避免 GC 后堆的频繁伸缩带来的性能开销。
    *   **选择合适的 GC**：
        *   高吞吐、能容忍一定停顿的应用 -> **Parallel GC**
        *   要求响应时间、停顿可控、内存较大的应用（大部分 Web 应用） -> **G 1 GC**
        *   对延迟要求极其苛刻、内存巨大的应用 -> **ZGC**
    *   **GC 日志分析**：通过 `-Xlog:gc*:file=gc.log` (JDK 9+) 开启 GC 日志，分析 GC 频率、STW 时间、各年代内存变化，是调优的第一手资料。

3.  **线上问题快速定位**：
    *   **CPU 飙高**：可能是 GC 过于频繁（特别是 Full GC），也可能是某个线程在死循环。
    *   **线程死锁/等待**：程序突然没响应了。
    *   **工具集**：
        *   `jps`：列出所有 Java 进程。
        *   `jstat`：实时查看堆内存、GC 统计信息。
        *   `jstack`：打印线程快照，**排查死锁、线程等待的神器**。
        *   `jinfo`：查看和修改 JVM 参数。
        *   **Arthas**：阿里开源的 Java 诊断工具，可以在不重启服务的情况下，实时查看方法调用、观察变量、甚至热更新代码，是现代 Java 开发的排错利器。

### 总结与学习路径建议

1.  **先理解宏观概念**：搞懂 JVM 的作用、内存布局、GC 的基本思想和双亲委派模型。
2.  **掌握核心工具**：学会使用 `jstack`, `jmap` 和 VisualVM/JConsole，这是你的“听诊器”和“CT 机”。
3.  **深入学习 G 1 和 ZGC**：这是现代和未来的主流，理解它们的设计思想和关键调优参数。
4.  **实践出真知**：在本地模拟 OOM 场景，尝试分析 heap dump；在测试环境对自己负责的应用进行压力测试，观察 GC 表现，尝试调整参数看看效果。

掌握 JVM，你就不再是一个只会写 `if-else` 和 `for` 循环的“代码实现者”，而是一个能够驾驭整个 Java 技术体系、从容应对复杂线上问题的“系统掌控者”。