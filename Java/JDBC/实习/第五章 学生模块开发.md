# 第四章 学生模块开发

## **模块简介**	

学生模块主要方便学生了解自身的学习情况，督促学生自我提高。

1. 个人中心：主要对教师个人信息进行管理。
2. 成绩管理：主要对所带班级的学生成绩进行管理。
3. 选课

 

基于控制台实现的教务管理系统

![img](image\学生模块.png) 



## 需求分析

学生登录：（学生使用学号登录，密码默认为手机号后6位）

​	成功进入管理界面

​	否则返回登录界面

个人中心模块：

​	展示个人信息

​	修改密码

​	修改电话

​	修改地址



成绩管理模块

​	查询自己各科成绩

选课

​	选择选修课程

​	

​	

​	

## **本章⽬标**	

 

### 1、完成学生登录功能

 

登录界面设计：根据选择身份不同，进行登录

​		

```
public void mainView() {

    while (true) {

        System.out.println("*************教务管理系统*******************");
        System.out.println("请选择：1 教师登录 2 学生登录 3 管理员登录 0 退出系统");
        String num = sc.nextLine();

        String mess = "";

        switch (num) {
            case "1":
                loginView();
                Teacher teacher = new TeacherServiceImpl().login(userInfo);
                System.out.println(teacher);
                if (teacher != null) {
                    new TeacherView().teacherPage(teacher);
                } else {
                    mess = "账号或密码错误";
                }
                ;
                break;

            case "2":

                loginView();
                Student student = new StudentServiceImpl().login(userInfo);
                if (student != null) {
                    new StudentView().studetPage(student);
                } else {
                    mess = "账号或密码错误";
                }

                break;

            case "3":
                loginView();
                Manager manager = new ManagerServiceImpl().login(userInfo);
                if (manager != null) {
                    new ManagerView().managerPage(manager);
                } else {
                    mess = "账号或密码错误";
                }
                break;

            case "0":
                System.out.println("bye");
                return;

            default:
                mess = "功能暂未开放";
        }

        System.out.println(mess);

    }


}

/**
 * 登录界面
 *
 * @return 账号密码数组
 */
private Object[] loginView() {

    userInfo = new Object[2];

    System.out.println("***********请输入账号**************");
    userInfo[0] = sc.nextLine();

    System.out.println("***********请输入密码**************");
    userInfo[1] = sc.nextLine();

    return userInfo;
}
```



登录查询：以账号密码进行数据库查询

```
/**
     * 根据电话和密码查询学生信息
     *
     * @param userInfo
     * @return
     */
    @Override
    public Student findStudentByPhoneAndPassword(Object[] userInfo) {
        try {
            return template.queryForObject("select * from student where id=? and password=?", new BeanPropertyRowMapper<>(Student.class), userInfo);
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }

```

###  

### 2、 完成管理界面主菜单设计

 

```
 public void studetPage(Student student) {

        loginStudent = student;

        while (true) {

            System.out.println("****************教务系统-学生系统***************");
            System.out.println("***************当前用户为:" + student.getName() + "****************");
            System.out.println("************************************************");
            System.out.println("请选择功能：1 个人中心 2 成绩管理  3 选课 0 退出系统");

            String num = sc.nextLine();

            switch (num) {

                case "1":
                    myselfView();
                    break;

                case "2":
                    scoreView();
                    break;

                case "3":
                    electiveCourseView();
                    break;

                case "0":
                    return;

                default:
                    System.out.println("功能暂未开放，请重新选择");
            }
        }

    }

```



 

 

### 3、完成个人中心模块

```
  //学生个人中心
    private void myselfView() {

        System.out.println("当前所在位置：##########学生系统>个人信息管理##########");

        System.out.println("基本信息：" + loginStudent);

        while (true) {
            System.out.println("请选择功能：1 修改密码 2 修改电话 3 修改地址 0 返回上一级");
            String tnum = sc.nextLine();
            switch (tnum) {
                case "1":
                    System.out.println("请输入新密码：");
                    String password = sc.nextLine();
                    studentService.updatePassword(loginStudent.getId(), password);
                    System.out.println("密码修改完成，请牢记新密码:" + password);
                    break;

                case "2":
                    System.out.println("请输入新手机号:");
                    String phone = checkTeacherPhone();
                    studentService.updatePhone(loginStudent.getId(), phone);
                    System.out.println("修改完成");
                    break;

                case "3":
                    System.out.println("请输入新地址：");
                    String address = sc.nextLine();
                    studentService.updateAddress(loginStudent.getId(), address);
                    System.out.println("修改完成");
                    break;

                case "0":
                    return;

                default:
                    System.out.println("该功能暂未开放，请重新选择");
            }

            //更新登录用户信息
            //根据id查询
            loginStudent = studentService.findStudentById(loginStudent.getId());


        }
    }
```

 

### 4、完成成绩管理模块



```
    private void scoreView() {

        System.out.println("您的成绩如下：");
        System.out.println("*********************************************************");
        List<Map<String,Object>> scores = scoreService.findScoresBySid(loginStudent.getId());
        if(scores.size()==0){
            System.out.println("暂未查询到课程成绩");
        }else{

            for (Map<String, Object> score : scores) {

                System.out.println(score.get("cname")+":"+score.get("grade"));
            }
        }

        System.out.println("*********************************************************");

    }
```



### 5、完成选课

```
private void electiveCourseView() {

    System.out.println("当前所在位置：##########学生系统>选课管理##########");

    //查询选课信息
    Map<String,Object> map = courseService.findElectiveCoursesBySid(loginStudent.getId());

    if(map==null){
        System.out.println("暂未进行课程选修！请即时选修");

        //选修课程
        System.out.println("你可选修的课程如下:");
        List<Map<String,Object>> courseList = courseService.findCourseByTypeAndSid();

        if(courseList.size()==0){
            System.out.println("没有新的选修课程信息，请过段时间再进行尝试！");
            return;
        }

        ArrayList<Object> tids = new ArrayList<>();

        for (Map<String,Object> mp: courseList) {
            System.out.println("课程名称:"+mp.get("cname")+"\t 教师:"+mp.get("tname")+"\t教师编号:"+mp.get("tid"));
            tids.add(mp.get("tid"));
        }

        System.out.println("请输入选修课程的教师编号：");
        String tid=null;
        while (true){
            tid = sc.nextLine();

            if(tids.contains(tid)){
                break;
            }

            System.out.println("你选择的课程教师不在选修列表内，请重新选择：");
        }

        //添加选修
        courseService.electiveCourse(tid,loginStudent.getId());

        System.out.println("选课成功！");

    }else{
        System.out.println("##############################################");
        System.out.println("你已选修的课程如下:");

        System.out.println("课程名称:"+map.get("cname")+"\t教师:"+map.get("tname"));
        System.out.println("##############################################");



    }



}
```

## 涉及知识点

 

（⼀）异常处理

 

（二）单元测试



## **知识点讲解**	

### 异常

 什么是异常

​	异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：

> **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。

在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。

> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.



#### 异常的体系

> 异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。

![image-20201116093403797](F:/%E4%BA%91%E5%92%8C%E6%95%B0%E6%8D%AE/%E4%BA%91%E5%92%8C/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/01-JavaSE/day12-%E5%BC%82%E5%B8%B8&Log4j/%E7%AC%94%E8%AE%B0/assets/image-20201116093403797.png)

- #### Throwable体系

  - **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。
  - **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。


#### 异常的分类

> 我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。

**异常(Exception)的分类**:【编译时期】   和  【运行时期】 异常?

- **编译时期异常**:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)

- **运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)

  ![异常的分类](F:/%E4%BA%91%E5%92%8C%E6%95%B0%E6%8D%AE/%E4%BA%91%E5%92%8C/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/01-JavaSE/day12-%E5%BC%82%E5%B8%B8&Log4j/%E7%AC%94%E8%AE%B0/assets/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png)



#### 异常的处理

##### JVM默认处理异常的方式

==如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，==

- #### 处理方式有如下两个步骤：

  - 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台
  - 程序停止执行

- #### 代码演示

  ```java
  public class ExceptionDemo {
      public static void main(String[] args) {
          int[] arr = { 34, 12, 67 };
          int num = ArrayTools.getElement(arr, 4)
          System.out.println("num=" + num);
          System.out.println("over");
      }
  }
  
  public class ArrayTools {
      // 对给定的数组通过给定的角标获取元素。
      public static int getElement(int[] arr, int index) {
          int element = arr[index];
          return element;
      }
  }
  
  
  ```

- #### JVM处理异常过程分析

  ![异常产生过程](F:/%E4%BA%91%E5%92%8C%E6%95%B0%E6%8D%AE/%E4%BA%91%E5%92%8C/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/01-JavaSE/day12-%E5%BC%82%E5%B8%B8&Log4j/%E7%AC%94%E8%AE%B0/assets/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png)



##### try-catch方式处理异常

定义格式

```java
try {
	可能出现异常的代码;
} catch(异常类名 变量名) {
	异常的处理代码;
}
```

执行流程

- 程序从 try 里面的代码开始执行
- 出现异常，就会跳转到对应的 catch 里面去执行
- 执行完毕之后，程序还可以继续往下执行



代码示例

```java
public class ExceptionDemo01 {
    public static void main(String[] args) {

        int a = 10;
        int b = 0;
		//try存放的是可能出现问题的代码，如果有问题就进行catch，如果没有问题try和catch就不关心
        try {
            System.out.println("00000");

            //try中里放的代码越少越好
            System.out.println(a / b);

            //这里不会执行
            System.out.println("11111111111111111");

            //异常类尽量准确
        }catch (Exception e){
            System.out.println("你不会数学，我来教你！！");
        }
		//处理完之后不影响后台代码执行
        System.out.println("222222222222222");
    }
}
```



##### throws和 throw 处理异常

什么是声明异常（throws）

throws方式处理异常 又被称之为**声明异常**，将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。

关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).

声明异常格式

```java
修饰符 返回值类型 方法名() throws 异常类名 {
    
}
```

什么是throw

​	在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。

在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？

1. 创建一个异常对象。封装一些提示信息(信息可以自己编写。

2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。

   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。

   ```java
   修饰符 返回值类型 方法名(参数列表) [throws 异常的类型] {
       if (判断条件) {
           throw new 异常对象("异常的原因");	
       }
   }
   ```


代码演示

```java
public class ThrowsDemo {
    public static void main(String[] args) throws FileNotFoundException {
        read("a.txt");
    }

    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明
    public static void read(String path) throws FileNotFoundException {
        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException("文件不存在");
        }
    }
}
```

- ==throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。==

```java
public class ThrowsDemo2 {
    public static void main(String[] args) throws IOException {
        read("a.txt");
    }

    public static void read(String path)throws FileNotFoundException, IOException {
        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException("文件不存在");
        }
        if (!path.equals("b.txt")) {
            throw new IOException();
        }
    }
}
```

#### Exception大的异常

```java
public class Demo {
    public static void main(String[] args) throws Exception {
        read("a.txt");
    }
    public static void read(String path)throws Exception {
        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException("文件不存在");
        }
        if (!path.equals("b.txt")) {
            throw new IOException();
        }
    }
}
```

#### throw 与 throws的区别

```
1.throw代表动作,表示抛出一个异常的动作; throws代表一种状态,代表方法可能有异常抛出
2.throw用在方法实现中,而throws用在方法声明中
3.throw只能用于抛出一种异常,而throws可以抛出多个异常
```





#### finally 代码块

##### 什么 finally

​		有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。

什么时候的代码必须最终执行？

​	当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。



==具体代码 要等到讲IO流的时候 ，会写IO流处理异常标准格式==



##### finally格式

```java
try {
	可能出现异常的代码;
    	。。。
} catch(异常类名 变量名) {
	异常的处理代码;
} finally{
    释放资源
}
```

- #### 注意

  > finally不能单独使用。必须配合着try...catch使用

代码示例

```java
public static void main(String[] args) {
    try {
        int[] arr = {1,2,3};
        System.out.println(arr[3]);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        System.out.println("finally代码块执行了.....");
    }
}
```

- #### 注意

  > 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。



#### 异常的注意事项

- 多个异常使用捕获又该如何处理呢？

  1. 多个异常分别处理。
  2. 多个异常一次捕获，多次处理。
  3. 多个异常一次捕获一次处理。

  一般我们是使用一次捕获多次处理方式，格式如下：

  ```java
  try{
       编写可能会出现异常的代码
  }catch(异常类型A  e){  // 当try中出现A类型异常,就用该catch来捕获.
       处理异常的代码
       //记录日志/打印异常信息/继续抛出异常
  }catch(异常类型B  e){  // 当try中出现B类型异常,就用该catch来捕获.
       处理异常的代码
       //记录日志/打印异常信息/继续抛出异常
  }
  ```

  > 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。

- 运行时异常被抛出可以不处理。即不捕获也不声明抛出。

- 如果finally有return语句,永远返回finally中的结果,避免该情况. 

- 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。

- 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出

```java
/**
 * 注意事项：
 *  1:能明确的尽量明确，不要用大的来处理。
 *  2:平级关系的异常谁前谁后无所谓，如果出现了子父关系，父必须在后面。
 */
public class Demo {
    public static void main(String[] args){
        int a = 10;
        int b = 0;
        int[] arr = {1,2,3};

        try {
            // System.out.println(a/b);
            System.out.println(arr[3]);
        } catch (ArithmeticException ae) {
            ae.printStackTrace();
            System.out.println("我是算术异常");
        } catch (ArrayIndexOutOfBoundsException ae) {
            ae.printStackTrace();
            System.out.println("我是数组异常");
        } catch (Exception e ){
            e.printStackTrace();
            System.out.println("我是异常");
        }
    }
    
     public static void main(String[] args) {
        int a = 10;
        int b = 0;
        int[] arr = {1,2,3};
        try {
            System.out.println(a/b);
            System.out.println(arr[9]);
            //。。。。异常
        } catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
            e.printStackTrace();
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



#### 如果在finally之前有return

```java
/*
 * 面试题：
 * 2:如果catch里面有return语句，请问finally里面的代码还会执行吗?
 *   如果会，请问是在return前，还是return后。
 *        会。前。
 */
    public static void main(String[] args) {
        System.out.println(getInt());
    }

    public static int getInt() {
        int a = 10;
        try {
            System.out.println(a / 0);
            a = 20;
        } catch (ArithmeticException e) {
            a = 30;
            return a;
            /*
             * return a在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了。
             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
             * 再次回到以前的返回路径，继续走return 30;
             */
        } finally {
         	System.out.println("我是finally");
        }
        return a;
    }
```

# 


### 单元测试

#### 什么是单元测试？

​	单元测试(unit testing),是指对软件中的最小可测试单元进行检查和验证。

​	单元是人为规定的最小的被测功能模块。



#### 常用的Java测试框架

Junit：是一个为Java编程语言设计的单元测试框架。（主要）

Mockito：允许程序员使用自动化的单元测试创建和测试模拟对象。

PowerMock：PowerMock利用自定义的类加载器和字节码操纵器，来确保静态方法的模拟、静态初始化的删除、函数构造、最终的类和方法以及私有方法。



#### Junit单元测试

JUnit提供了非常强大的注解功能，通过`@Test`注解修饰到方法上，该方法就变为了一个测试方法，执行当前类时，会自动的执行该类下所有带`@Test`注解的用例。

实例

![img](image\junit事例.png)

除了@Test注解外，还有以下常用注解：

@BeforeEach:当前的方法需要在每个用例执行之前都执行一次
@BeforeAll:当前的方法需要在当前类下所有用例执行之前执行一次，且被该注解修饰的方法必须为静态方法
@AfterEach:当前的方法需要在每个用例执行之后都执行一次
@AfterAll:当前的方法需要在当前类下所有用例执行之后执行一次，且被该注解修饰的方法必须为静态方法



#### 断言

检查测试方法的期望结果值和真实返回值，通过Assertions类实现。

- 断言匹配/不匹配：assertEquals()、assertNotEquals()
- 断言结果为真/为假：assertTrue()、assertFalse()
- 断言结果为空/非空：assertNull()、assertNotNull()

```
`@Test``    ``void` `a() {``        ``Assertions.assertTrue(``1``==``1``);``    ``}`
```



## 模块功能实现

#### 个人中心模块

界面

```
private void myselfView() {

        System.out.println("当前所在位置：##########学生系统>个人信息管理##########");

        System.out.println("基本信息：" + loginStudent);

        while (true) {
            System.out.println("请选择功能：1 修改密码 2 修改电话 3 修改地址 0 返回上一级");
            String tnum = sc.nextLine();
            switch (tnum) {
                case "1":
                    System.out.println("请输入新密码：");
                    String password = sc.nextLine();
                    studentService.updatePassword(loginStudent.getId(), password);
                    System.out.println("密码修改完成，请牢记新密码:" + password);
                    break;

                case "2":
                    System.out.println("请输入新手机号:");
                    String phone = checkTeacherPhone();
                    studentService.updatePhone(loginStudent.getId(), phone);
                    System.out.println("修改完成");
                    break;

                case "3":
                    System.out.println("请输入新地址：");
                    String address = sc.nextLine();
                    studentService.updateAddress(loginStudent.getId(), address);
                    System.out.println("修改完成");
                    break;

                case "0":
                    return;

                default:
                    System.out.println("该功能暂未开放，请重新选择");
            }

            //更新登录用户信息
            //根据id查询
            loginStudent = studentService.findStudentById(loginStudent.getId());


        }
    }

```

 

持久层

```

   /**
     * 根据学号查询学生信息
     * @param id
     * @return
     */
    @Override
    public Student findStudentById(String id) {
        return template.queryForObject("select * from student where id=?",new BeanPropertyRowMapper<>(Student.class),id);
    }

    /**
     * 修改地址
     * @param id
     * @param address
     * @return
     */
    @Override
    public int updateAddress(String id, String address) {
        return template.update("update Student set address=? where id=?",address,id);
    }

    /**
     * 修改电话
     * @param id
     * @param phone
     * @return
     */
    @Override
    public int updatePhone(String id, String phone) {
        return template.update("update Student set phone=? where id=?",phone,id);
    }

    /**
     * 修改密码
     * @param id
     * @param password
     * @return
     */
    @Override
    public int updatePassword(String id, String password) {
        return template.update("update Student set password=? where id=?",password,id);
    }

  
   
```



#### 个人成绩

```
  private void scoreView() {

        System.out.println("您的成绩如下：");
        System.out.println("*********************************************************");
        List<Map<String,Object>> scores = scoreService.findScoresBySid(loginStudent.getId());
        if(scores.size()==0){
            System.out.println("暂未查询到课程成绩");
        }else{

            for (Map<String, Object> score : scores) {

                System.out.println(score.get("cname")+":"+score.get("grade"));
            }
        }

        System.out.println("*********************************************************");

    }
```

 

持久层

```
  @Override
    public List<Map<String, Object>> queryScoresBySid(String id) {

        return template.queryForList("select cname,grade from course c,score s where c.id = s.cid and s.sid=?",id);
    }
```

##### 选课

界面

```
 /**
     * 选课界面
     *
     */
    private void electiveCourseView() {

        System.out.println("当前所在位置：##########学生系统>选课管理##########");

        //查询选课信息
        Map<String,Object> map = courseService.findElectiveCoursesBySid(loginStudent.getId());

        if(map==null){
            System.out.println("暂未进行课程选修！请即时选修");

            //选修课程
            System.out.println("你可选修的课程如下:");
            List<Map<String,Object>> courseList = courseService.findCourseByTypeAndSid();

            if(courseList.size()==0){
                System.out.println("没有新的选修课程信息，请过段时间再进行尝试！");
                return;
            }

            ArrayList<Object> tids = new ArrayList<>();

            for (Map<String,Object> mp: courseList) {
                System.out.println("课程名称:"+mp.get("cname")+"\t 教师:"+mp.get("tname")+"\t教师编号:"+mp.get("tid"));
                tids.add(mp.get("tid"));
            }

            System.out.println("请输入选修课程的教师编号：");
            String tid=null;
            while (true){
                tid = sc.nextLine();

                if(tids.contains(tid)){
                    break;
                }

                System.out.println("你选择的课程教师不在选修列表内，请重新选择：");
            }

            //添加选修
            courseService.electiveCourse(tid,loginStudent.getId());

            System.out.println("选课成功！");

        }else{
            System.out.println("##############################################");
            System.out.println("你已选修的课程如下:");

            System.out.println("课程名称:"+map.get("cname")+"\t教师:"+map.get("tname"));
            System.out.println("##############################################");



        }



    }
```

##  

持久层

```
/**
     * 查询学生可选修课程
     *
     * @param id
     * @return
     */
    @Override
    public Map<String, Object> findElectiveCoursesBySid(String id) {
        return template.queryForMap("select c.cname,t.name tname from course c,teacher t,electivecourse ec where t.cid=c.id and t.id=ec.tid and ec.stid=?",id);
    }

    @Override
    public List<Map<String,Object>> findCourseByTypeAndSid() {
        return template.queryForList("select cname,t.name tname,t.id tid from course c,teacher t where type=2 and t.cid = c.id");
    }

    /**
     * 添加选课信息
     *
     * @param tid
     * @param id
     */
    @Override
    public void addElectiveCourse(String tid, String id) {

        template.update("insert into electiveCourse values(null,?,?)",id,tid);
    }
```







## 本章总结

 

本章重点讲解学生模块的开发实现。

 

## 布置作业

1. 完成界面创建。

2. 完成相关数据操作。


