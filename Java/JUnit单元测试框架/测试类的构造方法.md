在 JUnit 5 中，测试类的构造方法 **每次都会被调用**，即每个测试方法在执行时都会创建一个新的测试类实例。这意味着对于同一个测试类中的多个测试方法，它们会使用不同的测试类实例进行测试。

### 具体解释

- **每个测试方法都有独立的实例**：在 JUnit 5 中，每次运行测试方法时，JUnit 都会创建一个新的测试类实例。这与 JUnit 4 的默认行为相同。这样做的好处是每个测试方法都能在一个干净的、独立的状态下运行，避免测试方法之间的相互干扰。

- **构造方法调用频率**：由于每个测试方法运行时都会创建一个新的实例，因此测试类的构造方法会在每次测试方法执行之前被调用。

### 示例代码

```java
import org.junit.jupiter.api.Test;

class MyTests {

    MyTests() {
        System.out.println("Constructor called");
    }

    @Test
    void test1() {
        System.out.println("Running test1");
    }

    @Test
    void test2() {
        System.out.println("Running test2");
    }
}
```

### 预期输出

如果你运行上述测试类，输出可能如下：

```
Constructor called
Running test1
Constructor called
Running test2
```

### 结论

从输出可以看出，每个测试方法在执行之前，都会调用测试类的构造方法并创建一个新的实例。测试类的构造方法 **确实会在每次测试方法调用时被执行**。

这种机制**确保了测试方法之间没有共享状态，从而使测试结果更加可靠和独立**。如果你需要在所有测试方法之间共享一些资源，可以使用 `@BeforeAll` 和 `@AfterAll` 注解，并将这些方法定义为静态方法。


-------------------------------------------------------------------


如果你希望在 JUnit 5 中的**测试类构造方法只被调用一次**，即在所有测试方法执行前只创建一次测试类实例，你需要使用 `@TestInstance` 注解。这个注解允许你控制测试实例的生命周期。

### 使用 `@TestInstance` 注解

默认情况下，JUnit 5 每个测试方法都会创建一个新的测试类实例，这种生命周期模式称为 **`PER_METHOD`**。为了让测试类的构造方法只被调用一次，你可以将测试实例的生命周期模式更改为 **`PER_CLASS`**。这样，JUnit 5 在运行整个测试类时，只会创建一个实例，并复用该实例运行所有测试方法。

### 示例代码

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class MyTests {

    MyTests() {
        System.out.println("Constructor called");
    }

    @Test
    void test1() {
        System.out.println("Running test1");
    }

    @Test
    void test2() {
        System.out.println("Running test2");
    }
}
```

### 预期输出

如果你运行上述测试类，输出可能如下：

```
Constructor called
Running test1
Running test2
```

### 解释

- **`@TestInstance(TestInstance.Lifecycle.PER_CLASS)`**：这个注解指定了测试实例的生命周期为类级别 (`PER_CLASS`)。这意味着在测试类中所有测试方法执行期间，JUnit 5 只会创建一个测试类实例，并复用该实例来运行所有测试方法。

- **构造方法调用频率**：在这种模式下，构造方法只会在测试类第一次被使用时调用一次，之后所有的测试方法都将使用同一个测试类实例。

### 注意事项

使用 `PER_CLASS` 模式时，测试方法之间可以共享测试类的状态（如实例变量）。这需要格外注意，以避免测试方法之间相互影响，从而导致测试结果不可靠。如果你需要多个测试方法共享一些资源或状态，这种模式非常适用；但如果你希望测试方法完全独立，不共享任何状态，还是应该使用默认的 `PER_METHOD` 模式。