#### // 线程 = 程序的执行路径 
#### // 我们可以使用多个线程来执行， 
#### // 我们的程序同时执行不同的任务。 
#### // 当前运行的线程是“主”线程 
#### // 使用using System.Threading;

---
**Thread mainThread = Thread.CurrentThread;**
### 代码含义

- **Thread mainThread:** 声明了一个名为 `mainThread` 的变量，它的类型是 `Thread`。这个变量将用来存储一个线程对象。
- **Thread.CurrentThread:** 这部分代码是一个静态方法调用。它返回一个代表当前正在执行代码的线程对象的引用。换句话说，它告诉我们现在正在运行的是哪个线程。
- **=:** 等号是赋值运算符，将 `Thread.CurrentThread` 返回的线程对象赋值给 `mainThread` 变量。

### 整体解释

所以，这段代码的作用就是：

1. **获取主线程:** 程序启动时，会创建一个主线程。`Thread.CurrentThread` 就会获取到这个主线程。
2. **保存主线程引用:** 将获取到的主线程的引用保存到 `mainThread` 变量中。

### 使用场景

- **标识主线程:** 在多线程程序中，你可以使用 `mainThread` 来标识主线程，以便与其他子线程进行区分。
- **获取主线程信息:** 通过 `mainThread`，你可以获取主线程的一些信息，比如线程名称、线程状态等。
- **控制主线程行为:** 在某些特殊情况下，你可能需要对主线程进行一些控制，比如等待主线程结束等。

```c#
using System;
using System.Threading;

namespace MyFirstProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            Thread mainThread = Thread.CurrentThread;
            mainThread.Name = "Main Thread";
            //Console.WriteLine(mainThread.Name);
            
			//CountDown() //先
			//CountUp()   //后
			
			//同时进行
            Thread thread1 = new Thread(() => CountDown("Timer #1"));
            Thread thread2 = new Thread(() => CountUp("Timer #2"));
            thread1.Start();
            thread2.Start();

            Console.WriteLine(mainThread.Name + " is complete!");

            Console.ReadKey();
        }  
        public static void CountDown(String name)
        {
            for (int i = 10; i >= 0; i--)
            {
                Console.WriteLine("Timer #1 : " + i + " seconds");
                Thread.Sleep(1000);
            }
            Console.WriteLine("Timer #1 is complete!");
        }
        public static void CountUp(String name)
        {
            for (int i = 0; i <= 10; i++)
            {
                Console.WriteLine("Timer #2 : " + i + " seconds");
                Thread.Sleep(1000);
            }
            Console.WriteLine("Timer #2 is complete!");
        }
    }
}
```

在C#中 ，多线程是一个重要的技术，用于并发执行任务，从而提高程序的性能和响应能力。C# 提供了多种多线程编程方式，包括使用 `Thread` 类、`ThreadPool`、`Task` 并行库 (TPL) 以及异步编程模型 (async/await)。

### 1. 使用 `Thread` 类

`Thread` 类是最基础的多线程编程方式，可以手动创建和管理线程。

#### 示例：

```csharp
using System;
using System.Threading;

class Program
{
    static void Main(string[] args)
    {
        Thread thread = new Thread(new ThreadStart(PrintNumbers));
        thread.Start();
        thread.Join(); // 等待新线程完成

        // 主线程继续执行其他任务
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine("Main thread: " + i);
            Thread.Sleep(1000);
        }
    }

    static void PrintNumbers()
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine("Secondary thread: " + i);
            Thread.Sleep(1000);
        }
    }
}
```

### 2. 使用 `ThreadPool`

`ThreadPool` 提供了一个**线程池**来管理线程。你可以将任务排队到线程池中，而不必手动创建和管理线程。

#### 示例：

```csharp
using System;
using System.Threading;

class Program
{
    static void Main(string[] args)
    {
        ThreadPool.QueueUserWorkItem(PrintNumbers);

        // 主线程继续执行其他任务
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine("Main thread: " + i);
            Thread.Sleep(1000);
        }

        // 等待用户按下回车键
        Console.ReadLine();
    }

    static void PrintNumbers(object state)
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine("Thread pool: " + i);
            Thread.Sleep(1000);
        }
    }
}
```

### 3. 使用 `Task` 并行库 (TPL)

`Task` 并行库是更高级的多线程编程方式，提供了更多功能和更简单的语法。

#### 示例：

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main(string[] args)
    {
        Task task = Task.Run(() => PrintNumbers());

        // 主线程继续执行其他任务
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine("Main thread: " + i);
            Task.Delay(100).Wait();
        }

        task.Wait(); // 等待任务完成
    }

    static void PrintNumbers()
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine("Task: " + i);
            Task.Delay(100).Wait();
        }
    }
}
```

### 4. 异步编程 (async/await)

异步编程模型 (async/await) 是 C# 中最简洁和强大的并发编程方式，尤其适合 I/O 绑定的操作。

#### 示例：

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        Task task = PrintNumbersAsync();

        // 主线程继续执行其他任务
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine("Main thread: " + i);
            await Task.Delay(100);
        }

        await task; // 等待异步任务完成
    }

    static async Task PrintNumbersAsync()
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine("Async task: " + i);
            await Task.Delay(100);
        }
    }
}
```

### 5. 线程同步

在多线程编程中，有时需要同步线程以防止竞争条件。可以使用锁（`lock`）、信号量（`Semaphore`）等同步机制。

#### 示例：使用 `lock` 进行线程同步

```csharp
using System;
using System.Threading;

class Program
{
    static readonly object _lock = new object();

    static void Main(string[] args)
    {
        Thread thread1 = new Thread(PrintNumbers);
        Thread thread2 = new Thread(PrintNumbers);

        thread1.Start();
        thread2.Start();

        thread1.Join();
        thread2.Join();
    }

    static void PrintNumbers()
    {
        for (int i = 0; i < 5; i++)
        {
            lock (_lock)
            {
                Console.WriteLine(Thread.CurrentThread.ManagedThreadId + ": " + i);
                Thread.Sleep(100);
            }
        }
    }
}
```

### 总结

C# 提供了多种多线程编程方式，从基础的 `Thread` 类到高级的 `Task` 并行库和异步编程模型 (async/await)，每种方式都有其适用的场景和优缺点。选择合适的多线程编程方式可以帮助你编写高效、响应迅速的应用程序。