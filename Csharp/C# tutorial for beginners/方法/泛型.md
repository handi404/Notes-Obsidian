#### // generic =“不特定于特定数据类型” 
#### // 将<>添加到：类、方法、字段等。
#### // 允许不同数据类型的代码重用

---

```c#
using System;

namespace MyFirstProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] intArray = { 1, 2, 3 };
            double[] doubleArray = { 1.0, 2.0, 3.0 };
            String[] stringArray = { "1", "2", "3" };
            Player[] playerArray = { new Player("bro"), 
            					 new Player("hasn"), 
            					 new Player("cao") };

            displayElements(intArray);
            displayElements(doubleArray);
            displayElements(stringArray);
            displayElements(playerArray);

            Console.ReadKey();
        }     
        public static void displayElements<Thing>(Thing[] array)
        {
            foreach (Thing item in array)
            {
                Console.Write(item + " ");
            }
            Console.WriteLine();
        }
    }
    class Player
    {
        public Player()
        {
        }
    
        public string Name { get; set; }
    
        public Player(string name)
        {
            Name = name;
        }
        public override string ToString()
        {
            return "Hello " + "my name is " + Name;
        }
    }
}
```

## C# 泛型：编写灵活、可重用的代码

### 什么是泛型？

C# 泛型（Generics）是一种编程技术，它允许你在编写代码时使用类型参数，而不是具体的类型。这样一来，你就可以创建可重用的组件，这些组件可以与多种数据类型一起工作，而无需为每种数据类型编写单独的版本。

**为什么要使用泛型？**

- **类型安全：** 编译器可以在编译时检查类型，避免运行时错误。
- **代码重用：** 通过使用类型参数，可以编写适用于多种类型的代码，减少重复代码。
- **性能提升：** 在某些情况下，泛型代码可以生成更高效的代码。
- **提高代码可读性：** 使用泛型可以使代码更具表达性，更容易理解。

### 泛型类的定义

```C#
public class GenericList<T>
{
    private T[] _items = new T[10];
    // ... 其他成员
}
```

- `GenericList<T>`：定义了一个泛型类，T 是一个类型参数。
- `T[] _items`：声明了一个类型为 T 的数组。

### 泛型方法的定义

```C#
public T GetElement<T>(int index)
{
    return _items[index];
}
```

- `T GetElement<T>(int index)`：定义了一个泛型方法，T 是一个类型参数。

### 泛型接口的定义

```C#
public interface IGenericList<T>
{
    void Add(T item);
    T GetElement(int index);
}
```

- `IGenericList<T>`：定义了一个泛型接口，T 是一个类型参数。

### 泛型约束

为了确保类型安全和功能正确性，你可以对类型参数施加约束。

- **where T : struct**：限制 T 为值类型。
- **where T : class**：限制 T 为引用类型。
- **where T : IComparable**：限制 T 实现 IComparable 接口。
- **where T : new()**：限制 T 有无参构造函数。

```C#
public class GenericClass<T> where T : IComparable
{
    // ...
}
```

### 泛型委托

```C#
public delegate T MyDelegate<T>(T arg);
```

### 泛型事件

```C#
public class GenericClass<T>
{
    public event EventHandler<T> MyEvent;
    // ...
}
```

### 泛型集合

C# 的集合类（如 List、Dictionary）都是泛型的，这使得它们可以存储任意类型的对象。

### 使用泛型

```C#
List<int> numbers = new List<int>();
numbers.Add(1);
numbers.Add(2);

GenericList<string> strings = new GenericList<string>();
strings.Add("Hello");
```

### 泛型的好处

- **类型安全：** 编译器会检查类型是否匹配，避免运行时错误。
- **代码复用：** 编写一次代码，可以用于多种数据类型。
- **性能提升：** 编译器可以针对特定的类型生成优化代码。
- **提高代码可读性：** 代码更简洁、易于理解。

### 总结

C# 泛型是C#语言中非常强大的特性，它为编写通用、可重用的代码提供了有力支持。通过理解泛型的概念和用法，你可以编写出更加灵活、高效的代码。