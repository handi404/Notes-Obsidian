___

## EPIGRAMS IN PROGRAMMING 编程中的警句

___

1\. One man's constant is another man's variable.  
1. 一个人的常数是另一个人的变量。

2\. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.  
2. 功能延迟绑定; 数据结构诱导绑定。寓意：在编程过程的后期构建数据。

3\. Syntactic sugar causes cancer of the semicolon.  
3. 句法糖导致分号癌。

4\. Every program is a part of some other program and rarely fits.  
4. 每个程序都是其他程序的一部分，很少适合。

5\. If a program manipulates a large amount of data, it does so in a small number of ways.  
5. 如果一个程序操作了大量数据，它以少数方式进行操作。

6\. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.  
6. 对称性是一个降低复杂性的概念（协程包括子例程）; 到处寻找它。

7\. It is easier to write an incorrect program than understand a correct one.  
7. 编写不正确的程序比理解正确的程序更容易。

8\. A programming language is low level when its programs require attention to the irrelevant.  
8. 当一种编程语言的程序需要注意不相关的内容时，它是低级的。

9\. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.  
9. 让 100 个函数在一个数据结构上运行比在 10 个数据结构上运行 10 个函数要好。

10\. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference (!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.  
10. 尽早进入陈规陋习：以同样的方式执行相同的过程。积累成语。规范。莎士比亚和你之间唯一的区别是他的成语列表的大小 - 而不是他的词汇量。

11\. If you have a procedure with ten parameters, you probably missed some.  
11. 如果你有一个有十个参数的过程，你可能错过了一些。

12\. Recursion is the root of computation since it trades description for time.  
12. 递归是计算的根源，因为它用描述换取时间。

13\. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.  
13. 如果两个人编写完全相同的程序，那么每个人都应该被放入微码中，那么他们肯定不会相同。

14\. In the long run every program becomes rococo - then rubble.  
14. 从长远来看，每个程序都变成了洛可可式 - 然后是瓦砾。

15\. Everything should be built top-down, except the first time.  
15. 一切都应该自上而下地构建，除了第一次。

16\. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.  
16. 每个程序（至少）有两个目的：一个是编写它的目的，另一个不是它的目的。

17\. If a listener nods his head when you're explaining your program, wake him up.  
17. 如果听众在你解释你的节目时点头，叫醒他。

18\. A program without a loop and a structured variable isn't worth writing.  
18. 一个没有循环和结构化变量的程序不值得写。

19\. A language that doesn't affect the way you think about programming, is not worth knowing.  
19. 一门不影响你对编程的思考方式的语言，是不值得了解的。

20\. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.  
20. 凡是模块化的地方，就有可能产生误解：隐藏信息意味着需要检查沟通。

21\. Optimization hinders evolution.  
21. 优化阻碍了进化。

22\. A good system can't have a weak command language.  
22. 一个好的系统不能有弱的命令语言。

23\. To understand a program you must become both the machine and the program.  
23. 要理解一个程序，你必须既是机器又是程序。

24\. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.  
24. 也许如果我们从小就写程序，成年后我们就能阅读它们。

25\. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.  
25. 一个人只能在脑海中显示复杂的信息。就像看一样，无论多么可爱，运动或流动或改变视图都比静态图片更重要。

26\. There will always be things we wish to say in our programs that in all known languages can only be said poorly.  
26. 在我们的节目中，总会有一些我们想说的话，在所有已知的语言中只能说得很糟糕。

27\. Once you understand how to write a program get someone else to write it.  
27. 一旦你了解了如何编写程序，就让别人来编写它。

28\. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?  
28. 在计算机周围，很难找到正确的时间单位来衡量进度。一些大教堂花了一个世纪才完成。你能想象一个需要这么长时间的计划的宏伟和范围吗？

29\. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.  
29. 对于系统来说，改头换面的类似方法是在控制图中添加一个创建循环的边缘，而不仅仅是一个额外的节点。

30\. In programming, everything we do is a special case of something more general -- and often we know it too quickly.  
30. 在编程中，我们所做的一切都是更普遍的特例——而且我们往往知道得太快了。

31\. Simplicity does not precede complexity, but follows it.  
31. 简单不是在复杂之前，而是在复杂之后。

32\. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.  
32. 衡量程序员的标准不是他们的聪明才智和逻辑，而是他们案例分析的完整性。

33\. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.  
33. 第十一条诫命是“你要计算”或“你不可计算”——我忘了是哪一条。

34\. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.  
34. 字符串是一个鲜明的数据结构，无论它在哪里传递，都有很多重复的过程。它是隐藏信息的完美工具。

35\. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.  
35. 每个人都可以被教导雕刻：米开朗基罗必须被教导不要这样做。伟大的程序员也是如此。

36\. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.  
36. 使用程序来证明四色定理不会改变数学——它只是证明这个定理是一个世纪的挑战，对数学来说可能并不重要。

37\. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.  
37. 最重要的计算机是在我们的头骨中肆虐并不断寻求令人满意的外部模拟器的计算机。真实计算机的标准化将是一场灾难 - 因此它可能不会发生。

38\. Structured Programming supports the law of the excluded middle.  
38. 结构化编程支持被排除在外的中间人法则。

39\. Re graphics: A picture is worth 10 K words - but only those to describe the picture. Hardly any sets of 10 K words can be adequately described with pictures.  
39. Re 图形：一张图片价值 10 K 字 - 但仅限于描述图片的文字。几乎没有任何一组 10 K 个单词可以用图片充分描述。

40\. There are two ways to write error-free programs; only the third one works.  
40. 有两种方法可以编写无差错的程序; 只有第三个有效。

41\. Some programming languages manage to absorb change, but withstand progress.  
41. 一些编程语言设法吸收变化，但经受住了进步。

42\. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.  
42. 你可以通过观察程序员对 FORTRAN 持续生命力的态度来衡量他的观点。

43\. In software systems, it is often the early bird that makes the worm.  
43. 在软件系统中，往往是早起的鸟儿制造了蠕虫。

44\. Sometimes I think the only universal in the computing field is the fetch-execute cycle.  
44. 有时我认为计算领域唯一通用的是获取-执行循环。

45\. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.  
45. 计算的目标是模拟我们的综合能力，而不是理解我们的分析能力。

46\. Like punning, programming is a play on words.  
46. 就像双关语一样，编程是一种文字游戏。

47\. As Will Rogers would have said, "There is no such thing as a free variable."  
47. 正如威尔·罗杰斯（Will Rogers）所说，“没有自由变量这样的东西。

48\. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.  
48. 外行最好的编程书籍是《爱丽丝梦游仙境》; 但那是因为它是外行人最好的书。

49\. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.  
49. 放弃汇编语言是我们伊甸园里的苹果：使用浪费机器循环的语言是有罪的。LISP 机器现在允许 LISP 程序员放弃胸罩和遮羞布。

50\. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.  
50. 当我们理解基于知识的系统时，它将像以前一样 - 除了我们的指尖将被歌唱。

51\. Bringing computers into the home won't change either one, but may revitalize the corner saloon.  
51. 将电脑带入家中不会改变任何一个，但可能会使角落沙龙焕发活力。

52\. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.  
52. 系统有子系统，子系统有子系统等等，无穷无尽——这就是为什么我们总是重新开始。

53\. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.  
53. 如此多的好主意一旦踏上语义鸿沟的航行，就再也听不到了。

54\. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.  
54. 当心图灵焦油坑，其中一切皆有可能，但没有什么是容易的。

55\. A LISP programmer knows the value of everything, but the cost of nothing.  
55. LISP 程序员知道一切的价值，但什么都不知道。

56\. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.  
56. 软件一直处于紧张状态。作为象征，它是任意完善的; 但它也是任意变化的。

57\. It is easier to change the specification to fit the program than vice versa.  
57. 更改规范以适应程序比更改规范更容易。

58\. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.  
58. 傻瓜忽略了复杂性。实用主义者受苦。有些人可以避免它。天才将其删除。

59\. In English every word can be verbed. Would that it were so in our programming languages.  
59. 在英语中，每个单词都可以动词。在我们的编程语言中会是这样吗？

60\. In seeking the unattainable, simplicity only gets in the way.  
60. 在寻求无法实现的东西时，简单只会成为障碍。

61\. In programming, as in everything else, to be in error is to be reborn.  
61. 在编程中，就像在其他所有事情中一样，犯错就是重生。

62\. In computing, invariants are ephemeral.  
62. 在计算中，不变量是短暂的。

63\. When we write programs that "learn", it turns out that we do and they don't.  
63. 当我们编写“学习”的程序时，事实证明我们做到了，而他们没有。

64\. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.  
64. 通常，手段是目的的正当性：目标推进技术，即使目标结构崩溃，技术也能幸存下来。

65\. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.  
65. 不要搞错了：计算机处理的是数字——而不是符号。我们通过对一项活动进行算术化的程度来衡量我们的理解（和控制）。

66\. Making something variable is easy. Controlling duration of constancy is the trick.  
66. 使事物变得可变很容易。控制恒定性的持续时间是诀窍。

67\. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".  
67. 想想在寻求“算法”和“程序”之间的根本区别时所花费的所有精神能量。

68\. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?  
68. 如果我们相信数据结构，我们必须相信独立（因此是同时）处理。不然我们为什么要在结构内收集物品？为什么我们容忍那些只给我们一个而没有另一个的语言？

69\. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.  
69. 在 5 年的时间里，我们得到了一种出色的编程语言。只是我们无法控制 5 年期限的时间。

70\. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.  
70. 几个世纪以来，印第安人发展了手语来交流感兴趣的现象。来自不同部落（FORTRAN、LISP、ALGOL、SNOBOL 等）的程序员可以使用不需要他们在小马身上携带黑板的程序员。

71\. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.  
71. 文档就像定期保险：它令人满意，因为几乎没有订阅它的人依赖于它的好处。

72\. An adequate bootstrap is a contradiction in terms.  
72. 充分的引导在术语上是矛盾的。

73\. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.  
73. 控制其变化梯度的不是语言的弱点，而是语言的优势：唉，语言永远无法逃脱它的胚胎囊。

74\. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?  
74. 有没有可能软件与其他任何东西都不一样，它应该被丢弃：重点是将其视为肥皂泡？

75\. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.  
75. 由于其生命力，计算机领域总是迫切需要新的陈词滥调：平庸抚慰我们的神经。

76\. It is the user who should parameterize procedures, not their creators.  
76. 应该由用户参数化程序，而不是程序的创建者。

77\. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.  
77. 人，计算机和算法之间的控制论交换就像音乐椅游戏：对平衡的疯狂追求总是让三者中的一个感到不安。

78\. If your computer speaks English, it was probably made in Japan.  
78. 如果你的电脑说英语，它可能是日本制造的。

79\. A year spent in artificial intelligence is enough to make one believe in God.  
79. 在人工智能上花费一年的时间足以让一个人相信上帝。

80\. Prolonged contact with the computer turns mathematicians into clerks and vice versa.  
80. 与计算机的长期接触使数学家变成了文员，反之亦然。

81\. In computing, turning the obvious into the useful is a living definition of the word "frustration".  
81. 在计算机中，将显而易见的东西变成有用的东西是“挫折”一词的活生生的定义。

82\. We are on the verge: Today our program proved Fermat's next-to-last theorem.  
82. 我们正处于边缘：今天我们的程序证明了费马的倒数第二定理。

83\. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.  
83. 图灵机和现代计算机有什么区别？这与希拉里登上珠穆朗玛峰和在珠穆朗玛峰顶峰建立希尔顿酒店之间的情况相同。

84\. Motto for a research laboratory: What we work on today, others will first think of tomorrow.  
84. 研究实验室的座右铭：我们今天所做的事情，其他人将首先想到明天。

85\. Though the Chinese should adore APL, it's FORTRAN they put their money on.  
85. 虽然中国人应该崇拜 APL，但他们把钱花在了 FORTRAN 上。

86\. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.  
86. 如果我们认为在活跃的数据库系统中，程序与数据的比例可以任意缩小甚至保持很小，那我们就是自欺欺人。

87\. We have the mini and the micro computer. In what semantic niche would the pico computer fall?  
87. 我们有迷你电脑和微型电脑。微型计算机会落在什么语义利基？

88\. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.  
88. 麦克斯韦方程组不足以设计电动机，这不是计算机的错。

89\. One does not learn computing by using a hand calculator, but one can forget arithmetic.  
89. 一个人不会通过使用手动计算器来学习计算，但可以忘记算术。

90\. Computation has made the tree flower.  
90. 计算使树开花。

91\. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.  
91. 电脑让人想起 Lon Chaney ——它是一千张面孔的机器。

92\. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.  
92. 计算机是最终的污染者：它的粪便与它生产的食物没有区别。

93\. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.  
93. 当有人说“我想要一种编程语言，我只需要说出我想做的事情”时，请给他一根棒棒糖。

94\. Interfaces keep things tidy, but don't accelerate growth: Functions do.  
94. 界面保持整洁，但不会加速增长：功能可以。

95\. Don't have good ideas if you aren't willing to be responsible for them.  
95. 如果你不愿意对好主意负责，就不要有好主意。

96\. Computers don't introduce order anywhere as much as they expose opportunities.  
96. 计算机不会在任何地方引入秩序，因为它们会暴露机会。

97\. When a professor insists computer science is X but not Y, have compassion for his graduate students.  
97. 当教授坚持认为计算机科学是 X 而不是 Y 时，请同情他的研究生。

98\. In computing, the mean time to failure keeps getting shorter.  
98\. 在计算中，平均故障时间越来越短。

99\. In man-machine symbiosis, it is man who must adjust: The machines can't.  
99. 在人机共生中，人必须调整：机器不能。

100\. We will never run out of things to program as long as there is a single program around.  
100. 只要有一个程序，我们就永远不会用完要编程的东西。

101\. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.  
101. 处理失败很容易：努力改进。成功也很容易处理：你解决了错误的问题。努力改进。

102\. One can't proceed from the informal to the formal by formal means.  
102. 人们不能通过正式的方式从非正式到正式。

103\. Purely applicative languages are poorly applicable.  
103. 纯粹的应用性语言的适用性很差。

104\. The proof of a system's value is its existence.  
104. 系统价值的证明是它的存在。

105\. You can't communicate complexity, only an awareness of it.  
105. 你无法传达复杂性，只能意识到它。

106\. It's difficult to extract sense from strings, but they're the only communication coin we can count on.  
106. 很难从字符串中提取意义，但它们是我们唯一可以依靠的交流硬币。

107\. The debate rages on: is PL/I Bachtrian or Dromedary?  
107. 争论激烈：PL/I 是巴赫特里亚还是单峰骆驼？

108\. Whenever two programmers meet to criticize their programs, both are silent.  
108. 每当两个程序员见面批评他们的程序时，两人都保持沉默。

109\. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. Cm.  
109. 想想看！使用 VLSI，我们可以在 1 平方厘米内包装 100 个 ENIACS。

110\. Editing is a rewording activity.  
110. 编辑是一项改写工作。

111\. Why did the Roman Empire collapse? What is Latin for office automation?  
111. 罗马帝国为什么崩溃？什么是办公自动化的拉丁语？

112\. Computer Science is embarrassed by the computer.  
112. 计算机科学对计算机感到尴尬。

113\. The only constructive theory connecting neuroscience and psychology will arise from the study of software.  
113. 将神经科学和心理学联系起来的唯一建设性理论将产生于对软件的研究。

114\. Within a computer natural language is unnatural.  
114. 在计算机中，自然语言是不自然的。

115\. Most people find the concept of programming obvious, but the doing impossible.  
115. 大多数人觉得编程的概念是显而易见的，但做起来是不可能的。

116\. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.  
116. 你认为你知道什么时候可以学习，什么时候可以写作更确定，什么时候可以教书更确定，但什么时候可以编程更确定。

117\. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?  
117. 教孩子编程有悖于现代教育的精髓。制定计划、获得组织思想的纪律、关注细节和学会自我批评有什么乐趣？

118\. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.  
118. 如果你能想象一个计算机机器人是唯一卑微的社会，你可以想象任何事情。

119\. Programming is an unnatural act.  
119. 编程是一种不自然的行为。

120\. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.  
120. 调整旧程序以适应新机器通常意味着调整新机器以使其表现得像旧机器一样。


> [!NOTE]
>   From ACM's SIGPLAN publication, (September, 1982), Article "Epigrams inProgramming", by Alan J. Perlis of Yale University.  
>  摘自 ACM 的 SIGPLAN 出版物（1982 年 9 月），耶鲁大学的 Alan J. Perlis 撰写的文章“Epigrams in Programming”。
> 


