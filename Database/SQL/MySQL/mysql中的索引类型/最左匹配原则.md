## 索引最左前缀匹配原则

对于最左前缀匹配原则居然没有百度百科，实在是让我感觉不可思议。

最左前缀匹配原则，用几句话来概述就是：  
顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

##### 什么是最左匹配原则？

最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

#### 最左匹配原则实际场景及难点

如果只是上面这些概念的话，这篇博客显然是不合格的，那么接下来我们用实际场景来解释最左匹配原则的一些难点  
先创建一张表

```
CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `cid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `name_cid_INX` (`name`,`cid`),
  KEY `name_INX` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8
```

注意上面的语句，在倒数第三行创建了**name_cid_IN**X索引，包含name和cid字段  
在倒数第二行创建了**name_INX**索引，包含name字段

执行1:

EXPLAIN SELECT * FROM student WHERE cid=1;

结果：

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1702696607222-209c0521-f0d5-42ab-a9a8-4fff03c5b966.png)

依据mysql索引最左匹配原则，两个索引都匹配上了，这个没有问题。

执行2:

EXPLAIN SELECT * FROM student WHERE cid=1;

结果：

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1702696664591-5525364c-7071-414d-8c21-c69b26b4292c.png)

  

执行3：

EXPLAIN SELECT * FROM student WHERE cid=1 AND name=‘小红’;

结果：

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1702696702460-8f9e52a5-eba5-4876-bd29-ada8d4917a90.png)

  

这个时候，对于初步了解最左前缀匹配原则的同学就会懵逼了，纳尼？？？

执行2，执行3不应该都与最左前缀匹配原则完全相悖吗？怎么还是使用了索引？？？（可以看到key字段中都表示用了name_cid_INX索引）顿时怀疑人生了有木有？

如果你也有跟上述一样的心理变化，说明你对索引的理解是狭隘的（没错，说的就是我。。。）

好的，接下来我们来揭秘了

上述,的两个查询的explain结果中显示用到索引的情况类型是不一样的。,可观察explain结果中的type字段。执行2和执行3中的type字段分别是：

执行2. type: index

执行3. type: ref

解释：

index：这种类型表示是mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引

所以：对于执行2：

```
EXPLAIN SELECT * FROM student WHERE   cid=1;
```

判断条件是cid=1,而cid是(name,cid)复合索引的一部分，没有问题，可以进行index类型的索引扫描方式。explain显示结果使用到了索引，是index类型的方式。

ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。

**简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。**

有些了解的人可能会问，索引不都是一个有序排列的数据结构么。不过答案说的还不够完善，那只是针对单个索引，而复合索引的情况有些同学可能就不太了解了。

**下面就说下复合索引：**  
以该表的(name,cid)复合索引为例,它内部结构简单说就是下面这样排列的：

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1702696855449-1d5bad10-4722-4be8-9e03-5eedb36e1414.png)

mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。

所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的，当然，可能会出现上面的使用index类型的索引。这就是所谓的mysql为什么要强调最左前缀原则的原因。

**那么什么时候才能用到呢?**

当然是cid字段的索引数据也是有序的情况下才能使用咯，什么时候才是有序的呢？观察可知，当然是在name字段是等值匹配的情况下，cid才是有序的。发现没有，观察两个name名字为 c 的cid字段是不是有序的呢。从上往下分别是4 5。

这也就是mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。

所以对于执行3这条sql查询：

```
EXPLAIN SELECT * FROM student WHERE   cid=1 AND name='小红';
```

没有错，而且复合索引中的两个索引字段都能很好的利用到了！因为语句中最左面的name字段进行了等值匹配，所以cid是有序的，也可以利用到索引了。

你可能会问：我建的索引是(name,cid)。而我查询的语句是cid=1 AND name=‘小红’; 我是先查询cid，再查询name的，不是先从最左面查的呀？

好吧，我再解释一下这个问题：首先可以肯定的是把条件判断反过来变成这样 name=‘小红’ and cid=1; 最后所查询的结果是一样的。

那么问题产生了？既然结果是一样的，到底以何种顺序的查询方式最好呢？

**所以**，而此时那就是我们的**mysql查询优化器**该登场了，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。