# 1. 查询当前服务器中SQL执行频率

```
show GLOBAL|session STATUS  like "COM_______"; 
```

  

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701178854018-3c38927a-b16c-45bf-804d-f816e614e030.png)

# 2. 慢查询

## 2.1. 慢查询的概念

```
问 慢查询是什么
答 ChatGPT

慢查询是指【执行时间较长的数据库查询操作】。具体来说，慢查询通常是指执行时间超过一定阈值（如1秒）的查询。这可能是因为查询语句本身复杂，数据库表缺少必要的索引，数据量过大，或者其他一些性能方面的原因。

数据库管理系统通常提供了一些工具和日志，用于监控和记录执行时间超过设定阈值的查询，以帮助识别和优化慢查询。这些工具可以提供有关查询执行计划、索引使用情况等方面的信息，帮助数据库管理员和开发人员识别和解决性能问题。

优化慢查询是数据库性能优化的一部分，通过调整查询语句、优化数据库结构和索引，以及使用合适的缓存策略等手段，可以提高查询性能，减少慢查询的发生。
```

## 2.2. 附，查看慢查询是开启还是关闭

```
SHOW VARIABLES LIKE 'slow_query_log';
```

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701179601141-dcab72ae-70a3-4745-b0f5-033c840832cd.png)

## 2.3. 附，开启慢查询

```
在MySQL中，可以通过以下步骤查看慢查询是否开启：
    登录到MySQL客户端。
    执行以下命令： 复制代码
        
    SHOW VARIABLES LIKE 'slow_query_log';

    如果返回结果中的Value列的值为ON，则表示慢查询已开启；如果为OFF，则表示慢查询已关闭。

    如果需要开启慢查询，可以修改MySQL配置文件my.cnf（或my.ini）中的[mysqld]部分，添加以下配置：
         
            复制代码
        
    slow_query_log = 1
    slow_query_log_file = /var/log/mysql/slow-query.log
    long_query_time =2 

    其中，slow_query_log设置为1表示开启慢查询日志记录，slow_query_log_file指定慢查询日志文件的路径，long_query_time设置慢查询的阈值，单位为秒。然后重启MySQL服务使配置生效。
```

# 3. 语句的执行计划EXPLAIN指令

## 3.1. 优化器

mysql中有专门负责优化select语句的【优化模块】，主要功能： 通过计算分析系统收集到的统计信息，为客户端请求的Query提供它认为最优的【执行计划】

## 3.2. 指令EXPLAIN能做什么？

1."EXPLAIN"命令用于分析SQL查询语句的执行计划，帮助优化查询性能。

  

```
问 mysql中的expain能做什么
答  星火 
MySQL中的EXPLAIN命令是一个性能分析工具，它可以模拟MySQL优化器执行SQL语句，
	从而MySQL中的EXPLAIN命令是一个性能分析工具，它可以模拟MySQL优化器执行SQL语句，
    从而帮助开发者深入理解查询的处理方式，    而无需实际执行这条SQL。
    通过使用EXPLAIN，您可以获取关于查询的多方面信息，包括但不限于：

    【表的读取顺序】：这可以帮助开发者理解数据访问的顺序和逻辑。
    【数据读取操作的类型】：这可以揭示查询在处理数据时的具体操作方式。
    【可用的索引】：这将显示查询可能用到的索引。
    【实际使用的索引】：这会展示查询在实际操作中用到了哪些索引。
    【表之间的引用】：如果查询涉及到多张表的联合查询，这将显示出表与表之间的关联关系。
    【每张表有多少行被优化器查询】：这可以帮助开发者判断查询的效率，以及是否需要对某些表进行优化以提高查询速度。

```

## 3.3. 语法

（1）

1. explain SQL语句 或者 describe SQL语句
2. 补充，这只是一个SQL语句执行计划分析，不是真正的执行，例如 explain DELETE FROM t_dish WHERE id=3;; 执行完后id=3的这条记录还在；

（2）执行示例

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701259962230-1c8fa803-c400-4b19-9174-115b7b9af897.png)

（3）执行结果列的解释

MySQL的EXPLAIN命令的执行结果每一列的含义如下：

1. id：查询的序列号，表示查询中每个子查询的执行顺序。如果是一个简单的查询，则id的值为1。
2. select_type：查询类型，表示查询的类型，例如简单查询、联合查询、子查询等。
3. table：输出的结果集所涉及的表。
4. type：这是表示连接类型，表示MySQL在查找数据时所使用的方式，如ALL、index等。
5. possible_keys：可能使用的索引。
6. key：实际使用的索引。
7. key_len：使用的索引的长度。
8. ref：显示哪个列或常量使用了key。
9. rows：扫描行数，表示通过全表扫描需要检查的行数。
10. filtered:实际读取记录的条数和符合符合条件的记录数的比率；
11. Extra：包含不适合在其他列中显示的额外信息，如是否使用了索引、是否执行了文件排序等。

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701260398108-395f5b68-3663-48f1-a970-ee05f1aef5be.png)

# 4. 执行计划中的查询任务和查询次数

## 4.1. 一遍的示例

1. 【标1】所示，只有一条记录，表示只执行了一个查询任务，只执行了一遍查询；
2. 【标2】所示，id值1，表示这个查询任务的ID编号为1，
3. 【标3】所示，表示查询时使用了哪个表；

```
# 查看购物车中用户ID=1001的所有购物记录
EXPLAIN select c.* from t_shopping_cart c WHERE c.user_id
=1001;
```

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702087162081-ed2da68c-a790-44c6-bdc9-915f3036083f.png)

## 4.2. 两遍的示例

1. 【标1】所示，有两条记录，表示这个查询任务，执行了两遍查询；
2. 【标2】所示，两条记录id的值都是1，表示这个两次查询都属于1号查询任务；
3. 【标3】所示，表示哪个查询使用了哪个表；

```
# 查看购物车中用户ID=1001的所有购物记录，并一同显示用户的用户名 
EXPLAIN select c.*,u.username  from t_shopping_cart c LEFT JOIN  t_user u ON c.user_id=u.id  WHERE c.user_id
=1001;
```

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702087068594-c65e711d-c9da-4236-b626-b44885f8ddd6.png)

## 4.3. 三遍的示例

### 4.3.1. 准备

(1)

1. 找到【标1】处的视图v_shop_cart_01，选中鼠标右键，在弹窗中选择【设计视图】，从视图窗口中复制SQL脚本；
2. 粘贴到【标2】处；
3. 找到【标3】处的Order，按【标3】所示，插入 where c.user_id=1001
4. 选中SQL语句部分，执行选中的SQL语句，能看到【标4】处符合条件的购物车清单列表；

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702088644993-62122f80-e5ac-4177-981e-5a3e2c9ff697.png)

(2) 附，代码

```
# 查看购物车中用户ID=1001的所有购物记录，并一同菜品名称和套餐名称 
EXPLAIN select `c`.`id` AS `id`,`c`.`user_id` AS `user_id`,`c`.`dish_id` AS `dish_id`,`c`.`setmeal_id` AS `setmeal_id`,`c`.`name` AS `name`,`c`.`image` AS `image`,`c`.`dish_flavor` AS `dish_flavor`,`c`.`price` AS `price`,`c`.`quantity` AS `quantity`,`c`.`amount` AS `amount`,`c`.`create_time` AS `create_time`,`d`.`name` AS `dish_name`,`d`.`price` AS `dish_price`,`s`.`name` AS `setmeal_name`,`s`.`price` AS `setmeal_price` from ((`t_shopping_cart01` `c` left join `t_dish` `d` on((`c`.`dish_id` = `d`.`id`))) left join `t_setmeal` `s` on((`c`.`setmeal_id` = `s`.`id`))) 
where c.user_id=1001     order by `c`.`id`;
```

### 4.3.2. 分析

1. 一次查询任务，执行了三次查询，哪次查询使用了哪个表

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702089305983-979b4941-4ea8-406e-b075-884ed0d1593d.png)

## 4.4. 多个查询任务

1. 【标1】所示，是一次查询任务；
2. 【标2】所示，又是一次查询任务；
3. 【标3】所示，是从两次查询结果中在执行一次联合任务；

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702090451749-c45a3eda-5467-4d3c-bae6-567938e908d1.png)

```
EXPLAIN 
SELECT "01",c1.* from t_shopping_cart c1 WHERE user_id=1001
	UNION
SELECT "02",c2.* from t_shopping_cart01 c2 WHERE user_id=1001;


-- 
EXPLAIN 
SELECT "01",c1.* from t_shopping_cart c1 WHERE user_id=1001
	UNION ALL
SELECT "02",c2.* from t_shopping_cart01 c2 WHERE user_id=1001;
```

# 5. 执行计划分析

## 5.1. 表t_shoping_cart02中的主键、索引、外键

1. 表t_shoping_cart01无主键、索引、外键；
2. 表t_shoping_cart02的：

（1）字段id做主键；

（2）字段user_id做索引；

（3）字段dish_id和setmeal_id联合做索引2；

（4）另外还有三个外键约束；

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702104996597-de95e936-b195-4954-baaa-d614166ad577.png)

## 5.2. 表t_shoping_cart01的执行计划分析

  

（1）使用到的语句

```
EXPLAIN SELECT c1.*  from  t_shopping_cart01  c1;
EXPLAIN  select c1.* from t_shopping_cart01 c1 where id>10000 and id<20000 ;
```

（2）第一条查询

1. 【标2】目前忽略；
2. 【标3】表示，本次查询中使用到的主键和索引；
3. 【标4】表示，主键或者索引占用的字节长度；即如果使用到主键和索引时，读一次主键或者索引时需要读多少个字节；
4. 【标5】表示，存在子查询或者多表关联查询时，存在的外部引用关系；
5. 【标6】表示，本次查询时，需要读取记录的总条数；
6. 【标7】表示，其中符合条件的记录数的比率；
7. 【表8】表示，额外摘要内容；

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702106290014-4b4e33d4-78db-40b0-b55b-5a98c89e24d0.png)

（3）第二条查询

1. 【标2】表示，没有使用到任何：主要和索引，也没有使用外键；
2. 【标3】和【标4】表示，本次查询共读取13635条，其中11.11%的记录符合条件；
3. 【标5】表示，通过where 筛选符合条件的记录的；

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702107098068-a76b734b-c972-4cc5-b461-3c8f5b5615cf.png)

## 5.3. 表t_shoping_cart02的执行计划分析1

（1）使用到的语句

```
EXPLAIN SELECT c2.*  from  t_shopping_cart02  c2;
EXPLAIN  select c2.* from t_shopping_cart02 c2 where id>10000 and id<20000 ;
```

（2）自动优化通过主键查询

1. 【标5】表示，通过主键查询；
2. 【标6】表示，一条记录中一个主键占用8个字节；
3. 【标7】表示，一共读了280条记录；
4. 【标8】表示，其中符合条件的100%；

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702109445972-e8c6f363-e284-422d-90d2-060cdc2e9949.png)

## 5.4. 表t_shoping_cart02的执行计划分析2

（1）脚本

```
EXPLAIN SELECT c2.*  from  t_shopping_cart02  c2;
EXPLAIN  select c2.* from t_shopping_cart02 c2 where id>10000 and id<20000;
# 扩展延伸
EXPLAIN  select c2.* from t_shopping_cart02 c2 
	where id>10000 and id<20000 and dish_id=55;
EXPLAIN  select c2.* from t_shopping_cart02 c2 
	where id>10000 and id<20000 and name="王老吉";
```

（2）执行

1. 【标2】表示，通过主键和索引进行查询；
2. 【标3】和【标4】表示，通过主键一共读了280条记录；
3. 【标5】-【标7】表示，通过索引再筛选出符合条件的占比3.39%；
4. 【标9】表示，只用到了主键；

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702110868417-7045618a-dbb9-4af5-af9d-7155194dd535.png)

# 6. 揭开视图查询的秘密

## 6.1. 视图v_shop_cart_01想象中执行方式

（1）脚本

```
EXPLAIN SELECT v1.* from v_shop_cart_01 v1 where user_id=1001;
```

（2）假设中的执行方式

1. 【标1】所示的查询语句，从【标2】的视图中查询数据；
2. 视图的数据，又从【标3】所示的查询语句产生的数据结构中再次查询而生成的；
3. 即，查询时，先驱动视图查询一次数据，再从第一次查询的结果集中查询产生数据；

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702115243114-e02d3a8a-0e83-457f-b533-c1e1b420d345.png)

## 6.2. 视图v_shop_cart_01的实际执行方式

1. 如【标1】和【标2】所示，整个查询通过MYSQL的优化器优化后，只发生了一次查询任务，不是两次查询任务；
2. 因为这视图是夸3个表通过左连接完成的查询，因此一个查询任务有3次查询；
3. 因为表t_shopping_cart没有主键、索引、外键，因此，第一个查询中，没有使用到任何优化处理；
4. 左连接的附表t_dish和t_setmeal的ID正好是主键，因此下面两个查询时，自动采用了主键优化；

左连接的

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702115998350-7ca8ba2a-6f35-4dc6-9ea7-21b49757b6a3.png)

## 6.3. 视图v_shop_cart_02的自动优化

1. 跟v_shop_cart_01的区别为，第一次查询时，自动选择了主键

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1702124446672-40264f05-eb29-426e-95dc-ee985433784b.png)

# 7. 意外情况

## 7.1. 重做表t_shopping_cart02 的数据

（1） 观察表t_shopping_cart02的主键、索引、外键时，能发现所有的外键都有一个对应的显氏索引或者隐式(自动生成的)索引；

```
摘自  chatGPT： 
MySQL 引擎的默认行为，称为隐式索引。当你添加一个外键时，
MySQL 会自动在引用列（被引用的表中的列，即外键）上创建一个索引，
以加速外键的检索。这有助于确保外键的参照完整性和提高查询效率。
```

（2）重做数据

```
USE SheQuGouV6B;

DROP TABLE IF EXISTS `t_shopping_cart02`;
CREATE TABLE `t_shopping_cart02` (
  `id` bigint NOT NULL  COMMENT '主键',
  `user_id` bigint NOT NULL COMMENT '客户ID,索引字段',
  `dish_id` bigint DEFAULT NULL COMMENT '对应菜品id',
  `setmeal_id` bigint DEFAULT NULL COMMENT '对应套餐id',
  `name` varchar(32) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '商品名称(冗余字段)',
  `image` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '图片(冗余字段)',  
  `dish_flavor` varchar(50) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '口味(冗余字段)',
  `price` decimal(10,2) NOT NULL COMMENT '单价',  
  `quantity` int NOT NULL DEFAULT 1 COMMENT '数量',
  `amount` decimal(10,2) NOT NULL COMMENT '小计金额',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间'   
  -- 没有任何 主键  索引、外键
   -- 没有任何主键，索引、外键
  -- INDEX idx_t_shopping_cart_userid (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='购物车02';

INSERT INTO t_shopping_cart02 
			select * from t_shopping_cart01; 		
			
-- 添加主键
ALTER TABLE `shequgouv6b`.`t_shopping_cart02` 
MODIFY COLUMN `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键' FIRST,
ADD PRIMARY KEY (`id`),
AUTO_INCREMENT = 300000;

-- 添加索引和外键，不创建 setmeal_id 的索引
ALTER TABLE `t_shopping_cart02`
ADD INDEX `idx_t_shopping02_cart_userid`(`user_id`),
ADD INDEX `idx_t_shopping02_cart_3`(`dish_id`,`setmeal_id`);
```

## 7.2. 被冷落的主键和索引(联合索引)

（1）示例

```
#使用主键
EXPLAIN SELECT * from t_shopping_cart02 where id <100000;
#使用主键和索引
EXPLAIN SELECT * from t_shopping_cart02 where id <100000 and dish_id<50000;
#使用索引
EXPLAIN SELECT * from t_shopping_cart02 where dish_id<50000;

#INDEX `idx_t_shopping02_cart_3`(`dish_id`,`setmeal_id`);
#   中明明有setmeal_id字段，但优化时却没有使用上呢？ 为什么？
EXPLAIN SELECT * from t_shopping_cart02 where setmeal_id<50000;

#这个能使用上主键和索引吗
EXPLAIN SELECT * from t_shopping_cart02 where name like "米%";
```

（2）左匹配原则在星火中的解释

```
问  mysql中联合索引的最左匹配原则是什么，并通过示例说明有效的匹配和失效的匹配

答  星火模型
MySQL中联合索引的最左匹配原则是指在使用联合索引进行查询时，
	MySQL会从联合索引的最左边开始匹配查询条件。只有当查询条件中的列按照
  联合索引的顺序从最左边开始连续匹配时，MySQL才会使用该联合索引进行查询。

下面通过一个示例来说明有效的匹配和失效的匹配：
假设有一个名为students的表，其中包含以下列：id（主键）、name、age、class。
	现在为name和class列创建一个联合索引idx_name_class。

有效的匹配示例：
   sql 复制代码    
SELECT * FROM students WHERE name = '张三' AND class = '一班';
在这个查询中，查询条件name = '张三'和class = '一班'都是按照联合索引
	idx_name_class的顺序从最左边开始连续匹配的，所以MySQL会使用该联合索引
  进行查询。

失效的匹配示例：
   sql  复制代码    
SELECT * FROM students WHERE name = '张三' OR class = '一班';  

在这个查询中，虽然查询条件包含了联合索引的所有列，但是因为使用了OR连接，
	导致查询条件无法按照联合索引的顺序从最左边开始连续匹配。
  所以MySQL不会使用该联合索引进行查询，而是选择全表扫描。
```

（3）左匹配原则在CharGPT中的解释

```
问 组合索引中 左匹配原则是什么
答  ChatGPT

左匹配原则指的是在组合索引中，索引的第一个列进行匹配的效果最好，而后续的列匹配效果逐渐减弱。

具体来说，如果一个组合索引是 (column1, column2, column3)，那么在查询条件中，如果能够使用到索引，最好是从左到右依次匹配，即：

    查询条件中包含了 column1，并且可以利用索引。
    查询条件中包含了 column1 和 column2，并且可以利用索引。
    查询条件中包含了 column1、column2 和 column3，并且可以利用索引。

如果只使用了组合索引中的某一部分列，而没有使用到组合索引的左侧列，那么索引的效能可能会下降。这是因为在 B 树索引中，索引的前缀可以直接作为单列索引使用，但如果不包含左侧列，就无法使用。

这并不是绝对规律，实际效果还受到数据分布、查询条件等多方面因素的影响。在具体的应用中，通过分析查询的具体情况，可以更好地选择适合的索引和查询策略。
```

# 8. 附，参考资料

## 8.1. mysql中的索引类型

```
问  mysql中，有哪几种索引，分别有什么特点
答 MySQL中常见的索引包括：

    主键索引（Primary Key Index）：
        特点：唯一标识表中的每一行记录，不能为空，每个表只能有一个主键索引。
        创建语法：PRIMARY KEY (column_name)

    唯一索引（Unique Index）：
        特点：确保索引列的值在整个表中唯一，但允许空值。
        创建语法：UNIQUE KEY (column_name)

    普通索引（Normal Index）：
        特点：对表中的某列创建索引，不要求唯一性。
        创建语法：INDEX index_name (column_name)

    全文索引（Full-Text Index）：
        特点：用于全文搜索，适用于对文本内容进行搜索的场景。
        创建语法：FULLTEXT KEY (column_name)

    组合索引（Composite Index）：
        特点：对表中的多个列创建索引，可以提高多列条件查询的效率。
        创建语法：INDEX index_name (column1, column2, ...)

    空间索引（Spatial Index）：
        特点：用于处理空间数据类型，如地理位置信息。
        创建语法：SPATIAL KEY (column_name)

这些索引类型在不同场景下有各自的优势和用途，
选择适当的索引类型可以提高查询性能。
```

## 8.2. 聚族索引

```
问 聚族索引是什么？ 有什么优缺点？上文中的哪些索引默采用了聚族索引？
答 chatGPT 
聚簇索引（Clustered Index）是一种特殊类型的索引，它决定了数据在磁盘上的物理存储顺序。
在聚簇索引下，表的行数据存储和索引存储在一起，形成一个物理上的顺序。
这与非聚簇索引（也称为非聚集索引）不同，非聚簇索引只存储索引的数据结构，
而不直接决定数据在磁盘上的物理存储顺序。

优点：

    快速检索： 聚簇索引的物理存储顺序使得范围查询和排序等操作更加高效，因为相关的数据行在物理上也是相邻的。
    减少IO操作： 由于相关数据存储在一起，IO操作的次数可能减少，因为在许多情况下，可以通过一次IO读取多个相邻的数据行。

缺点：

    插入和更新代价较高： 当插入或更新数据时，数据库引擎可能需要对整个数据页进行重组，以维护聚簇索引的物理顺序。这可能导致插入和更新操作的代价较高。
    空间利用： 由于数据行的物理存储顺序与聚簇索引的顺序一致，因此对于表的非聚簇索引，可能会占用较多的空间，因为它们需要存储指向实际数据行的引用。

在上文提到的MySQL中，【InnoDB存储引擎的主键索引是聚簇索引。
	如果表没有显式定义主键，InnoDB会选择一个唯一非空的索引作为聚簇索引，
  	或者如果没有这样的索引，InnoDB会生成一个隐藏的聚簇索引。】
在下列语句中：

sql

ALTER TABLE `t_shopping_cart02`
ADD PRIMARY KEY (`id`),
AUTO_INCREMENT = 300000;

这里通过添加PRIMARY KEY，给id列创建了主键索引，因此在InnoDB存储引擎下，它是一个聚簇索引。
```

## 8.3. B+树

1. CSDN网友分享：

[https://blog.csdn.net/weixin_44203782/article/details/131202433](https://blog.csdn.net/weixin_44203782/article/details/131202433)

2. 知乎分享

[https://www.zhihu.com/question/591053709/answer/3039461507?utm_id=0](https://www.zhihu.com/question/591053709/answer/3039461507?utm_id=0)

## 8.4. 网友分享

1. 《详解 SQL 优化》 [https://www.toutiao.com/article/7303349235867714099/](https://www.toutiao.com/article/7303349235867714099/)
2. 《最完整的Explain总结，SQL优化不再困难！》 [https://www.toutiao.com/article/7306335754626761254/](https://www.toutiao.com/article/7306335754626761254/)