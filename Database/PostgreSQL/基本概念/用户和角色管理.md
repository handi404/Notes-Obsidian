PostgreSQL 中的用户和角色管理。这部分是数据库安全和权限控制的核心。

PostgreSQL 在权限管理上有一个非常优雅和强大的设计：**它不区分“用户”和“组”，统一使用“角色 (Role)”这一概念。** 一个角色可以是一个数据库用户，也可以是一个用户组，或者两者皆是。

我们来逐一分解：

1.  **创建角色 (Creating Roles)**
2.  **角色属性 (Role Attributes)**
3.  **对象授权 (Object Authorization - `GRANT`)**
4.  **撤销授权 (Revoking Authorization - `REVOKE`)**
5.  **角色成员 (Role Membership)**
6.  **删除角色 (Deleting Roles)**

---

### 核心概念：一切皆角色

*   **统一性**：在 PostgreSQL 中，"用户 (User)" 和 "组 (Group)" 实际上都是 "角色 (Role)" 的特例。
    *   当你说 `CREATE USER`，它等同于 `CREATE ROLE ... LOGIN`。
    *   当你说 `CREATE GROUP`，它等同于 `CREATE ROLE ... NOLOGIN` (早期版本行为，现在更推荐直接用 `ROLE` 并管理其 `LOGIN` 属性)。
*   **灵活性**：这种设计使得权限管理非常灵活。你可以创建一个角色让它能登录（像用户），也可以创建另一个角色不能登录但用于聚合权限（像组），然后把能登录的角色加入到这个“组”角色中。

---

### 1. 创建角色 (Creating Roles)

最基础的命令是 `CREATE ROLE`。

```sql
CREATE ROLE role_name;
```

例如：
```sql
CREATE ROLE web_app_user;
CREATE ROLE data_analyst;
CREATE ROLE readonly_group;
```

**传统别名 (仍然可用，但不推荐作为主要方式)：**
*   `CREATE USER username;` 相当于 `CREATE ROLE username LOGIN;`
*   `CREATE GROUP groupname;` 相当于 `CREATE ROLE groupname NOLOGIN;` (在较新版本，它更像一个不带任何特权的 `CREATE ROLE groupname;`)

**最佳实践**：统一使用 `CREATE ROLE` 并明确指定其属性，这样更清晰。

---

### 2. 角色属性 (Role Attributes)

创建角色时或之后，可以为其指定多种属性，这些属性决定了角色的能力和行为。

**常用属性：**

*   **`LOGIN` / `NOLOGIN`**:
    *   `LOGIN`: 允许此角色登录到数据库。这是“用户”角色的典型特征。
    *   `NOLOGIN` (默认): 不允许此角色登录。这是“组”角色的典型特征，用于聚合权限。
*   **`SUPERUSER` / `NOSUPERUSER`**:
    *   `SUPERUSER`: 超级用户，拥有所有权限，绕过所有权限检查。**极度危险，应极少使用。**
    *   `NOSUPERUSER` (默认): 普通用户。
*   **`CREATEDB` / `NOCREATEDB`**:
    *   `CREATEDB`: 允许此角色创建新的数据库。
    *   `NOCREATEDB` (默认): 不允许。
*   **`CREATEROLE` / `NOCREATEROLE`**:
    *   `CREATEROLE`: 允许此角色创建、修改、删除其他角色，以及授予或撤销角色成员资格。**这也是一个非常强大的权限，需谨慎授予。**
    *   `NOCREATEROLE` (默认): 不允许。
*   **`INHERIT` / `NOINHERIT`**:
    *   `INHERIT` (默认): 角色自动继承其所属的“组”角色的所有权限。
    *   `NOINHERIT`: 角色不自动继承组权限，需要通过 `SET ROLE` 命令显式切换到组角色才能使用其权限。
*   **`REPLICATION` / `NOREPLICATION`**:
    *   `REPLICATION`: 允许此角色用于流复制连接，并能执行复制相关的命令。
    *   `NOREPLICATION` (默认): 不允许。
*   **`BYPASSRLS` / `NOBYPASSRLS`**:
    *   `BYPASSRLS`: 允许此角色绕过行级安全策略 (Row Level Security, RLS)。通常只给数据库所有者和超级用户。
    *   `NOBYPASSRLS` (默认): 角色受 RLS 策略限制。
*   **`PASSWORD 'your_password'` / `ENCRYPTED PASSWORD 'md5_hash_or_scram_hash'`**:
    *   为具有 `LOGIN` 属性的角色设置密码。
    *   **强烈推荐使用 `SCRAM-SHA-256` 加密** (通过在 `postgresql.conf` 中设置 `password_encryption = 'scram-sha-256'`)。如果客户端和服务器都支持，这是最安全的。MD 5 已经过时。
    *   `PASSWORD NULL` 可以移除密码（例如，用于仅通过 ident 或证书认证的角色）。
*   **`VALID UNTIL 'timestamp'`**:
    *   设置密码的有效期。例如 `VALID UNTIL '2024-12-31'`。
*   **`CONNECTION LIMIT count`**:
    *   限制此角色可以建立的并发连接数。`-1` (默认) 表示无限制。
*   **`IN ROLE role1, role2, ...`**:
    *   在创建角色时，立即将其添加为指定“组”角色的成员。
*   **`ROLE role1, role2, ...`**:
    *   同 `IN ROLE`。
*   **`ADMIN role1, role2, ...`**:
    *   将新角色添加为指定“组”角色的成员，并授予 `WITH ADMIN OPTION`。

**创建时指定属性示例：**
```sql
-- 一个典型的应用用户，可以登录，有密码，但没有其他特殊权限
CREATE ROLE app_user LOGIN PASSWORD 'S3curEPa$$wOrd' NOSUPERUSER NOCREATEDB NOCREATEROLE;

-- 一个只读权限组，不能登录
CREATE ROLE read_only_group NOLOGIN;

-- 一个管理员角色，可以创建其他角色和数据库（但不是超级用户）
CREATE ROLE db_admin CREATEDB CREATEROLE LOGIN PASSWORD 'Adm1nPa$$';
```

**修改角色属性：**
使用 `ALTER ROLE` 命令。
```sql
ALTER ROLE app_user CONNECTION LIMIT 10;
ALTER ROLE data_analyst LOGIN; -- 允许 data_analyst 角色登录
ALTER ROLE app_user PASSWORD 'NewS3curEPa$$wOrd';
ALTER ROLE app_user VALID UNTIL 'infinity'; -- 密码永不过期
ALTER ROLE app_user SET search_path = public, app_schema; -- 为角色设置默认搜索路径
```

---

### 3. 对象授权 (Object Authorization - `GRANT`)

一旦角色创建完成，你需要授予它们访问数据库对象的权限。

**基本语法：**
`GRANT privilege [, ...] ON object_type object_name [, ...] TO role_name [, ...] [WITH GRANT OPTION];`

*   **`privilege`**: 权限类型，如：
    *   `SELECT`, `INSERT`, `UPDATE`, `DELETE`: 对表、视图、列的 DML 权限。
    *   `TRUNCATE`: 对表的 `TRUNCATE` 权限。
    *   `REFERENCES`: 创建外键约束的权限。
    *   `TRIGGER`: 在表上创建触发器的权限。
    *   `CREATE`:
        *   对数据库：允许在数据库中创建新的 Schema。
        *   对 Schema：允许在 Schema 中创建新的对象（表、函数等）。
        *   对表空间：允许在表空间中创建数据库、表等。
    *   `CONNECT`: 连接到数据库的权限。
    *   `TEMPORARY` (或 `TEMP`): 创建临时表的权限。
    *   `EXECUTE`: 执行函数或存储过程的权限。
    *   `USAGE`:
        *   对 Schema：允许访问 Schema 内的对象（即使没有 `CREATE` 权限）。这是最基本的 Schema 权限。
        *   对序列 (Sequence)：允许使用 `currval()` 和 `nextval()`。
        *   对类型 (Type)、域 (Domain)、外部数据包装器 (Foreign Data Wrapper)、外部服务器 (Foreign Server)、语言 (Language)。
    *   `ALL PRIVILEGES`: 授予适用于该对象类型的所有权限。
*   **`object_type`**: 对象类型，如：
    *   `TABLE`, `SEQUENCE`, `DATABASE`, `FUNCTION`, `SCHEMA`, `LANGUAGE`, `TABLESPACE`, `FOREIGN DATA WRAPPER`, `FOREIGN SERVER`, `TYPE`, `DOMAIN`, `LARGE OBJECT`.
    *   `ALL TABLES IN SCHEMA schema_name`
    *   `ALL SEQUENCES IN SCHEMA schema_name`
    *   `ALL FUNCTIONS IN SCHEMA schema_name`
    *   `ALL ROUTINES IN SCHEMA schema_name` (包括函数和过程)
*   **`object_name`**: 具体的对象名称。
*   **`role_name`**: 要授予权限的角色。可以是单个角色，也可以是 `PUBLIC` (表示所有角色)。
*   **`WITH GRANT OPTION`**: 允许被授权的角色将它获得的这些权限再授予给其他角色。谨慎使用。

**示例：**
```sql
-- 授予 app_user 对 specific_table 的 SELECT, INSERT, UPDATE, DELETE 权限
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE specific_table TO app_user;

-- 授予 data_analyst 对所有在 public schema 下的表的 SELECT 权限
GRANT SELECT ON ALL TABLES IN SCHEMA public TO data_analyst;

-- 授予 readonly_group 对 myschema 中所有序列的 USAGE 权限
GRANT USAGE ON ALL SEQUENCES IN SCHEMA myschema TO readonly_group;

-- 授予 app_user 连接到 my_database 的权限
GRANT CONNECT ON DATABASE my_database TO app_user;

-- 授予 app_user 对 myschema 的 USAGE 权限 (这样它才能看到里面的对象)
GRANT USAGE ON SCHEMA myschema TO app_user;

-- 授予 app_user 在 myschema 中创建对象的权限
GRANT CREATE ON SCHEMA myschema TO app_user;

-- 授予 dev_role 执行 my_function 函数的权限
GRANT EXECUTE ON FUNCTION my_function(arg_type1, arg_type2) TO dev_role;
```

**重要：默认权限 (`ALTER DEFAULT PRIVILEGES`)**
当你希望某个角色（通常是对象创建者）未来创建的对象自动拥有某些权限时，这个功能非常有用。
```sql
-- app_creator 创建的表，自动授予 app_user SELECT 权限
ALTER DEFAULT PRIVILEGES FOR ROLE app_creator IN SCHEMA app_schema
   GRANT SELECT ON TABLES TO app_user_group;

-- 如果不指定 FOR ROLE，则表示当前用户
ALTER DEFAULT PRIVILEGES IN SCHEMA app_schema
   GRANT USAGE ON SEQUENCES TO app_user_group;
```
这对于自动化和简化权限管理至关重要，避免了每次创建新表后都要手动 `GRANT`。

---

### 4. 撤销授权 (Revoking Authorization - `REVOKE`)

与 `GRANT` 相反，用于移除权限。

**基本语法：**
`REVOKE [GRANT OPTION FOR] privilege [, ...] ON object_type object_name [, ...] FROM role_name [, ...] [CASCADE | RESTRICT];`

*   **`GRANT OPTION FOR`**: 只撤销 `WITH GRANT OPTION` 的能力，而不撤销权限本身。
*   **`CASCADE`**: 如果被撤销权限的角色又将此权限授予了其他角色，`CASCADE` 会一并撤销这些间接授予的权限。
*   **`RESTRICT`** (默认): 如果存在依赖于此权限的间接授权，`REVOKE` 命令会失败，除非指定 `CASCADE`。

**示例：**
```sql
-- 从 app_user 撤销对 specific_table 的 INSERT 权限
REVOKE INSERT ON TABLE specific_table FROM app_user;

-- 从 data_analyst 撤销对所有在 public schema 下的表的 SELECT 权限
REVOKE SELECT ON ALL TABLES IN SCHEMA public FROM data_analyst;

-- 撤销 app_user 连接到 my_database 的权限
REVOKE CONNECT ON DATABASE my_database FROM app_user;

-- 撤销 dev_role 执行 my_function 的权限
REVOKE EXECUTE ON FUNCTION my_function(arg_type1, arg_type2) FROM dev_role;
```

---

### 5. 角色成员 (Role Membership)

一个角色可以是另一个（或多个）“组”角色的成员。成员角色会继承其所属组角色的权限（除非组角色或成员角色设置了 `NOINHERIT`）。

**授予成员资格：**
`GRANT group_role TO member_role [, ...] [WITH ADMIN OPTION];`

*   **`group_role`**: “组”角色，其权限将被继承。
*   **`member_role`**: 要加入到组中的角色。
*   **`WITH ADMIN OPTION`**: 允许 `member_role` 将 `group_role` 的成员资格再授予给其他角色，或者从其他角色撤销 `group_role` 的成员资格。谨慎使用。

**示例：**
```sql
-- 创建一个登录用户和一个只读组
CREATE ROLE user_alice LOGIN PASSWORD 'alicepass';
CREATE ROLE readonly_permissions NOLOGIN;

-- 授予只读组对表的 SELECT 权限
GRANT SELECT ON TABLE sensitive_data TO readonly_permissions;
GRANT USAGE ON SCHEMA data_schema TO readonly_permissions;
GRANT SELECT ON ALL TABLES IN SCHEMA data_schema TO readonly_permissions;

-- 将 user_alice 加入 readonly_permissions 组
GRANT readonly_permissions TO user_alice;
-- 现在 user_alice 自动拥有了对 sensitive_data 表和 data_schema 中所有表的 SELECT 权限
```

**撤销成员资格：**
`REVOKE [ADMIN OPTION FOR] group_role FROM member_role [, ...] [CASCADE | RESTRICT];`

*   **`ADMIN OPTION FOR`**: 只撤销 `WITH ADMIN OPTION` 的能力。
*   `CASCADE` / `RESTRICT` 行为与对象权限撤销类似。

**示例：**
```sql
REVOKE readonly_permissions FROM user_alice;
```

**`SET ROLE` 和 `NOINHERIT`**:
如果一个角色 `A` 是角色 `B` 的成员，但 `A` 或 `B` 设置了 `NOINHERIT`，则 `A` 登录后不会自动拥有 `B` 的权限。`A` 需要执行 `SET ROLE B;` 来临时获取 `B` 的权限。使用 `RESET ROLE;` 或会话结束可恢复。这对于临时提升权限很有用。

---

### 6. 删除角色 (Deleting Roles)

使用 `DROP ROLE` 命令。

**基本语法：**
`DROP ROLE [IF EXISTS] role_name [, ...];`

**示例：**
```sql
DROP ROLE web_app_user;
DROP ROLE data_analyst;
```

**重要注意事项：**
*   **无法删除拥有对象的角色**：如果一个角色拥有任何数据库对象（如表、Schema、函数等），或者在其他对象上有权限，直接 `DROP ROLE` 会失败。
*   **处理方法**：
    1.  **转移对象所有权**：`REASSIGN OWNED BY old_role TO new_role;`
    2.  **撤销其授予的权限/删除其拥有的对象**：`DROP OWNED BY old_role;` (这会删除 `old_role` 拥有的所有对象，并撤销其授予的所有权限，非常危险，请小心使用！)
    3.  然后才能 `DROP ROLE old_role;`

---

### 扩展与应用 (Advanced & Practical Considerations)

1.  **预定义角色 (Predefined Roles - PostgreSQL 10/14+)**
    *   `pg_monitor`: 包含一系列监控服务器状态所需的权限，如读取统计视图。
    *   `pg_read_all_data` (PG 14+): 允许读取所有表、视图和 Schema 中的数据。
    *   `pg_write_all_data` (PG 14+): 允许写入所有表、视图和 Schema 中的数据。
    *   `pg_signal_backend`: 允许向其他后端进程发送信号 (如 `pg_cancel_backend`, `pg_terminate_backend`)。
    *   `pg_read_all_settings`: 允许读取所有配置变量，包括那些通常只对超级用户可见的。
    *   `pg_read_all_stats`: 允许读取所有 pg_stat_* 视图和使用各种统计相关的扩展。
    *   `pg_stat_scan_tables`: 允许执行可能触发 I/O 密集型扫描的监控函数。
    *   `pg_database_owner` (虚拟角色，不能直接授予): 代表当前数据库的所有者。
    使用这些预定义角色可以简化常见场景的权限配置，并遵循最小权限原则。

2.  **最小权限原则 (Principle of Least Privilege)**
    始终只授予角色完成其工作所必需的最小权限集。避免使用 `SUPERUSER` 进行日常操作或应用连接。

3.  **组角色管理权限，用户角色获取成员资格**
    这是最推荐的权限管理模型：
    *   创建代表特定职责或权限集的“组”角色（通常 `NOLOGIN`）。
    *   将对象权限授予这些“组”角色。
    *   创建“用户”角色（通常 `LOGIN`），并将它们添加为相应“组”角色的成员。
    这样，当需要调整权限时，只需修改“组”角色的权限；当员工变动时，只需将其“用户”角色从组中添加或移除。

4.  **行级安全 (Row Level Security - RLS)**
    对于更细粒度的访问控制（例如，用户只能看到或修改自己部门的数据），可以使用 RLS。角色和权限是 RLS 策略的基础。

5.  **审计权限**
    定期检查角色及其权限。可以使用系统目录视图：
    *   `pg_roles`: 查看所有角色及其属性。
    *   `pg_auth_members`: 查看角色成员关系。
    *   `information_schema.role_table_grants`, `information_schema.table_privileges`, `information_schema.usage_privileges` 等：查看对象权限。
    *   `psql` 中的命令：`\du` (列出角色), `\dp table_name` (列出表权限), `\dn+ schema_name` (列出 Schema 及其权限)。

6.  **密码管理**
    *   强制使用强密码策略。
    *   使用 `SCRAM-SHA-256` 加密。
    *   考虑使用外部认证系统 (LDAP, Kerberos, Ident, Certificate)。
    *   定期轮换密码，或使用 `VALID UNTIL`。

7.  **`public` Schema 和 `PUBLIC` 角色**
    *   默认情况下，数据库中的 `public` Schema 允许所有用户（即 `PUBLIC` 角色）创建对象。这通常是不希望的行为，因为任何用户都可能在 `public` Schema 下创建表，导致混乱。
    *   **最佳实践**：`REVOKE CREATE ON SCHEMA public FROM PUBLIC;` 移除 `PUBLIC` 角色在 `public` Schema 上的 `CREATE` 权限。然后为特定角色显式授予 `CREATE ON SCHEMA public` 或 `USAGE ON SCHEMA public`。
    *   `PUBLIC` 角色是一个特殊角色，代表所有已存在的和未来创建的角色。授予 `PUBLIC` 的权限对所有人有效。

---

总结一下，PostgreSQL 的角色和权限系统非常强大且灵活。理解其核心概念——角色是用户和组的统一体，以及如何通过 `GRANT` / `REVOKE` 和角色成员关系来精细控制访问，是管理和维护安全数据库环境的关键。始终以最小权限为原则，并善用 `ALTER DEFAULT PRIVILEGES` 和预定义角色来简化管理。



### 查看 PostgreSQL 用户的命令

在 PostgreSQL 中，你可以使用以下几种方法来查看用户(角色)信息：

#### 1. 使用 psql 命令行工具

```sql
-- 查看所有用户/角色
\du

-- 查看更详细的用户信息
\du+
```

#### 2. 使用 SQL 查询

```sql
-- 查看所有用户/角色基本信息
SELECT * FROM pg_user;

-- 查看更详细的角色信息
SELECT * FROM pg_roles;

-- 查看用户和他们的属性
SELECT usename AS username, usesuper AS is_superuser, usecreatedb AS can_create_db 
FROM pg_user;

-- 查看用户拥有的角色成员关系
SELECT * FROM pg_auth_members;
```

#### 3. 查看特定用户的权限

```sql
-- 查看某个特定用户的权限
\du username

-- 或者使用 SQL 查询
SELECT * FROM information_schema.role_table_grants 
WHERE grantee = 'username';
```

#### 注意事项

1. 在 PostgreSQL 中，"用户"和"角色"概念上是相同的，只是创建时语法略有不同
2. 你需要有足够的权限才能查看这些信息(通常是超级用户或有相应权限的角色)
3. 这些命令需要在 psql 命令行界面或通过其他 PostgreSQL 客户端工具执行