探讨 PostgreSQL 的核心运维主题：备份与恢复。这是确保数据安全和业务连续性的基石。

---

### 基本概念

1.  **备份 (Backup)**:
    *   创建一个数据库或整个数据库集群的数据副本的过程。
    *   目的是为了在发生数据丢失（如硬件故障、人为错误、软件缺陷、灾难事件）时，能够将数据恢复到某个已知的、一致的状态。

2.  **恢复 (Recovery)**:
    *   使用备份数据将数据库恢复到特定状态的过程。
    *   可以是恢复到最新的备份点，也可以是恢复到故障发生前的某个特定时间点 (Point-In-Time Recovery, PITR)。

3.  **关键术语与组件:**

    *   **WAL (Write-Ahead Logging / 日志先行)**:
        *   PostgreSQL 的核心可靠性机制。所有对数据文件的修改，都会首先以日志记录的形式写入 WAL 文件（也称为 XLOG 或事务日志文件）。
        *   这些日志记录描述了数据的变化，而不是变化后的整个数据页。
        *   确保即使在数据库崩溃时，通过重放 WAL 日志也能将数据库恢复到一个一致的状态 (Atomicity 和 Durability)。
        *   WAL 文件通常存储在数据目录下的 `pg_wal` (PG10+) 或 `pg_xlog` (PG9.6及更早版本) 子目录中。
        *   WAL 文件是以段 (segment) 的形式组织的，通常每个段 16MB。

    *   **Checkpoint (检查点)**:
        *   一个特殊的时间点，在该点之前的所有“脏”数据页（内存中已修改但尚未写入磁盘的数据页）都被确保已刷新到磁盘上的数据文件。
        *   Checkpoint 的目的是减少崩溃恢复所需的时间（需要重放的 WAL 日志量）。
        *   Checkpoint 由 `checkpoint_segments` / `max_wal_size` 和 `checkpoint_timeout` 等参数控制其频率。

    *   **基础备份 (Base Backup)**:
        *   一个数据库集群的物理文件副本（数据目录的完整拷贝）。
        *   它本身代表了备份开始那一刻数据库的一个（可能不完全一致的）快照。
        *   要使其成为一个可恢复的备份，必须配合从备份开始时点起的 WAL 日志。

    *   **归档 (Archiving) WAL 文件**:
        *   将已写满的 WAL 段文件从 `pg_wal` 目录复制到一个安全、独立的存储位置（如备份服务器、对象存储等）的过程。
        *   这是实现**时间点恢复 (PITR)** 的关键。没有归档的 WAL，你只能恢复到基础备份的时刻。
        *   通过 `archive_mode = on` 和 `archive_command` 配置。

    *   **时间点恢复 (Point-In-Time Recovery - PITR)**:
        *   能够将数据库恢复到过去任意一个特定时间点的能力（精确到事务级别）。
        *   需要一个基础备份和从该基础备份开始到目标恢复时间点的所有归档 WAL 文件。

    *   **恢复目标 (Recovery Target)**:
        *   在进行恢复时，可以指定恢复到哪个点。例如：
            *   最新的可用 WAL 日志 (恢复到最近状态)。
            *   特定的时间戳 (`recovery_target_time`)。
            *   特定的事务 ID (`recovery_target_xid`)。
            *   特定的命名恢复点 (`recovery_target_name`，通过 `pg_create_restore_point()` 创建)。
            *   特定的 LSN (`recovery_target_lsn`)。

    *   **RPO (Recovery Point Objective)**:
        *   可接受的最大数据丢失量。例如，RPO 为 15 分钟意味着系统在发生故障后，最多丢失 15 分钟的数据。
        *   PITR 和 WAL 归档频率直接影响 RPO。频繁归档 WAL 可以减少 RPO。

    *   **RTO (Recovery Time Objective)**:
        *   从系统故障到恢复服务所需的最长时间。
        *   RTO 受备份大小、恢复过程的复杂性、硬件性能等因素影响。

    *   **逻辑备份 (Logical Backup)**:
        *   导出数据库的 schema（表结构、函数等）和数据为 SQL 命令或文本文件（如 CSV）。
        *   例如 `pg_dump`, `pg_dumpall`。
        *   优点：平台无关（可以恢复到不同版本的 PG 或不同操作系统）、可以选择性备份/恢复特定对象、备份文件通常比物理备份小（对于稀疏数据）。
        *   缺点：恢复速度通常比物理备份慢（需要重新执行 SQL 和重建索引）、对于非常大的数据库可能非常耗时。

    *   **物理备份 (Physical Backup)**:
        *   直接复制数据库集群的数据文件。
        *   例如 `pg_basebackup`、文件系统级备份（如 LVM 快照、ZFS 快照）、第三方备份工具。
        *   优点：恢复速度快（特别是对于大数据库）、可以实现 PITR。
        *   缺点：通常只能恢复到相同或兼容的 PostgreSQL 版本和操作系统架构、备份文件较大。

---

### 备份 (Backup Strategies & Tools)

#### 1. 逻辑备份

*   **`pg_dump`**:
    *   用于备份**单个数据库**。
    *   输出格式：
        *   **纯文本 SQL 脚本 (`.sql`)**: 包含 `CREATE TABLE`, `INSERT` 等语句。易读，但恢复慢，并行恢复困难。
            ```bash
            pg_dump mydatabase > mydatabase_backup.sql
            ```
        *   **自定义格式 (`.dump`, `-Fc`)**: 压缩的二进制格式。推荐用于大型数据库。支持并行恢复 (`pg_restore -j N`)，可以选择性恢复对象。
            ```bash
            pg_dump -Fc -f mydatabase_backup.dump mydatabase
            ```
        *   **目录格式 (`-Fd`)**: 将备份输出到一个目录，每个表一个文件，有 `toc.dat` 文件。支持并行转储和恢复。适合非常大的数据库。
            ```bash
            pg_dump -Fd -f mydatabase_backup_dir mydatabase -j 4 # 使用4个并行作业
            ```
        *   **tar 格式 (`-Ft`)**: 不常用。
    *   常用选项：
        *   `-U username`: 指定用户名。
        *   `-W`: 提示输入密码。
        *   `-h host -p port`: 指定主机和端口。
        *   `--schema=schema_name`: 只备份特定模式。
        *   `--table=table_name`: 只备份特定表（及其依赖）。
        *   `--data-only`: 只备份数据，不备份 schema。
        *   `--schema-only`: 只备份 schema，不备份数据。
        *   `--blobs`: 包含大对象。
        *   `--jobs=N` (`-j N`): 并行转储（只对目录格式有效）。

*   **`pg_dumpall`**:
    *   用于备份**整个 PostgreSQL 集群**，包括所有数据库、全局对象（角色、表空间定义）。
    *   输出格式只能是纯文本 SQL 脚本。
    *   它实际上是为每个数据库调用 `pg_dump`，并转储全局对象。
    *   ```bash
        pg_dumpall > cluster_backup.sql
        ```
    *   选项：
        *   `--globals-only`: 只备份全局对象。
        *   `--roles-only`: 只备份角色。
        *   `--tablespaces-only`: 只备份表空间定义。

#### 2. 物理备份

实现 PITR 的基础。通常包括一个基础备份和持续的 WAL 归档。

*   **配置 WAL 归档**:
    在 `postgresql.conf` 中设置：
    ```ini
    wal_level = replica  # 或 logical，'replica' 是 PITR 的最低要求
    archive_mode = on
    archive_command = 'cp %p /path_to_archive_directory/%f' # 示例：复制到本地目录
    # 或使用 rsync, scp, 或专门的备份工具命令，如 pgBackRest, Barman, WAL-G
    # %p: WAL 文件的完整路径
    # %f: WAL 文件名
    ```
    **重要**: `archive_command` 必须在成功归档后返回 `0`，否则 PostgreSQL 会认为归档失败并不断重试。
    配置更改后需要重启 PostgreSQL 服务。

*   **创建基础备份 (`pg_basebackup`)**:
    *   PostgreSQL 内建的工具，用于创建在线的（数据库运行时）物理基础备份。
    *   它会复制数据目录的内容，并确保包含恢复所需的所有 WAL 文件（直到备份结束）。
    *   ```bash
        # 以普通文件格式输出到指定目录
        pg_basebackup -h localhost -U replicator_user -D /path_to_backup_directory -Ft -P -Xs -R
        # -D /path/to/backup_directory: 备份存储目录
        # -Ft: tar 格式 (默认是 plain)
        # -P: 显示进度
        # -Xs: --wal-method=stream，在备份期间流式传输 WAL 文件，确保备份结束时所有必要的 WAL 都在备份中。
        # -R: 在备份目录中创建 recovery.conf (PG11及更早) 或 postgresql.auto.conf + standby.signal (PG12+) 文件，简化恢复配置。
        ```
    *   常用选项：
        *   `-D directory`: 备份目标目录。
        *   `-Ft` (tar) 或 `-Fp` (plain，默认): 输出格式。Tar 格式通常更方便管理。
        *   `--wal-method=none|fetch|stream` (`-X none|fetch|stream`):
            *   `none`: 不包含 WAL 文件（不推荐用于独立备份）。
            *   `fetch`: 在备份结束时从服务器获取所需的 WAL 文件。
            *   `stream`: 在备份过程中通过复制连接流式传输 WAL 文件（推荐）。需要额外的 `pg_receivewal` 进程或 `max_wal_senders` 配置。
        *   `-P` / `--progress`: 显示进度。
        *   `-R`: 自动生成恢复配置文件。
        *   `-z`: 启用 gzip 压缩 (tar 格式)。
        *   `-c fast|spread`: 设置检查点模式。`fast` (默认) 尽快完成，`spread` 尽量减少对主库的 I/O 影响。
        *   `--label=backup_label`: 为备份设置一个标签。

*   **文件系统级备份 (Cold Backup / Snapshot)**:
    *   **冷备份**: 关闭数据库，然后复制整个数据目录。简单但有停机时间。
    *   **快照备份**:
        1.  执行 `SELECT pg_backup_start('mylabel', true);` (对于非独占备份，PG9.6+)。旧版本是 `pg_start_backup()`。
        2.  使用文件系统工具 (如 LVM snapshot, ZFS snapshot, SAN snapshot) 创建数据目录的快照。
        3.  执行 `SELECT pg_backup_stop(false);` (PG9.6+)。旧版本是 `pg_stop_backup()`。此命令会返回一个包含所需 WAL 信息的备份历史文件。
        4.  备份快照数据和从 `pg_backup_start` 到 `pg_backup_stop` 期间以及之后的所有 WAL 文件。
        *   优点：备份速度快，对主库性能影响小。
        *   缺点：配置和管理相对复杂。

#### 3. 专用备份工具 (强烈推荐)

这些工具通常集成了基础备份、WAL 归档、备份管理、恢复流程、并行处理、压缩、加密、增量/差异备份等高级功能。

*   **pgBackRest**:
    *   非常流行和功能强大的开源备份恢复工具。
    *   特点：并行备份恢复、压缩、加密、完整/增量/差异备份、备份轮换、S3/Azure/GCS 存储支持、简化的 PITR。
    *   需要单独安装和配置。
*   **Barman (Backup and Recovery Manager)**:
    *   另一个流行的开源工具，由 2ndQuadrant (现在是 EDB 的一部分) 开发。
    *   特点：远程备份管理、WAL 归档、PITR、压缩、集成 `pg_basebackup`。
*   **WAL-G / WAL-E**:
    *   用于将 WAL 文件持续归档到云存储 (S3, GCS, Azure Blob, Swift 等)。WAL-G 是 WAL-E 的后继者，用 Go 编写，性能更好，功能更全。
    *   常与 `pg_basebackup` 或其他基础备份方法结合使用。

---

### 恢复 (Recovery Strategies & Tools)

#### 1. 从逻辑备份恢复

*   **`psql` (用于 `.sql` 文件)**:
    ```bash
    # 恢复整个数据库 (如果数据库已存在且为空，或者先 DROP/CREATE)
    psql -U username -d mydatabase -f mydatabase_backup.sql
    
    # 如果备份包含 CREATE DATABASE 语句 (pg_dumpall 通常包含)
    psql -U postgres -f cluster_backup.sql
    ```
*   **`pg_restore` (用于 `pg_dump -Fc`, `-Fd`, `-Ft` 格式)**:
    *   功能更强大，支持并行恢复、选择性恢复对象、在恢复前创建数据库等。
    *   ```bash
        # 先创建空数据库
        createdb -U username mydatabase
        
        # 从自定义格式恢复
        pg_restore -U username -d mydatabase mydatabase_backup.dump
        
        # 使用4个并行作业恢复 (通常恢复索引构建可以并行)
        pg_restore -U username -d mydatabase -j 4 mydatabase_backup.dump
        
        # 列出备份内容
        pg_restore -l mydatabase_backup.dump
        
        # 只恢复特定表
        pg_restore -U username -d mydatabase --table=my_table mydatabase_backup.dump
        ```

#### 2. 从物理备份恢复 (PITR)

基本步骤：

1.  **准备环境**:
    *   确保 PostgreSQL 服务器已停止。
    *   准备一个新的、空的数据目录 (或者清理旧的数据目录，**务必小心，确保你真的要覆盖它！**)。
    *   确保新环境的 PostgreSQL 版本与备份时的版本兼容（通常是相同主版本）。

2.  **恢复基础备份**:
    *   将基础备份文件（来自 `pg_basebackup` 或文件系统快照）解压/复制到新的数据目录。

3.  **配置恢复参数**:
    *   **PG11 及更早版本**: 在数据目录中创建 `recovery.conf` 文件。
    *   **PG12 及更高版本**: 这些设置现在是 `postgresql.conf` 的一部分。如果需要进行恢复，通常会在数据目录中创建一个空的 `recovery.signal` 文件来指示服务器在启动时进入恢复模式。如果基础备份时使用了 `-R` 选项，`pg_basebackup` 会自动生成 `standby.signal` (用于备库) 或相关的配置到 `postgresql.auto.conf`。
    *   关键恢复参数 (`recovery.conf` 或 `postgresql.conf`):
        *   **`restore_command`**: **必需**。告诉 PostgreSQL 如何从归档位置获取所需的 WAL 文件。
            ```
            # 示例: 从本地目录恢复
            restore_command = 'cp /path_to_archive_directory/%f "%p"'
            # 或使用 pgBackRest, Barman, WAL-G 的恢复命令
            # %f: 需要的 WAL 文件名
            # %p: 目标路径 (PostgreSQL 会替换)
            ```
        *   **`recovery_target_time 'timestamp'`**: 恢复到指定时间点。
        *   **`recovery_target_xid 'transaction_id'`**: 恢复到指定事务ID之后。
        *   **`recovery_target_name 'restore_point_name'`**: 恢复到 `pg_create_restore_point()` 创建的命名恢复点。
        *   **`recovery_target_lsn 'lsn_value'`**: 恢复到指定的 LSN。
        *   **`recovery_target_inclusive = boolean`**: 指定恢复目标是否包含该点 (true) 或在该点之前停止 (false, 默认)。
        *   **`recovery_target_action = 'pause' | 'promote' | 'shutdown'`** (PG9.5+): 达到恢复目标后执行的操作。
            *   `pause` (默认): 暂停恢复，允许连接进行只读查询，可手动执行 `pg_wal_replay_resume()` 继续或 `pg_promote()` 提升。
            *   `promote`: 自动提升为可写主库。
            *   `shutdown`: 关闭服务器。
        *   **`recovery_end_command`**: 达到恢复末尾时执行的命令（例如清理归档目录中的临时文件）。
        *   **`archive_cleanup_command`**: (用于备库) 清理不再需要的旧归档 WAL 文件。

    *   **PG12+ 恢复信号文件**:
        *   `recovery.signal`: 如果存在，服务器启动时进入恢复模式，并应用 WAL 直到末尾，然后转为正常操作（删除 `recovery.signal`）。
        *   `standby.signal`: 如果存在，服务器启动时进入备库模式，持续从主库或归档接收并应用 WAL。

4.  **启动 PostgreSQL 服务器**:
    *   PostgreSQL 会读取恢复配置，进入恢复模式，开始从归档位置获取并重放 WAL 日志。
    *   监控 PostgreSQL 日志文件查看恢复进度和任何错误。

5.  **完成恢复**:
    *   一旦达到恢复目标（或所有可用 WAL 都已应用），如果 `recovery_target_action` 是 `promote` 或手动执行 `SELECT pg_promote();` (PG12+) 或 `pg_ctl promote`，数据库将结束恢复模式，成为一个可读写的主库。
    *   旧的 `recovery.conf` 会被重命名为 `recovery.done` (PG11及更早)。`recovery.signal` 会被删除 (PG12+)。

**使用专用备份工具恢复**:
pgBackRest, Barman 等工具通常有自己的 `restore` 命令，它们会为你处理大部分复杂的步骤，包括准备数据目录、配置恢复参数、获取 WAL 文件等。
例如，使用 pgBackRest:
```bash
pgbackrest --stanza=my_stanza restore --delta # --delta 用于增量恢复
# 或恢复到特定时间点
pgbackrest --stanza=my_stanza restore --type=time --target="YYYY-MM-DD HH:MM:SS"
```

---

### 备份与恢复的最佳实践

1.  **定期备份**: 根据 RPO 制定备份计划 (每日、每小时等)。
2.  **异地备份**: 将备份（尤其是 WAL 归档）存储在与主数据库物理位置不同的地方，以防区域性灾难。
3.  **定期测试恢复**: **这是最重要的一点！** 备份如果不能成功恢复，就等于没有备份。定期演练恢复过程，确保备份有效且团队熟悉流程。
4.  **监控备份和归档**: 确保备份作业和 WAL 归档成功完成。设置告警。
5.  **验证备份完整性**: 一些备份工具提供验证功能。
6.  **使用专用备份工具**: 它们能显著简化管理，减少人为错误，并提供高级功能。
7.  **理解 RPO 和 RTO**: 并确保备份策略能满足业务需求。
8.  **安全存储备份**: 备份数据可能包含敏感信息，需要适当加密和访问控制。
9.  **记录备份和恢复程序**: 保持文档更新。
10. **不要忘记全局对象**: 如果使用 `pg_dump`，考虑定期运行 `pg_dumpall --globals-only` 来备份角色和表空间定义。物理备份通常包含这些。
11. **为 WAL 归档分配足够的空间和带宽**: 归档失败会导致主库 WAL 目录堆积，最终可能导致数据库停止写入。
12. **使用流复制和备库 (Standby Servers)**:
    *   虽然不是严格意义上的“备份”，但流复制创建的备库（热备或温备）可以用于高可用 (HA) 和灾难恢复 (DR)。
    *   备库可以快速提升为主库，大大减少 RTO。
    *   备库仍然需要独立的备份策略，以防止逻辑错误（如意外 `DROP TABLE`）被复制。

---

备份与恢复是 PostgreSQL 管理中非常复杂但至关重要的部分。强烈建议投入时间学习和实践，并优先考虑使用成熟的专用备份工具。
