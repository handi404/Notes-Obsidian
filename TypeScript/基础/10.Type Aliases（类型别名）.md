TypeScript 中的 **Type Aliases（类型别名）** 以及它和 **Interfaces（接口）** 的主要区别。这两者很多时候可以互换使用，但它们确实存在关键的不同点。

### Type Aliases (类型别名)

**是什么？**

类型别名，顾名思义，就是给一个**类型**起一个新的、更方便的名字。这个“类型”可以是任何 TypeScript 类型：

*   **原始类型**: `string`, `number`, `boolean`, `symbol`, `null`, `undefined`, `bigint`
*   **联合类型 (Union Types)**: `string | number`
*   **交叉类型 (Intersection Types)**: `TypeA & TypeB`
*   **元组 (Tuple Types)**: `[string, number]`
*   **函数类型**: `(arg: string) => number`
*   **对象字面量类型**: `{ name: string; age: number; }`
*   **泛型类型**: `Array<string>`
*   **甚至是其他的类型别名或接口**

**语法：**

```typescript
type NewTypeName = ExistingType;
```

**主要用途：**

1.  **提高可读性**: 给复杂的类型一个简单的名字。
2.  **代码复用**: 避免重复书写相同的类型结构。
3.  **定义非对象类型**: 这是类型别名独有的能力，比如给联合类型、元组等起别名。

**示例：**

```typescript
// 1. 给原始类型起别名 (虽然不常用，但可以)
type UserID = string;

// 2. 给联合类型起别名 (非常常用)
type StringOrNumber = string | number;
let value: StringOrNumber = "hello";
value = 123;

// 3. 给对象字面量类型起别名
type Point = {
  x: number;
  y: number;
};
let p: Point = { x: 10, y: 20 };

// 4. 给函数类型起别名
type GreetFunction = (name: string) => void;
const greet: GreetFunction = (name) => console.log(`Hello, ${name}`);

// 5. 给元组起别名
type NameAgePair = [string, number];
let person: NameAgePair = ["Alice", 30];

// 6. 结合泛型
type StringArray = Array<string>;
type Maybe<T> = T | null | undefined;
```

### Interfaces (接口)

**是什么？**

接口主要用于定义**对象的结构（Shape）**或者**类的契约（Contract）**。它描述了一个对象应该有哪些属性和方法，以及它们的类型。

**语法：**

```typescript
interface InterfaceName {
  propertyName: Type;
  methodName(arg: ArgType): ReturnType;
  readonly readOnlyProp?: OptionalType; // 可选和只读修饰符
}
```

**主要用途：**

1.  **定义对象的“形状”**: 强制对象符合特定的结构。
2.  **定义类的契约**: 使用 `implements` 关键字强制类实现接口定义的所有成员。
3.  **利用声明合并 (Declaration Merging)**: 可以多次声明同名接口，TypeScript 会将它们合并。

**示例：**

```typescript
// 1. 定义对象形状
interface User {
  id: number;
  name: string;
  isActive?: boolean; // 可选属性
  readonly registrationDate: Date; // 只读属性
  getInfo(): string; // 方法
}

let user: User = {
  id: 1,
  name: "Bob",
  registrationDate: new Date(),
  getInfo() {
    return `ID: ${this.id}, Name: ${this.name}`;
  },
};

// 2. 定义类的契约
interface ClockInterface {
  currentTime: Date;
  setTime(d: Date): void;
}

class Clock implements ClockInterface {
  currentTime: Date = new Date();
  setTime(d: Date) {
    this.currentTime = d;
  }
}

// 3. 声明合并 (Declaration Merging)
interface Box {
  height: number;
  width: number;
}

interface Box { // 同名接口会被合并
  scale: number;
}

let box: Box = { height: 5, width: 6, scale: 10 };
```

### Type Aliases vs. Interfaces 的关键区别

| 特性                 | Type Alias (`type`)                         | Interface (`interface`)                      | 说明                                                                 |
| :------------------- | :------------------------------------------ | :------------------------------------------- | :------------------------------------------------------------------- |
| **定义范围**         | **任何类型** (原始、联合、交叉、元组、函数、对象等) | **主要用于对象/类的结构**                      | `type` 更通用，`interface` 更专注于描述“形状”。                        |
| **声明合并**         | **不可以** (同名 `type` 会报错)             | **可以** (自动合并)                           | 这是 `interface` 的独特优势，常用于扩展第三方库的接口。                 |
| **扩展/继承**        | 使用 **交叉类型 `&`** 实现组合/扩展         | 使用 **`extends`** 关键字实现继承            | 两者都能实现扩展，但语法和语义略有不同。`interface` 的 `extends` 更符合传统 OOP 概念。 |
| **实现 (`implements`)** | 类可以 `implements` **对象形状的 `type`**   | 类**通常 `implements` 接口**                | `interface` 是 `implements` 的标准用法，虽然 `type` 定义的对象类型也可以被 `implements`，但 `type` 定义的联合类型等不能被 `implements`。 |
| **可读性/惯用法**   | `type` 更适合定义**非对象类型**和**复杂组合** | `interface` 更适合定义**对象蓝图**和**类契约** | 社区对此有不同偏好，但这是常见的区分方式。                             |
| **错误提示**         | 复杂 `type` 的错误有时可能不如 `interface` 直观 | 错误提示通常更直接指向 `interface` 本身       | 这点比较主观，且随 TS 版本演进可能变化，但历史上 `interface` 的错误提示有时更友好。 |

**扩展/组合示例对比：**

```typescript
// 使用 interface extends
interface Animal {
  name: string;
}
interface Bear extends Animal {
  honey: boolean;
}
const bear: Bear = { name: 'Winnie', honey: true };

// 使用 type & (交叉类型)
type Person = {
  name: string;
};
type Employee = Person & { // 组合 Person 和 匿名对象类型
  employeeId: number;
};
const employee: Employee = { name: 'Alice', employeeId: 123 };

// type 也可以 "扩展" interface
type NamedBox = Box & { name: string }; // 组合上面定义的 Box 接口和匿名类型
```

### 总结与建议

1.  **优先使用哪个？**
    *   如果你需要定义**对象/类的形状**，并且可能需要利用**声明合并** (比如扩展外部库的类型)，或者希望明确表达“这是一个契约”，使用 `interface`。
    *   如果你需要给**联合类型、元组、函数类型**或者复杂的**交叉/映射类型**等起别名，必须使用 `type`。
    *   对于简单的对象形状，`type` 和 `interface` 大多时候可以互换。现代 TypeScript 开发中，很多人倾向于 **默认使用 `type`**，因为它更通用，只有在明确需要 `interface` 的特性（如声明合并）时才使用 `interface`。但遵循团队规范更重要。

2.  **关键区别牢记：**
    *   `interface` 可以声明合并，`type` 不行。
    *   `type` 可以定义任何类型，`interface` 主要用于对象结构。

选择哪个更多是风格和具体需求的问题，两者都是 TypeScript 类型系统中强大且常用的工具。理解它们的差异能帮助你写出更清晰、更健壮的代码。