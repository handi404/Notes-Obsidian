深入了解 TypeScript 的核心——**类型基础 (Type Basics)**。这部分是理解和使用 TypeScript 的基石。

简单来说，**类型**就是给变量、函数参数、函数返回值等“贴标签”，规定它们可以存储什么样的数据。

#### **1. 核心原始类型 (Core Primitive Types)**

这些是 JavaScript 中最基础的数据类型，TypeScript 完全支持，并提供了静态类型检查：

*   **`string`**: 表示文本数据（字符串）。
    ```typescript
    let message: string = "Hello, TypeScript!";
    // message = 123; // 错误！不能将 number 类型赋值给 string 类型
    ```
*   **`number`**: 表示所有数字，包括整数和浮点数。
    ```typescript
    let count: number = 42;
    let price: number = 99.99;
    // count = "forty-two"; // 错误！
    ```
*   **`boolean`**: 表示逻辑值，只有 `true` 和 `false`。
    ```typescript
    let isActive: boolean = true;
    // isActive = 0; // 错误！(除非你的 tsconfig 配置允许)
    ```
*   **`null`**: 表示有意设置的空值。
    ```typescript
    let data: null = null;
    // 通常与 | (联合类型) 一起使用，比如 string | null
    ```
*   **`undefined`**: 表示变量已声明但未初始化（或函数没有返回值）。
    ```typescript
    let notAssigned: undefined;
    // console.log(notAssigned); // 输出 undefined
    ```
    **注意:** 在默认配置 (`strictNullChecks: true`) 下，`null` 和 `undefined` 是它们各自独立的类型，不能随意赋值给其他类型（如 `string` 或 `number`），除非你显式地使用联合类型（见下文）。这是推荐的配置，能避免很多错误。

*   **`bigint`**: 表示大于 `Number.MAX_SAFE_INTEGER` (2^53 - 1) 的整数。用数字字面量加 `n` 后缀表示。
    ```typescript
    let largeNumber: bigint = 9007199254740991n;
    // let smallNum: number = largeNumber; // 错误！类型不兼容
    ```
*   **`symbol`**: 表示全局唯一的引用值，通常用作对象属性的键。
    ```typescript
    let sym1: symbol = Symbol("key");
    let sym2 = Symbol("key"); // sym1 !== sym2
    ```

#### **2. 对象类型 (Object Types)**

用于描述对象的结构（包含哪些属性，属性是什么类型）：

*   **内联类型 (Inline Type):** 直接在变量注解中定义形状。
    ```typescript
    let person: { name: string; age: number; isActive?: boolean }; // isActive 是可选属性
    person = { name: "Alice", age: 30 };
    person = { name: "Bob", age: 25, isActive: true };
    // person = { name: "Charlie" }; // 错误！缺少 age 属性
    // person = { name: "David", age: 40, location: "City" }; // 错误！有多余的 location 属性
    ```
*   **接口 (Interface) / 类型别名 (Type Alias):** 更常用、可复用的方式来定义对象类型（我们稍后会详细对比）。
    ```typescript
    // 使用 interface
    interface Point {
      x: number;
      y: number;
    }
    let p1: Point = { x: 10, y: 20 };

    // 使用 type alias
    type User = {
      id: string | number;
      username: string;
    };
    let u1: User = { id: "user-123", username: "dave" };
    ```

#### **3. 数组类型 (Array Types)**

有两种常用语法定义数组，它们是等价的：

*   **`Type[]`**: 元素类型后面跟 `[]`。
    ```typescript
    let numbers: number[] = [1, 2, 3, 4];
    let names: string[] = ["Alice", "Bob"];
    // numbers.push("5"); // 错误！不能将 string push 到 number[]
    ```
*   **`Array<Type>`**: 使用泛型（Generic）语法。
    ```typescript
    let flags: Array<boolean> = [true, false, true];
    ```

#### **4. 函数类型 (Function Types)**

用来描述函数的参数类型和返回值类型：

```typescript
// 完整的函数类型注解
function add(a: number, b: number): number {
  return a + b;
}

// 也可以只注解参数，TS 通常能推断出返回值类型
function multiply(a: number, b: number) { // 返回值类型被推断为 number
  return a * b;
}

// 使用箭头函数语法
const subtract = (a: number, b: number): number => {
  return a - b;
};

// 定义一个函数类型的变量（类型别名常用）
type MathOperation = (x: number, y: number) => number;

let divide: MathOperation = (x, y) => {
  if (y === 0) throw new Error("Division by zero");
  return x / y;
};
```

#### **5. 特殊的 TypeScript 类型**

*   **`any`**: **“放弃类型检查”** 的信号。任何类型的值都可以赋给 `any` 类型的变量，也可以对 `any` 类型的变量进行任何操作（访问属性、调用方法等），编译器完全不检查。
    *   **用途:** 在迁移旧 JS 代码或处理不确定类型的第三方库时可能临时用到。
    *   **警告:** **应极力避免使用 `any`**，因为它会破坏 TypeScript 的类型安全优势。
    ```typescript
    let anything: any = "hello";
    anything = 123; // OK
    anything = { key: "value" }; // OK
    console.log(anything.nonExistentProperty); // 编译时 OK，运行时可能出错！
    anything(); // 编译时 OK，运行时可能出错！
    ```
*   **`unknown`**: **“类型安全的 `any`”**。和 `any` 一样，任何类型的值都可以赋给 `unknown` 类型的变量。但关键区别在于：**你不能对 `unknown` 类型的变量做任何明确的操作（如访问属性、调用方法），除非你先进行了类型检查或类型断言来缩小范围 (Type Narrowing)。**
    *   **推荐:** 当你确实不知道一个值的类型时，**优先使用 `unknown` 而不是 `any`**。
    ```typescript
    let maybe: unknown = "hello";
    // maybe.toUpperCase(); // 错误！'maybe' is of type 'unknown'.

    if (typeof maybe === "string") {
      // 在这个代码块内，TS 知道 maybe 是 string 类型
      console.log(maybe.toUpperCase()); // OK
    }

    let num: unknown = 10;
    if (typeof num === "number") {
      console.log(num.toFixed(2)); // OK
    }
    ```
*   **`void`**: 通常用作**函数返回值类型**，表示该函数**不返回任何有意义的值**（即使它可能隐式返回 `undefined`）。
    ```typescript
    function logMessage(message: string): void {
      console.log(message);
      // 没有 return 语句，或者 return;
    }
    ```
*   **`never`**: 表示**永远不会达到的终点**。通常是以下两种情况的函数的返回值类型：
    1.  总是抛出错误的函数。
    2.  包含无限循环（且理论上无法跳出）的函数。
    ```typescript
    function fail(message: string): never {
      throw new Error(message);
    }

    function infiniteLoop(): never {
      while (true) {
        // ...
      }
    }
    ```
    `never` 类型的主要用途是在类型系统中进行详尽性检查（Exhaustiveness Checking）。

#### **6. 类型推断 (Type Inference)**

如果**没有**显式地写类型注解，TypeScript 会尝试根据初始赋值或函数返回值等上下文**自动推断**出类型。

```typescript
let name = "Alice"; // TS 推断 name 是 string 类型
let age = 30;     // TS 推断 age 是 number 类型

// TS 推断 add 函数返回 number 类型
function add(a: number, b: number) {
  return a + b;
}
const result = add(1, 2); // TS 推断 result 是 number 类型
```
类型推断很方便，但在某些情况下（如函数返回值、复杂对象、需要明确契约时），显式注解仍然是更好的选择，可以提高代码清晰度和防止意外的类型变化。

#### **7. 联合类型 (Union Types)**

使用 `|` 操作符，表示一个值可以是**多种类型中的一种**。

```typescript
let id: string | number;
id = 101;    // OK
id = "user-abc"; // OK
// id = false; // 错误！ boolean 类型不在 string | number 联合中

function printId(inputId: string | number) {
  // 在使用联合类型的值时，通常需要进行类型检查
  if (typeof inputId === "string") {
    console.log(inputId.toUpperCase());
  } else {
    console.log(inputId);
  }
}
```
- **注意**：当访问联合类型的属性或方法时，只能访问所有联合成员都共有的属性或方法，除非使用类型守卫缩小范围。

#### **8. 交叉类型 (Intersection Types)**

- **描述**：使用 & (和号) 分隔的多种类型，表示一个值必须同时满足所有这些类型的特征。它将多个类型合并为一个类型，这个新类型拥有所有组成类型的所有成员。
    
- **示例**：
```ts
interface Loggable {
  log(message: string): void;
}
interface Serializable {
  serialize(): string;
}

type LoggableAndSerializable = Loggable & Serializable;

class DataItem implements LoggableAndSerializable {
  constructor(private data: any) {}

  log(message: string): void {
    console.log(`[LOG] ${message}: ${this.data}`);
  }
  serialize(): string {
    return JSON.stringify(this.data);
  }
}

const item = new DataItem({ value: 42 });
item.log("Processing item");
console.log(item.serialize());
```
- **对于对象类型**：交叉类型会合并对象的属性。
- **对于原始类型**：如果交叉的原始类型不兼容（例如 string & number），结果会是 never 类型，因为没有任何值能同时是字符串和数字。

#### **9. 字面量类型 (Literal Types)**
- **描述**：允许你将变量限制为特定的字符串、数字或布尔值。通常与联合类型一起使用，来创建一组允许的特定值。
- **示例 (字符串字面量)**：
```ts
type Alignment = "left" | "right" | "center";
let textAlign: Alignment;
textAlign = "left";   // OK
textAlign = "center"; // OK
// textAlign = "middle"; // Error: Type '"middle"' is not assignable to type 'Alignment'.
```
- **示例 (数字字面量)**：
```ts
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;
let roll: DiceRoll = 3; // OK
// let invalidRoll: DiceRoll = 7; // Error
```
- **示例 (布尔字面量)**：
```ts
interface Config {
  debugMode: true; // debugMode 必须是 true
  port: number;
}
// const conf: Config = { debugMode: false, port: 80 }; // Error
const conf: Config = { debugMode: true, port: 80 }; // OK
```
- **应用**：常用于状态管理、配置选项、区分联合类型中的对象 (可辨识联合类型)。
#### **总结:**

TypeScript 的类型基础提供了描述各种数据结构和函数签名的能力。掌握这些基本类型是利用 TypeScript 提高代码质量和开发效率的第一步。核心在于理解每种类型代表什么，以及如何使用 `any`、`unknown`、`void`、`never` 这些特殊类型，并善用类型推断和联合类型。


---

