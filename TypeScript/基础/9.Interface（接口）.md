为我们定义自己的自定义类型开辟了一种方式，那就是接口。简而言之，接口是一种定义特定结构的方式，所有数据结构都可以遵循这种结构，无论是类对象文字还是其他接口。

---

探讨 TypeScript 中的 **接口 (Interface)**。接口是 TypeScript 核心概念之一，主要用于**定义对象的“形状”或“契约”**。

可以把接口想象成一个**蓝图**或**合同**：它规定了一个对象**应该**有哪些属性，这些属性的类型是什么；或者一个函数/类**应该**满足什么样的结构。

**核心目的：**

*   **描述对象的结构:** 定义对象需要包含哪些成员（属性和方法）以及它们的类型。
*   **强制执行契约:** 确保变量、函数参数、类实例等符合预期的结构。
*   **提高代码可读性和可维护性:** 清晰地表明数据应该是什么样子。
*   **促进协作:** 在团队中作为共享数据结构的约定。

**重要特性：接口只在编译时存在，用于类型检查。它不会被编译到最终的 JavaScript 代码中。**

---

**1. 定义对象形状 (Object Shapes)**

这是接口最常见的用途。

*   **基本语法:**
    ```typescript
    // 定义一个名为 'Point' 的接口
    interface Point {
      x: number; // 必须有 x 属性，类型为 number
      y: number; // 必须有 y 属性，类型为 number
    }

    // 使用接口作为类型注解
    function logPoint(p: Point) {
      console.log(`Coordinates: (${p.x}, ${p.y})`);
    }

    const myPoint: Point = { x: 10, y: 20 }; // OK, 符合 Point 接口
    logPoint(myPoint);

    // const invalidPoint = { x: 5 }; // 错误: Property 'y' is missing in type '{ x: number; }' but required in type 'Point'.
    // const wrongTypePoint = { x: "10", y: 20 }; // 错误: Type 'string' is not assignable to type 'number'.
    // const extraPropPoint = { x: 1, y: 2, z: 3 }; // 错误 (对于对象字面量): Object literal may only specify known properties, and 'z' does not exist in type 'Point'.
                                               // 注意：如果将一个已有对象赋值给 Point 类型变量，多余的属性会被允许（鸭子类型）
                                               // let existingObj = { x: 1, y: 2, z: 3 };
                                               // let p2: Point = existingObj; // OK
    ```

*   **可选属性 (Optional Properties):** 使用 `?` 标记属性为可选。
    ```typescript
    interface UserProfile {
      id: number;
      username: string;
      email?: string; // email 是可选的
      bio?: string;   // bio 也是可选的
    }

    let user1: UserProfile = { id: 1, username: "Alice" }; // OK, 省略了 email 和 bio
    let user2: UserProfile = { id: 2, username: "Bob", email: "bob@example.com" }; // OK

    function displayEmail(profile: UserProfile) {
      // 访问可选属性时，需要处理 undefined 的情况
      console.log(profile.email?.toUpperCase() ?? "No email provided");
    }
    displayEmail(user1); // 输出: No email provided
    displayEmail(user2); // 输出: BOB@EXAMPLE.COM
    ```

*   **只读属性 (Readonly Properties):** 使用 `readonly` 关键字标记属性，表示该属性在对象创建后不能被修改。
    ```typescript
    interface AppConfig {
      readonly apiKey: string; // apiKey 创建后不可修改
      readonly environment: "development" | "production" | "test";
      timeout: number; // timeout 是可写的
    }

    const config: AppConfig = {
      apiKey: "xyz123abc",
      environment: "production",
      timeout: 5000
    };

    // config.apiKey = "newkey"; // 错误: Cannot assign to 'apiKey' because it is a read-only property.
    config.timeout = 10000; // OK
    ```

---

**2. 定义函数类型 (Function Types)**

接口也可以用来描述函数的签名（参数类型和返回值类型）。

```typescript
interface SearchFunc {
  (source: string, subString: string): boolean; // 定义一个调用签名
}

let mySearch: SearchFunc;

mySearch = function(src, sub) { // 参数名可以不同，但类型和顺序要匹配
  let result = src.search(sub);
  return result > -1;
};

// 错误: Type '(src: string) => boolean' is not assignable to type 'SearchFunc'.
// mySearch = function(src) { return true; };

// 错误: Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.
// mySearch = function(src, sub) { return "found"; };
```
虽然 `type` 别名通常更常用于定义函数类型，但 `interface` 也可以做到。

---

**3. 索引签名 (Index Signatures)**

当你不确定对象会有哪些属性名，但知道这些属性的类型时，可以使用索引签名。

```typescript
interface StringArray {
  [index: number]: string; // 索引是 number 类型，值是 string 类型 (类似字符串数组)
}
let names: StringArray = ["Alice", "Bob"];
console.log(names[0]); // "Alice"

interface Dictionary {
  [key: string]: any; // 索引是 string 类型，值可以是任意类型
  length: number;     // 可以同时有明确的属性，但其类型必须兼容索引签名的值类型 (number 兼容 any)
}
let data: Dictionary = {
  "name": "Project X",
  "version": 1.2,
  "enabled": true,
  length: 3 // 必须提供 length 属性
};
console.log(data["version"]); // 1.2
```
索引签名类型可以是 `string`、`number`、`symbol` 或模板字面量类型。

---

**4. 类实现接口 (Class Implementing Interface)**

接口可以强制类去满足某个契约，类必须实现接口中定义的所有成员。使用 `implements` 关键字。

```typescript
interface ClockInterface {
  currentTime: Date;
  setTime(d: Date): void;
}

class Clock implements ClockInterface {
  currentTime: Date = new Date(); // 必须实现 currentTime 属性

  setTime(d: Date) { // 必须实现 setTime 方法
    this.currentTime = d;
  }

  // 类可以有额外的成员
  constructor(h: number, m: number) {
     // ... (构造函数逻辑)
  }
  tick() {
      console.log("tick tock");
  }
}

// 错误: Class 'BrokenClock' incorrectly implements interface 'ClockInterface'.
// Property 'setTime' is missing in type 'BrokenClock' but required in type 'ClockInterface'.
// class BrokenClock implements ClockInterface {
//   currentTime: Date = new Date();
// }
```
一个类可以 `implements` 多个接口。

---

**5. 接口继承 (Interface Extending Interface)**

接口可以使用 `extends` 关键字从一个或多个其他接口继承成员，实现复用和组合。

```typescript
interface Shape {
  color: string;
}

interface PenStroke {
  penWidth: number;
}

// Square 继承自 Shape，拥有 color 属性
interface Square extends Shape {
  sideLength: number;
}

// Circle 继承自 Shape 和 PenStroke，拥有 color 和 penWidth 属性
interface Circle extends Shape, PenStroke {
    radius: number;
}

let square: Square = { color: "blue", sideLength: 10 };
let circle: Circle = { color: "red", penWidth: 2, radius: 5 };

console.log(square.color); // "blue"
console.log(circle.penWidth); // 2
```

---

**6. 混合类型 (Hybrid Types)**

接口可以描述那些“行为像函数又像对象”的类型，即一个类型既可以被调用，又有额外的属性。

```typescript
interface Counter {
  // 调用签名 (使其可以像函数一样被调用)
  (): void;
  // 属性
  interval: number;
  // 方法
  reset(): void;
}

function getCounter(): Counter {
  // 创建一个符合 Counter 接口的对象
  let counter = (() => { counter.count++; }) as Counter; // 使用类型断言初始化
  counter.count = 0;
  counter.interval = 1000;
  counter.reset = function() { this.count = 0; };
  // 需要手动添加额外的属性和方法
  return counter;
}

let c = getCounter();
c(); // 调用 counter()
console.log(c.count); // 访问属性
c.reset(); // 调用方法
```
这在描述一些特殊的库模式时可能有用。

---

**7. 接口合并 (Declaration Merging)**

如果你多次声明**同名**的 `interface`，TypeScript 会将它们的成员**合并**到同一个接口定义中。

```typescript
interface Box {
  height: number;
  width: number;
}

interface Box {
  scale: number;
  // height: string; // 错误：后续属性声明必须属于同一类型。 Property 'height' must be of type 'number', but here has type 'string'.
}

// 合并后的 Box 接口相当于：
// interface Box {
//   height: number;
//   width: number;
//   scale: number;
// }

let box: Box = { height: 5, width: 6, scale: 10 };
```
这个特性对于扩展第三方库的接口或者在不同文件中对同一个接口进行补充非常有用。**`type` 别名不支持声明合并。**

---

**接口 (`interface`) vs 类型别名 (`type`)**

`interface` 和 `type` 都可以用来描述对象的形状或函数签名，很多情况下可以互换。但它们有关键区别：

| 特性            | `interface`                     | `type` alias                       |
| :-------------- | :------------------------------ | :--------------------------------- |
| **主要用途**    | 定义对象形状、类契约             | 定义任何类型 (对象, 联合, 元组, 原始类型等) |
| **声明合并**    | 支持                            | 不支持 (会报错)                    |
| **继承/组合**   | 使用 `extends`                  | 使用交叉类型 `&`                   |
| **实现 (类)**  | 使用 `implements`               | `implements` 可以用于 `type` (如果其解析为对象形状)，但 `interface` 更惯用 |
| **可读性**      | 通常被认为更适合描述“是什么”     | 通常被认为更适合“别名”或复杂类型组合 |
| **灵活性**      | 主要用于对象结构                | 更通用，可用于联合、交叉、元组、映射类型等 |

**何时使用哪个？**

*   **优先使用 `interface`** 当你定义一个**对象**的形状，或者定义一个希望**类去实现**的契约时。它的声明合并能力在某些场景（如扩展库类型）很有用。
*   **使用 `type`** 当你需要定义**联合类型**、**元组类型**、**函数类型**（虽然 interface 也可以，但 type 更常见），或者使用**类型工具（Utility Types）**、**映射类型 (Mapped Types)**、**条件类型 (Conditional Types)** 等创建更复杂的类型别名时。

**一致性很重要**：在一个项目中，最好选择一种风格作为主要的类型定义方式（尤其是在对象形状上），除非有特定原因需要另一种。

---

**总结:**

`interface` 是 TypeScript 中用于**定义类型契约**的强大工具，主要用于：

*   描述对象的**形状** (属性、方法及其类型)。
*   定义**函数类型**。
*   利用**可选属性 (`?`)**、**只读属性 (`readonly`)** 和**索引签名 (`[]`)** 增强灵活性。
*   通过 **`implements`** 强制**类**遵守契约。
*   通过 **`extends`** 实现接口间的**继承与组合**。
*   利用**声明合并**扩展接口。

熟练使用接口是编写结构清晰、类型安全、易于维护的 TypeScript 代码的关键。