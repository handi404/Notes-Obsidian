TypeScript 中的 **Type Guards (类型保护)**。

**是什么？**

类型保护是一种 TypeScript 表达式或技术，它在运行时执行检查，以**确保一个变量在某个作用域内是特定的类型**。

想象一下，你有一个联合类型 `string | number` 的变量。在某个代码块里，你想调用字符串特有的方法（比如 `.toUpperCase()`），但在另一个代码块里，你想调用数字特有的方法（比如 `.toFixed()`）。直接调用会报错，因为 TypeScript 不确定当前变量到底是 `string` 还是 `number`。

类型保护就是用来解决这个问题的：它允许你写一些代码，**向 TypeScript 编译器“证明”**，在当前这个代码分支下，这个变量**确实**是某个具体的类型，从而安全地调用该类型特有的成员。

这个“证明”和缩类型的过程通常被称为 **类型窄化 (Type Narrowing)**，而类型保护是实现类型窄化的主要手段。

**常见的类型保护方式：**

1.  **`typeof` 类型保护**:
    *   用于检查**原始类型** (`string`, `number`, `boolean`, `symbol`, `bigint`, `undefined`, `function`)。
    *   **注意**: `typeof null` 返回 `"object"`，这是一个历史遗留问题，所以 `typeof` 不能直接用来判断 `null`。
    *   **语法**: `if (typeof variable === "typename") { ... }`

    ```typescript
    function printValue(value: string | number | boolean) {
      if (typeof value === "string") {
        // 在这个块内，TypeScript 知道 value 是 string
        console.log(value.toUpperCase());
      } else if (typeof value === "number") {
        // 在这个块内，TypeScript 知道 value 是 number
        console.log(value.toFixed(2));
      } else {
        // 在这个块内，TypeScript 知道 value 是 boolean
        console.log(value ? "It's true" : "It's false");
      }
    }
    ```

2.  **`instanceof` 类型保护**:
    *   用于检查一个值是否是**某个类的实例**。
    *   检查的是**原型链** (`prototype` chain)。
    *   右侧必须是一个**构造函数**。
    *   **语法**: `if (variable instanceof ClassName) { ... }`

    ```typescript
    class Bird { fly() { console.log("Flying..."); } }
    class Fish { swim() { console.log("Swimming..."); } }

    function move(pet: Bird | Fish) {
      if (pet instanceof Bird) {
        // 在这个块内，TypeScript 知道 pet 是 Bird 的实例
        pet.fly();
      } else {
        // 在这个块内，TypeScript 知道 pet 是 Fish 的实例 (假设只有这两种可能)
        pet.swim();
      }
    }
    let myPet = Math.random() > 0.5 ? new Bird() : new Fish();
    move(myPet);
    ```

3.  **`in` 操作符类型保护**:
    *   用于检查一个对象**自身或其原型链上**是否存在某个**属性名**。
    *   常用于检查**对象的结构**，特别是处理接口或类型别名定义的联合类型时。
    *   **语法**: `if ("propertyName" in object) { ... }`

    ```typescript
    interface Admin { name: string; privileges: string[]; }
    interface Employee { name: string; startDate: Date; }

    type UnknownEmployee = Admin | Employee;

    function printEmployeeInfo(emp: UnknownEmployee) {
      console.log(`Name: ${emp.name}`);
      // 检查 'privileges' 属性是否存在于 emp 对象中
      if ("privileges" in emp) {
        // 在这个块内，TypeScript 知道 emp 是 Admin 类型
        console.log(`Privileges: ${emp.privileges.join(", ")}`);
      }
      // 检查 'startDate' 属性是否存在于 emp 对象中
      if ("startDate" in emp) {
        // 在这个块内，TypeScript 知道 emp 是 Employee 类型
        console.log(`Start Date: ${emp.startDate}`);
      }
    }
    ```

4.  **字面量类型保护 / 等值判断保护**:
    *   通过严格相等 (`===`) 或不相等 (`!==`, `==`, `!=`) 检查，特别是与 `null`、`undefined` 或特定的**字面量值**比较。
    *   常用于**可辨识联合类型 (Discriminated Unions)**。

    ```typescript
    // 1. 检查 null/undefined
    function process(value: string | null) {
      if (value !== null) {
        // 在这个块内，TypeScript 知道 value 是 string
        console.log(value.trim());
      }
    }

    // 2. 可辨识联合类型 (Discriminated Unions)
    interface Circle { kind: "circle"; radius: number; }
    interface Square { kind: "square"; sideLength: number; }
    type Shape = Circle | Square;

    function getArea(shape: Shape) {
      // 通过检查 'kind' 属性的值来区分类型
      if (shape.kind === "circle") {
        // 在这个块内，TypeScript 知道 shape 是 Circle
        return Math.PI * shape.radius ** 2;
      } else {
        // 在这个块内，TypeScript 知道 shape 是 Square
        return shape.sideLength ** 2;
      }
      // 使用 switch 语句通常更清晰
      // switch (shape.kind) {
      //   case "circle": return Math.PI * shape.radius ** 2; // shape is Circle
      //   case "square": return shape.sideLength ** 2;     // shape is Square
      // }
    }
    ```

5.  **自定义类型保护函数 (User-Defined Type Guards)**:
    *   当内置的类型保护不满足需求时，可以创建自己的类型保护函数。
    *   这种函数返回一个特殊的布尔类型，称为**类型谓词 (Type Predicate)**。
    *   **类型谓词的语法**: `parameterName is Type`。
    *   如果函数返回 `true`，TypeScript 就会在调用该函数的 `if` 块内将 `parameterName` 的类型缩小为 `Type`。

    ```typescript
    interface Fish { swim: () => void; }
    interface Bird { fly: () => void; }

    // 自定义类型保护函数
    // 它检查传入的 pet 是否具有 swim 属性，并且该属性是函数类型
    // 返回值 'pet is Fish' 是关键的类型谓词
    function isFish(pet: Fish | Bird): pet is Fish {
      // 进行足够明确的检查来判断它是否是 Fish
      return typeof (pet as Fish).swim === 'function';
    }

    function feedPet(pet: Fish | Bird) {
      if (isFish(pet)) {
        // 在这个块内，TypeScript 通过 isFish 函数的返回谓词，知道 pet 是 Fish
        pet.swim();
        console.log("Feeding the fish...");
      } else {
        // 在这个块内，TypeScript 知道 pet 是 Bird
        pet.fly();
        console.log("Feeding the bird...");
      }
    }

    let pet1: Fish = { swim: () => console.log("Glub glub") };
    let pet2: Bird = { fly: () => console.log("Whoosh") };

    feedPet(pet1);
    feedPet(pet2);
    ```

**总结:**

*   类型保护是 TypeScript 中处理**联合类型**的关键机制。
*   它通过**运行时检查**来**缩小**变量在特定代码块中的类型范围（类型窄化）。
*   常用的内置类型保护包括 `typeof`, `instanceof`, `in` 和等值判断。
*   对于复杂场景，可以使用**自定义类型保护函数**，其返回值必须是**类型谓词 (`parameterName is Type`)**。
*   善用类型保护可以让你在享受联合类型灵活性的同时，保证代码的**类型安全**和**可读性**，并获得更好的 **IntelliSense** 支持。

---

```ts
interface User {
	type: 'user'
	username: string
	email: string
	id: Id
}
interface Person {
	type: 'person'
	firstname: string
	age: number
	id: Id
}

function logDetails(value: User | Person): void {
	if (value.type === 'user') {
		console.log(value.email, value.username)
	}
	if (value.type === 'person') {
		console.log(value.firstname, value.age)
	}
}
```