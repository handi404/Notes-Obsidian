以下是 TypeScript 中所有原始类型及其对应的包装对象的总结：

---

### **原始类型（Primitive Types）与包装对象（Wrapper Objects）**
| 原始类型        | 包装对象类型    | 说明                                             |
| ----------- | --------- | ---------------------------------------------- |
| `string`    | `String`  | 原始字符串类型，对应包装对象 `new String()`（极少使用）            |
| `number`    | `Number`  | 原始数字类型，对应包装对象 `new Number()`（几乎不用）             |
| `boolean`   | `Boolean` | 原始布尔类型，对应包装对象 `new Boolean()`（不建议使用）           |
| `symbol`    | `Symbol`  | 原始符号类型（ES6+），对应 `Symbol()`（不可通过 `new` 实例化）     |
| `bigint`    | `BigInt`  | 原始大整数类型（ES2020+），对应 `BigInt()`（不可通过 `new` 实例化） |
| `null`      | —         | 无对应的包装对象，表示空值                                  |
| `undefined` | —         | 无对应的包装对象，表示未定义的值                               |

---

### **关键区别**
1. **类型本质**：
   - **原始类型**：直接存储值（如 `'text'`, `42`, `true`），轻量高效。
   - **包装对象**：对象类型（如 `new String('text')`），存储引用地址，提供额外方法。

2. **使用场景**：
   - **原始类型**：99% 的场景应使用原始类型（声明变量、函数参数/返回值）。
   - **包装对象**：几乎不需要显式使用，仅在需要操作对象形式时（极少见）。

3. **自动装箱（Autoboxing）**：
   - 当调用原始类型的方法（如 `'hello'.toUpperCase()`）时，TypeScript/JavaScript 会自动将原始值临时包装为对象。
   - 无需手动创建包装对象。

---

### **注意事项**
1. **类型不兼容**：
   ```typescript
   let s: string = new String("hello"); // ❌ 错误：String 对象不能赋值给 string 类型
   let S: String = "hello";             // ❌ 错误：string 类型不能赋值给 String 类型
   ```

2. **Symbol 和 BigInt 的特殊性**：
   - `Symbol` 和 `BigInt` 的包装对象**不可通过 `new` 实例化**：
     ```typescript
     const sym = Symbol();    // ✅ 正确
     const symObj = new Symbol(); // ❌ 错误：Symbol 不可作为构造函数
     const big = BigInt(42);  // ✅ 正确
     const bigObj = new BigInt(); // ❌ 错误：BigInt 不可作为构造函数
     ```

3. **null 和 undefined**：
   - 没有对应的包装对象，直接表示空值或未定义。

---

### **总结**
- **优先使用原始类型**：`string`, `number`, `boolean`, `symbol`, `bigint`。
- **避免包装对象**：`String`, `Number`, `Boolean`, `Symbol`, `BigInt` 仅在极少数特殊场景需要。
- **自动装箱机制**：无需手动转换，原始类型可直接调用方法（如 `'abc'.length`）。