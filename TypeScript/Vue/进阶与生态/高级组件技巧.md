探讨这些能极大提升组件灵活性和复用性的高级技巧。

---

### 1. 插槽 (`Slots`)：组件的“内容占位符”

**核心思想**：让父组件可以决定子组件中**某一部分的内容**。插槽就像在组件的模板上开了一个“口子”，父组件可以将任何模板片段“塞”进这个口子里。这使得组件在保持自身结构和逻辑的同时，内容部分可以高度自定义。

#### 知识点

**A. 默认插槽 (Default Slot)**

最简单的插槽，一个组件只有一个。

**`BaseCard.vue` (子组件)**
```vue
<template>
  <div class="card">
    <header class="card-header">
      <h3>Card Title</h3>
    </header>
    <main class="card-content">
      <!-- 这里就是“口子” -->
      <slot></slot>
    </main>
  </div>
</template>

<style scoped>
.card { border: 1px solid #ccc; border-radius: 8px; padding: 16px; }
/* ... other styles */
</style>
```

**`Parent.vue` (父组件)**
```vue
<template>
  <BaseCard>
    <!-- 放在 BaseCard 标签内的所有内容，都会被渲染到 <slot> 的位置 -->
    <p>This is the content for the card.</p>
    <img src="/path/to/image.png" alt="An image">
  </BaseCard>
</template>
```

**B. 具名插槽 (Named Slots)**

当一个组件需要多个可定制的内容区域时，使用具名插槽。

**`PageLayout.vue` (子组件)**
```vue
<template>
  <div class="container">
    <header>
      <!-- name="header" 的插槽 -->
      <slot name="header">
        <!-- 插槽的后备内容 (Fallback Content) -->
        <!-- 如果父组件没有提供这个插槽，则显示后备内容 -->
        <h1>Default Page Header</h1>
      </slot>
    </header>
    <main>
      <!-- 默认插槽，可以和具名插槽共存 -->
      <slot></slot>
    </main>
    <footer>
      <!-- name="footer" 的插槽 -->
      <slot name="footer"></slot>
    </footer>
  </div>
</template>
```

**`Parent.vue` (父组件)**
```vue
<template>
  <PageLayout>
    <!-- 使用 <template v-slot:header> 或其简写 #header 来指定插槽 -->
    <template #header>
      <h2>My Custom Page Header</h2>
    </template>

    <!-- 不带 v-slot 的内容会进入默认插槽 -->
    <p>This is the main content of the page.</p>

    <!-- #footer 是 v-slot:footer 的简写 -->
    <template #footer>
      <p>&copy; 2024 My Company</p>
    </template>
  </PageLayout>
</template>
```

**C. 作用域插槽 (Scoped Slots)**

**这是插槽最强大的功能**。它允许子组件在渲染插槽时，将**子组件内部的数据**传递给父组件，让父组件可以根据这些数据来决定插槽的内容。

**`TodoList.vue` (子组件)**
```vue
<script setup lang="ts">
import { ref } from 'vue';
interface Todo { id: number; text: string; completed: boolean; }
const todos = ref<Todo[]>([
  { id: 1, text: 'Learn Vue', completed: true },
  { id: 2, text: 'Master Slots', completed: false },
]);
</script>

<template>
  <ul>
    <li v-for="todo in todos" :key="todo.id">
      <!-- 
        通过 v-bind 将子组件的数据 (todo) 暴露给父组件。
        父组件可以通过 v-slot="slotProps" 来接收这些数据。
      -->
      <slot :item="todo" :index="todo.id"></slot>
    </li>
  </ul>
</template>
```

**`Parent.vue` (父组件)**
```vue
<template>
  <TodoList>
    <!-- 
      使用 v-slot="slotProps" 接收子组件传递的所有数据。
      slotProps 是一个对象，包含了 { item: {...}, index: ... }
      你也可以直接解构它，如 v-slot="{ item, index }"
    -->
    <template #default="{ item, index }">
      <span :style="{ textDecoration: item.completed ? 'line-through' : 'none' }">
        {{ index }}. {{ item.text }}
      </span>
      <input type="checkbox" :checked="item.completed">
    </template>
  </TodoList>
</template>
```
**核心价值**：`TodoList` 组件只负责**数据的迭代和提供**，而每一项**如何展示**的逻辑则完全由父组件通过作用域插槽来控制。这实现了逻辑和视图的完美分离，大大增强了组件的复用性。

---

### 2. 依赖注入 (`Provide` / `Inject`)：跨层级的“隐形通道”

**核心思想**：解决“属性透传”问题。允许一个祖先组件向其所有后代组件（无论层级多深）提供数据或方法，而后代组件可以按需“注入”并使用这些数据。

**`provide`** 在祖先组件中提供值。
**`inject`** 在后代组件中注入值。

#### 知识点与最佳实践

**`keys.ts` (定义类型安全的注入键)**
使用 `Symbol` 作为 `InjectionKey` 可以避免命名冲突，并提供强大的类型支持。
```typescript
import type { InjectionKey, Ref } from 'vue';

export interface UserInfo {
  name: string;
  email: string;
}

// 定义一个类型化的 InjectionKey
export const userInfoKey = Symbol() as InjectionKey<Ref<UserInfo>>;
```

**`Ancestor.vue` (提供方)**
```vue
<script setup lang="ts">
import { provide, ref } from 'vue';
import { userInfoKey, type UserInfo } from './keys';
import DeepChild from './DeepChild.vue';

const user = ref<UserInfo>({ name: 'Alice', email: 'alice@vue.dev' });

// 使用类型化的 key 来 provide 数据
// 提供一个 ref，这样当 user 变化时，所有注入它的组件都会更新
provide(userInfoKey, user);

// 模拟数据更新
setTimeout(() => {
  user.value.name = 'Alice Smith';
}, 3000);
</script>

<template>
  <DeepChild />
</template>
```

**`DeepChild.vue` (注入方)**
```vue
<script setup lang="ts">
import { inject } from 'vue';
import { userInfoKey } from './keys';

// 使用相同的 key 来 inject 数据
// 如果可能找不到提供者，可以提供一个默认值
const injectedUser = inject(userInfoKey);

if (!injectedUser) {
  // 处理未找到 provider 的情况
  throw new Error('Could not find user info provider!');
}
</script>

<template>
  <div v-if="injectedUser">
    <h3>Deeply Nested Component</h3>
    <p>Injected User Name: {{ injectedUser.name }}</p>
  </div>
</template>
```

**要点/注意事项**：
*   **非响应式提供**：如果你 `provide` 一个普通对象而不是一个 `ref`，那么当祖先组件的数据变化时，后代组件**不会**自动更新。因此，**强烈推荐 `provide` 响应式数据 (`ref` 或 `reactive`)**。
*   **滥用风险**：`provide/inject` 使得组件间的依赖关系变得不那么明确。过度使用会使应用状态难以追踪。它最适合用于提供那些**全局性或半全局性**、不常变化的数据，如：主题信息、当前用户信息、i 18 n 函数等。对于大多数场景，Props 仍然是首选。

---

### 3. 动态组件 & 异步组件

#### 动态组件 `<component :is="...">`

**核心思想**：在一个挂载点动态地切换渲染不同的组件。

**`App.vue`**
```vue
<script setup lang="ts">
import { ref, shallowRef } from 'vue';
import ComponentA from './ComponentA.vue';
import ComponentB from './ComponentB.vue';
import ComponentC from './ComponentC.vue';

const tabs = { ComponentA, ComponentB, ComponentC };
// 使用 shallowRef 来存储组件定义，可以避免不必要的深度响应式开销
const currentTab = shallowRef(ComponentA);
</script>

<template>
  <div>
    <button v-for="(_, tabName) in tabs" @click="currentTab = tabs[tabName]">
      {{ tabName }}
    </button>
    
    <!-- :is 属性可以接收一个组件定义对象 -->
    <!-- Vue 会在这里渲染 currentTab 变量所指向的组件 -->
    <keep-alive>
      <component :is="currentTab"></component>
    </keep-alive>
  </div>
</template>
```
**`keep-alive`**：与动态组件是天作之合。被 `<keep-alive>` 包裹的动态组件在切换出去时，其状态会被缓存，而不是被销毁。这在实现 Tab 切换等功能时非常有用。

#### 异步组件 `defineAsyncComponent`

**核心思想**：将组件的加载推迟到它实际需要被渲染时。这对于优化应用的**首屏加载时间 (TTV/TTA)** 至关重要，是代码分割 (Code Splitting) 的一种体现。

Vue Router 的懒加载 `() => import(...)` 本质上就是异步组件的一种应用。我们也可以手动创建异步组件。

```typescript
import { defineAsyncComponent } from 'vue';

// 1. 最简单的形式
const AsyncComponent = defineAsyncComponent(() =>
  import('./MyHeavyComponent.vue')
);

// 2. 带有加载和错误状态的高级形式
import LoadingComponent from './Loading.vue';
import ErrorComponent from './Error.vue';

const AsyncAdvancedComponent = defineAsyncComponent({
  // 加载函数
  loader: () => import('./MyHeavyComponent.vue'),
  
  // 加载异步组件时显示的组件
  loadingComponent: LoadingComponent,
  
  // 如果加载失败，显示的组件
  errorComponent: ErrorComponent,
  
  // 在显示 loadingComponent 之前的延迟，单位 ms
  delay: 200,
  
  // 如果加载器函数在指定时间内未解析，则显示错误组件
  timeout: 3000,
});
```
**使用场景**：
*   路由视图（Vue Router 自动处理）。
*   由 `v-if` 控制的、不一定在初始时就显示的组件（如弹窗 Modals）。
*   任何体积较大且不是首屏核心内容的组件。