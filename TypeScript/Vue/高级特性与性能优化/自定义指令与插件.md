Vue 中两个用于扩展其核心功能的强大机制：**自定义指令**和**插件**。它们提供了在标准组件模型之外封装和复用能力的途径。

---

### 自定义指令 (Custom Directives)

**核心思想**：当你需要进行**底层的、直接的 DOM 操作**时，自定义指令提供了一种封装这些操作并使其在模板中声明式使用的优雅方式。它是 Vue 响应式系统和组件模型的“逃生舱口”，让你在必要时可以回归到操作原生 DOM。

**经验法则**：**始终优先考虑用组件来解决问题。** 只有当现有组件和组合式函数无法实现，且必须直接操作 DOM 时，才考虑使用自定义指令。例如：与一个不提供 Vue 组件接口的第三方 DOM 库集成、实现一个自动获取焦点的输入框等。

#### 知识点：如何编写

自定义指令是一个包含生命周期钩子函数的对象。这些钩子函数会在指令所绑定的元素的生命周期中被调用。

**常用钩子**：
*   `created`：在绑定元素的 attribute 或事件监听器被应用之前调用。
*   `beforeMount`：当指令第一次绑定到元素并且在挂载父组件之前调用。
*   `mounted`：在绑定元素的父组件被挂载后调用。**这是执行 DOM 操作最常见的地方。**
*   `updated`：在包含组件的 VNode 及其子组件的 VNode 更新后调用。
*   `unmounted`：在绑定元素的父组件被卸载后调用。**这是清理工作的关键。**

**案例 1：一个简单的 `v-focus` 指令**
在 `<script setup>` 中，任何以 `v` 开头的驼峰式命名的变量都可以被用作一个自定义指令。

**`MyComponent.vue`**
```vue
<script setup lang="ts">
import type { Directive } from 'vue';

// 指令的实现
// vFocus 是一个符合 Directive 接口的对象
const vFocus: Directive<HTMLInputElement, void> = {
  // 当被绑定的元素挂载到 DOM 中时，此钩子被调用
  mounted(el) {
    // el 是指令所绑定的 DOM 元素
    el.focus();
  }
};
</script>

<template>
  <!-- 在模板中使用 v-focus -->
  <input v-focus />
</template>
```
这是一种局部注册指令的方式，该指令只能在 `MyComponent.vue` 中使用。

**案例 2：全局注册一个带参数的 `v-highlight` 指令**
如果你希望一个指令在整个应用中都可用，可以在 `main.ts` 中全局注册。

**`directives/highlight.ts`**
```typescript
import type { Directive, DirectiveBinding } from 'vue';

interface HighlightBinding {
  color?: string;
  background?: string;
}

export const highlightDirective: Directive<HTMLElement, HighlightBinding> = {
  mounted(el: HTMLElement, binding: DirectiveBinding<HighlightBinding>) {
    // binding.value 是传递给指令的值
    el.style.color = binding.value?.color || 'red';
    el.style.backgroundColor = binding.value?.background || 'yellow';
  },
  // 当指令的值更新时，也需要更新样式
  updated(el: HTMLElement, binding: DirectiveBinding<HighlightBinding>) {
    el.style.color = binding.value?.color || 'red';
    el.style.backgroundColor = binding.value?.background || 'yellow';
  }
};
```

**`main.ts`**
```typescript
import { createApp } from 'vue';
import App from './App.vue';
import { highlightDirective } from './directives/highlight';

const app = createApp(App);

// 全局注册指令
app.directive('highlight', highlightDirective);

app.mount('#app');
```

**在任何组件中使用：**
```vue
<template>
  <!-- 不带参数，使用默认值 -->
  <p v-highlight>This text will be highlighted with defaults.</p>
  
  <!-- 传递一个对象作为参数 -->
  <p v-highlight="{ color: 'white', background: 'blue' }">
    This text will have custom highlight colors.
  </p>
</template>
```
**`binding` 对象**：
`binding` 是一个非常重要的参数，它包含了指令的各种信息：
*   `binding.value`: 传递给指令的值。
*   `binding.oldValue`: 之前的值，仅在 `updated` 钩子中可用。
*   `binding.arg`: 指令的参数，例如 `v-my-directive:foo` 中的 `foo`。
*   `binding.modifiers`: 修饰符对象，例如 `v-my-directive.bar.baz` 中的 `{ bar: true, baz: true }`。

---

### 插件 (Plugins)

**核心思想**：插件是一个对象或函数，用于向 Vue 应用**添加全局级别的功能**。它是一种比全局注册组件或指令更结构化、更强大的方式来扩展 Vue。

**插件可以用来做什么？**
*   通过 `app.component()` 和 `app.directive()` 添加一个或多个全局组件/指令。
*   通过 `app.provide()` 使一个资源（如一个方法或一个响应式对象）在整个应用中可被注入。
*   向 `app.config.globalProperties` 添加一些全局实例属性或方法，让它们在任何组件的模板或选项式 API 中可用（在组合式 API 中不推荐使用）。
*   一个完全独立的库，例如 `vue-router` 或 `pinia`，它们通过 `app.use()` 来安装自己。

#### 知识点：如何编写

一个插件可以是一个带有 `install` 方法的对象，也可以直接是一个函数。这个 `install` 函数会接收到 `app` 实例作为第一个参数，以及用户传入的选项作为第二个参数。

**案例：创建一个简单的插件来提供全局格式化函数**

**`plugins/i18n.ts`**
```typescript
import type { App, InjectionKey } from 'vue';

// 1. 定义插件选项的类型
interface I18nOptions {
  translations: Record<string, Record<string, string>>;
}

// 2. 定义一个 InjectionKey，让翻译函数可以被安全地注入
export const i18nKey: InjectionKey<(key: string) => string> = Symbol('i18n');

// 3. 插件对象
export default {
  install(app: App, options: I18nOptions) {
    // 创建一个翻译函数
    const t = (key: string): string => {
      // 这是一个简化的实现
      // 实际上会更复杂，比如需要处理当前语言
      const keys = key.split('.');
      let result: any = options.translations['en'];
      for (const k of keys) {
        result = result?.[k];
      }
      return result || key;
    };

    // 4. 通过 provide 让整个应用可以注入这个函数
    app.provide(i18nKey, t);

    // [可选] 如果你想在选项式 API 中通过 this.$t 使用
    // 在 Vue 3 和组合式 API 中，这种方式不那么常见了
    app.config.globalProperties.$t = t;
  }
};
```

**`main.ts`**
```typescript
import { createApp } from 'vue';
import App from './App.vue';
import i18nPlugin from './plugins/i18n'; // 导入插件

const app = createApp(App);

// 使用插件，并传入选项
app.use(i18nPlugin, {
  translations: {
    en: {
      greeting: 'Hello, Vue!',
      labels: {
        username: 'Username'
      }
    }
  }
});

app.mount('#app');
```

**在任何组件中使用 (通过 `inject`)**
```vue
<script setup lang="ts">
import { inject } from 'vue';
import { i18nKey } from '@/plugins/i18n';

// 注入翻译函数
const t = inject(i18nKey);

if (!t) {
  throw new Error('i18n plugin not installed');
}
</script>

<template>
  <h1>{{ t('greeting') }}</h1>
  <label>{{ t('labels.username') }}</label>
</template>
```

**要点/注意事项**
*   **单一职责原则**：好的插件应该专注于做好一件事。例如，一个插件负责国际化，另一个负责弹窗通知。
*   **可配置性**：通过 `install` 函数的 `options` 参数，让你的插件变得可配置，这会大大增加它的灵活性和复用性。
*   **组合优于继承**：插件是 Vue 生态系统中组合思想的体现。我们通过组合不同的、小而美的插件来构建复杂的功能，而不是创建一个巨大的、无所不包的“框架”。
*   **文档**：如果你编写了一个要给他人使用的插件，清晰的文档至关重要，需要说明如何安装、有哪些配置项、以及如何使用它提供的功能。