探讨 Vue 组件的生命之旅——生命周期钩子。在组合式 API (Composition API) 中，生命周期钩子的使用方式变得更加直观和灵活。

### 组件的生命周期：从出生到消亡

一个 Vue 组件的生命可以分为四个主要阶段：

1.  **创建 (Creation)**：组件实例被创建，但尚未被添加到 DOM 中。此时，响应式数据、计算属性等已经设置好，但你还无法访问到任何 DOM 元素。
2.  **挂载 (Mounting)**：组件的模板被编译成渲染函数，然后被渲染到真实的 DOM 中。这个阶段完成后，组件就“活”在了页面上。
3.  **更新 (Updating)**：当组件的响应式数据发生变化时，虚拟 DOM (Virtual DOM) 会重新渲染，并与旧的 VDOM 进行比对 (diff)，然后将变化的部分更新到真实的 DOM 中。
4.  **卸载 (Unmounting)**：当组件不再需要时（例如，`v-if` 变为 `false`，或用户切换路由离开页面），它会从 DOM 中被移除，并清理相关的资源（如事件监听器、定时器等）。

**生命周期钩子 (Lifecycle Hooks)** 就是 Vue 在这些特定阶段提供给我们的“回调函数”，允许我们在组件生命的不同时刻执行自己的代码。

---

### 组合式 API 中的生命周期钩子

在 `<script setup>` 中，生命周期钩子都是需要从 `vue` 中导入的函数。它们都以 `on` 开头，非常语义化。

| 组合式 API 钩子          | 对应选项式 API                 | 触发时机                                             |
| :------------------ | :------------------------ | :----------------------------------------------- |
| `setup` (函数本身)      | `beforeCreate`, `created` | 组件实例被创建，props 解析完毕后，**在所有其他钩子之前**执行。             |
| `onMounted`         | `mounted`                 | 组件被挂载到 DOM **之后**。**这是执行 DOM 操作、初始化第三方库最常用的地方。** |
| `onUpdated`         | `updated`                 | 组件因响应式数据变化而更新了 DOM **之后**。                       |
| `onUnmounted`       | `unmounted`               | 组件实例被卸载**之后**。**这是清理副作用（定时器、事件监听）最关键的地方。**       |
| `onBeforeMount`     | `beforeMount`             | 组件被挂载到 DOM **之前**。此时模板已编译，但尚未插入页面。               |
| `onBeforeUpdate`    | `beforeUpdate`            | 组件更新**之前**。此时可以访问到更新前的 DOM。                      |
| `onBeforeUnmount`   | `beforeUnmount`           | 组件实例被卸载**之前**。此时组件实例依然可用。                        |
| `onErrorCaptured`   | `errorCaptured`           | 捕获来自后代组件的错误时。                                    |
| `onRenderTracked`   | `renderTracked`           | (开发模式) 当一个响应式依赖被追踪时。用于调试。                        |
| `onRenderTriggered` | `renderTriggered`         | (开发模式) 当一个依赖导致组件重新渲染时。用于调试。                      |
| `onActivated`       | `activated`               | (仅 `<KeepAlive>`) 被缓存的组件被激活时。                    |
| `onDeactivated`     | `deactivated`             | (仅 `<KeepAlive>`) 被缓存的组件失活时。                     |


### 核心生命周期钩子详解

#### 1. `setup` (隐式)

在 `<script setup>` 模式下，整个 `<script>` 块的代码逻辑都在 `setup` 钩子中执行。它在组件的生命周期中**最早**被调用。

*   **特点**：
    *   在 `props` 解析之后，组件实例创建之前执行。
    *   无法访问 `this`（因为实例还没创建好）。
    *   是所有组合式 API 的“舞台”。

#### 2. `onMounted`：组件的“就职典礼”

这是最重要、最常用的钩子之一。

*   **触发时机**：当组件的 DOM 树已经被完整地创建并插入到页面中。
*   **核心用途**：
    1.  **执行 DOM 操作**：此时你可以安全地访问和操作 DOM 元素，例如通过 `ref` 获取元素实例。
    2.  **集成第三方库**：很多需要挂载到特定 DOM 元素的库（如图表库 ECharts、地图库）必须在这里初始化。
    3.  **发起网络请求**：虽然也可以在 `setup` 中请求，但在 `onMounted` 中请求可以确保组件已挂载，如果请求需要操作 DOM，这里是更安全的选择。

**示例：**
```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue';
import 'some-chart-library'; // 假设这是一个图表库

// 1. 创建一个 ref 来引用 DOM 元素
const chartContainer = ref<HTMLDivElement | null>(null);

onMounted(() => {
  // 此时，<div ref="chartContainer"> 已经存在于页面上
  console.log('Component has been mounted!');
  
  if (chartContainer.value) {
    // 2. 安全地访问 DOM 元素并初始化图表库
    const chartInstance = new SomeChartLibrary(chartContainer.value);
    chartInstance.render();
  }
  
  // 3. 发起初始数据请求
  fetch('/api/initial-data').then(/* ... */);
});
</script>

<template>
  <div ref="chartContainer" class="chart"></div>
</template>
```

#### 3. `onUpdated`：响应变化之后

*   **触发时机**：在组件的数据变化导致 DOM 更新**完成之后**。
*   **核心用途**：
    *   在 DOM 更新后执行需要依赖新 DOM 结构的操作。例如，在一个聊天应用中，当新消息被添加到列表后，你可能需要将滚动条滚动到底部。

**示例：**
```vue
<script setup lang="ts">
import { ref, onMounted, onUpdated, nextTick } from 'vue';

const messages = ref(['Hello', 'How are you?']);
const chatBox = ref<HTMLUListElement | null>(null);

function addMessage() {
  messages.value.push('I am fine, thank you!');
}

onUpdated(() => {
  // 当 messages 数组变化，DOM <li> 更新后，此钩子被调用
  console.log('Component has been updated!');
  
  if (chatBox.value) {
    // 将滚动条滚动到底部
    chatBox.value.scrollTop = chatBox.value.scrollHeight;
  }
});
</script>

<template>
  <ul ref="chatBox">
    <li v-for="msg in messages" :key="msg">{{ msg }}</li>
  </ul>
  <button @click="addMessage">Add Message</button>
</template>
```
**注意**：避免在 `onUpdated` 中修改组件状态，这可能会导致无限更新循环。如果确实需要，请确保有明确的终止条件。

#### 4. `onUnmounted`：最后的“告别仪式”

这是与 `onMounted` 相对的钩子，同样至关重要。

*   **触发时机**：在组件被从 DOM 中移除，实例被销毁**之后**。
*   **核心用途**：**清理工作！** 防止内存泄漏。
    1.  **销毁手动创建的事件监听器**：例如 `window.addEventListener` 或第三方库的 `.on()` 事件。
    2.  **清除定时器**：如 `setInterval` 和 `setTimeout`。
    3.  **销毁第三方库实例**：如果库提供了 `destroy` 或 `dispose` 方法。

**示例：一个追踪鼠标位置的组件**
```vue
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';

const x = ref(0);
const y = ref(0);

const update = (e: MouseEvent) => {
  x.value = e.pageX;
  y.value = e.pageY;
};

// 组件挂载时，添加全局事件监听
onMounted(() => {
  window.addEventListener('mousemove', update);
});

// 组件卸载时，必须移除事件监听，否则即使组件消失了，
// update 函数依然会持续被调用，造成内存泄漏！
onUnmounted(() => {
  console.log('Component is unmounting, cleaning up...');
  window.removeEventListener('mousemove', update);
});
</script>

<template>
  <div>Mouse position: {{ x }}, {{ y }}</div>
</template>
```

---

### 要点/注意事项

1.  **`setup` vs. `onMounted`**：
    *   `setup` 用于设置响应式状态、计算属性、侦听器等“数据层面”的逻辑。
    *   `onMounted` 用于处理与“DOM 层面”相关的逻辑。一个简单的准则是：如果你的代码需要访问 `document`、`window` 或通过 `ref` 获取的 DOM 元素，它就应该放在 `onMounted` 里。

2.  **服务器端渲染 (SSR)**：在 SSR 环境中，只有 `setup`、`onBeforeMount` 和 `onMounted` 之前的钩子会在服务器上执行。`onMounted`, `onUpdated`, `onUnmounted` 等只在客户端执行。因此，任何特定于浏览器的代码都应放在 `onMounted` 或之后的钩子中。

3.  **钩子的执行顺序**：
    *   **父子组件嵌套时**：
        *   **挂载**：父 `onBeforeMount` -> 子 `onBeforeMount` -> 子 `onMounted` -> 父 `onMounted` (子组件先准备好，父组件才算准备好)。
        *   **卸载**：父 `onBeforeUnmount` -> 子 `onBeforeUnmount` -> 子 `onUnmounted` -> 父 `onUnmounted` (子组件先清理完，父组件才算清理完)。

4.  **在 Composables 中使用**：生命周期钩子只能在组件的 `setup` 期间同步调用。这意味着你可以将它们封装在组合式函数 (Composables) 中，这非常强大。

    ```ts
    // composables/useEventListener.ts
    import { onMounted, onUnmounted } from 'vue';

    export function useEventListener(target, event, callback) {
      onMounted(() => target.addEventListener(event, callback));
      onUnmounted(() => target.removeEventListener(event, callback));
    }
    ```
    在组件中使用：
    ```ts
    // MyComponent.vue
    import { useEventListener } from './useEventListener';
    useEventListener(window, 'resize', () => { /* ... */ });
    ```
    这个 Composable 自动处理了生命周期的绑定和清理，让组件代码极其干净。