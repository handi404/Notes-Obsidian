组件通信是构建复杂 Vue 应用的“血脉”，理解其模式是至关重要的。在现代 Vue (TypeScript) 中，我们有非常清晰和类型安全的方式来处理组件间的数据流。

---

### 1. 父到子 (`Props`)：单向数据流的基石

**核心思想**：数据从父组件“流向”子组件。这是一种单向数据流，使得应用的状态更容易追踪和理解。你可以把 Props 想象成给组件函数传递的参数。

**工作方式**：父组件通过 `v-bind` (或其简写 `:`) 将数据绑定到子组件的属性上。子组件使用 `defineProps` 宏来声明它期望接收的 props 及其类型。

#### **知识点**

**`ChildComponent.vue` (接收方)**
```vue
<script setup lang="ts">
// 1. 使用泛型参数进行类型声明，这是最推荐、最强大的方式
// defineProps 是一个编译器宏，无需导入
interface Props {
  title: string; // 必选 prop
  likes?: number; // 可选 prop (用 ? 表示)
  author: { name: string }; // 对象类型 prop
  isPublished: boolean;
}

// 2. 使用 withDefaults 为 props 提供默认值
// 注意：一旦使用 withDefaults，可选类型 '?' 会失效，
// Vue 会根据是否提供了默认值来判断是否可选。
const props = withDefaults(defineProps<Props>(), {
  likes: 0, // 为可选的 'likes' 提供默认值
  isPublished: false,
});

// 警告：子组件永远不应该直接修改 prop！
// props.title = "New Title"; // 错误！这会违反单向数据流原则，并收到警告。
</script>

<template>
  <article>
    <h1>{{ props.title }}</h1>
    <p>By: {{ props.author.name }}</p>
    <span>Likes: {{ props.likes }}</span>
    <p v-if="props.isPublished">Status: Published</p>
    <p v-else>Status: Draft</p>
  </article>
</template>
```

**`ParentComponent.vue` (发送方)**
```vue
<script setup lang="ts">
import { ref, reactive } from 'vue';
import ChildComponent from './ChildComponent.vue';

const postTitle = ref("My First Vue Post");
const postAuthor = reactive({ name: 'Jane Doe' });
</script>

<template>
  <div>
    <!-- 使用 v-bind 的简写 ':' 来传递 props -->
    <ChildComponent
      :title="postTitle"
      :author="postAuthor"
      :likes="120"
      :is-published="true"
    />
    
    <!-- 另一个实例，不传递可选 props，它们将使用默认值 -->
    <ChildComponent
      title="Another Post"
      :author="{ name: 'John Smith' }"
    />
  </div>
</template>
```

#### **要点/注意事项**

1.  **单向数据流 (One-Way Data Flow)**：这是最重要的原则。父组件更新 prop，子组件会自动更新。但子组件**绝不能**直接修改 prop。这样做会使数据流变得混乱，难以调试。如果子组件需要修改数据，它应该**通知父组件**来完成修改（见下一节 `emits`）。
2.  **类型安全**：在 `<script setup>` 中使用 `<T>` 泛型语法与 `defineProps` 结合，可以获得完美的 TypeScript 类型推断和编辑器支持。如果父组件传递了错误的类型，TypeScript 会在编译时发出警告。
3.  **Prop 命名**：在 `<script>` 中使用 `camelCase` (驼峰命名法) 如 `isPublished`，在 `<template>` 中传递时推荐使用 `kebab-case` (短横线分隔命名法) 如 `is-published`。Vue 会自动转换。当然，在 `<script setup>` 模式下，直接使用 `camelCase` 也是完全支持的。
4.  **`withDefaults`**: 当你使用类型声明 `defineProps<Props>()` 时，无法直接在类型中指定默认值。`withDefaults` 编译器宏就是为了解决这个问题而生的。

---

### 2. 子到父 (`Emits`)：向上传递信号

**核心思想**：子组件不直接修改父组件的状态，而是通过触发一个**事件**来“请求”父组件进行更改。这就像一个孩子不能直接从父母钱包里拿钱，但他可以“请求”父母给他零花钱。

**工作方式**：子组件使用 `defineEmits` 宏来声明它可以触发的事件。然后通过调用 `emit` 函数来触发事件，并可以附带数据（payload）。父组件使用 `v-on` (或其简写 `@`) 来监听这些事件。

#### **知识点**

**`ChildComponent.vue` (事件发出方)**
```vue
<script setup lang="ts">
// 1. 同样使用泛型语法声明可触发的事件及其参数类型
// 'update:title' 是一种常见的事件命名约定，用于 v-model (下文会讲)
const emit = defineEmits<{
  (e: 'update:title', newTitle: string): void; // 事件名和载荷类型
  (e: 'publishPost', postId: number, options: { immediate: boolean }): void;
  (e: 'close'): void; // 没有载荷的事件
}>();

const props = defineProps<{ id: number, title: string }>();

function handleTitleChange(event: Event) {
  const target = event.target as HTMLInputElement;
  // 2. 触发事件，将新标题作为载荷传递出去
  emit('update:title', target.value);
}

function publish() {
  // 3. 触发另一个事件，可以带多个参数
  emit('publishPost', props.id, { immediate: true });
}
</script>

<template>
  <div>
    <label>Edit Title: </label>
    <input :value="title" @input="handleTitleChange" />
    <button @click="publish">Publish</button>
  </div>
</template>
```

**`ParentComponent.vue` (事件监听方)**
```vue
<script setup lang="ts">
import { ref } from 'vue';
import ChildComponent from './ChildComponent.vue';

const post = ref({ id: 1, title: 'My Post' });

// 4. 事件处理函数，参数类型被完美推断
function handleTitleUpdate(newTitle: string) {
  console.log('Received new title from child:', newTitle);
  post.value.title = newTitle;
}

function handlePublish(postId: number, options: { immediate: boolean }) {
  console.log(`Publishing post ${postId} with options:`, options);
}
</script>

<template>
  <div>
    <h2>Current Title: {{ post.title }}</h2>
    <!-- 5. 使用 @ 监听子组件触发的事件，并绑定处理函数 -->
    <ChildComponent
      :id="post.id"
      :title="post.title"
      @update:title="handleTitleUpdate"
      @publish-post="handlePublish"
    />
  </div>
</template>
```

---

### 3. 双向绑定 (`v-model`)：Props 和 Emits 的语法糖

**核心思想**：`v-model` 是实现双向数据绑定的便捷方式，但其本质只是 `prop` 和 `emit` 结合的“语法糖”。它让父子组件间的状态同步代码变得极其简洁。

**工作方式**：
一个 `v-model` 在组件上等价于：
*   传递一个名为 `modelValue` 的 prop。
*   监听一个名为 `update:modelValue` 的事件。

你也可以给 `v-model` 传递参数，如 `v-model:title`，它等价于：
*   传递一个名为 `title` 的 prop。
*   监听一个名为 `update:title` 的事件。

#### **知识点**

**`CustomInput.vue` (实现 `v-model` 的子组件)**
```vue
<script setup lang="ts">
import { computed } from 'vue';

const props = defineProps<{
  modelValue: string; // 默认 v-model 对应的 prop
  title: string;      // 命名 v-model (v-model:title) 对应的 prop
}>();

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
  (e: 'update:title', value: string): void;
}>();

// 最佳实践：使用 computed 属性来处理 v-model，避免直接修改 prop
const localValue = computed({
  get() {
    return props.modelValue;
  },
  set(newValue) {
    emit('update:modelValue', newValue);
  },
});

const localTitle = computed({
  get() {
    return props.title;
  },
  set(newValue) {
    emit('update:title', newValue);
  }
})
</script>

<template>
  <div>
    <label>Username: </label>
    <!-- 将 v-model 绑定到 computed 属性上 -->
    <input v-model="localValue" />
  </div>
  <div>
    <label>Title: </label>
    <input v-model="localTitle" />
  </div>
</template>
```

**`ParentComponent.vue` (使用 `v-model`)**
```vue
<script setup lang="ts">
import { ref } from 'vue';
import CustomInput from './CustomInput.vue';

const username = ref('guest');
const pageTitle = ref('My Page');
</script>

<template>
  <div>
    <p>Parent Username: {{ username }}</p>
    <p>Parent Page Title: {{ pageTitle }}</p>
    
    <!-- 使用 v-model，代码非常简洁 -->
    <CustomInput v-model="username" v-model:title="pageTitle" />
  </div>
</template>
```

#### **要点/注意事项**

1.  **`v-model` 是语法糖**：务必理解 `v-model` 的本质，它不是什么魔法。这有助于你在遇到复杂情况时进行调试。
2.  **`computed` 模式是黄金搭档**：在子组件内部，使用带有 `get` 和 `set` 的 `computed` 属性来代理 `v-model` 的 `prop` 是最干净、最推荐的模式。它既遵循了单向数据流原则（`set` 中是 `emit` 而不是直接修改），又让模板代码可以方便地使用 `v-model`。
3.  **多个 `v-model`**：Vue 3 允许在一个组件上使用多个 `v-model`，只需为它们命名即可（如 `v-model:firstName`, `v-model:lastName`）。这在构建复杂的表单组件时非常强大。