**在计算机系统中，正负数值，都是使用【补码】来表示和存储的。**

负数的补码，应该怎么求出来呢？  
通常都是说：**先确定符号位、再写出原码、再取反加一，符号位不变。**

但是，在计算机系统中，原码和反码，都是不存在的。  
那么，“取反加一” 怎么实现呢？ 　这岂不就是 “空中楼阁” 吗？

况且，原码和反码中，都有两个零，所以，原码和反码，都是比补码少一个数的。  
因此，就有一个补码，用 “取反加一” 根本就求不出来。  
例如，－128 就没有 8 位的原码和反码，那么，－128 的补码，用 “取反加一” 就求不出来。

**其实，正负数值和补码，是可以直接转换的，根本就不用借助原码和反码。**

按照补码的定义式，可得出正负数值与其 8 位的补码。如下图所示。

![](https://i-blog.csdnimg.cn/blog_migrate/e6f75a0cdfa012b1cbff65b550240f19.png)

图中，并没有列出原码和反码。只有正负数值与其补码。  
仔细观察一下此图，就能看出负数与其补码的转换规律：  
**－1 的补码是 1111 1111，也是 0000 0000 (即 0) 的非。而 0 则是－1 的绝对值减去 1；  
－2 的补码是 1111 1110，也是 0000 0001 (即 1) 的非。而 1 则是－2 的绝对值减去 1；**  
**－3 的补码是 1111 1101，也是 0000 0010 (即 2) 的非。而 2 则是－3 的绝对值减去 1；**  
　**。。。　。。。**  
**－128 的补码是 1000 0000，也是 127 的非。而 127 则是－128 的绝对值减去 1。**

**分析至此，就找到了【负数与其补码的转换规律】：**  
　**先用负数的绝对值（即正数）减一，再全部取反，就可得出负数的补码。**

大家看看，是不是非常方便呢？

**小结：负数转为补码，并不需要使用【根本就不存在的原码和反码】；  
也不需要先学习所谓的【符号位】！  
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－**  
实际上，已知正数，求其相反的数（即负数）的补码，应做的操作，就是 “减一取反”。  
而且，由负数的补码，转换成 “绝对值相同的正数的补码”，也同样是 “减一取反”。  
在计算机中，CPU 就是这么操作的。  
**在计算机中，要做【正负数补码的转换】，就是进行一次【减一取反】的操作。**

___

**如果已知一个补码，怎么求出它所代表的正负数值呢？**

有些人，还是会想到：先（取反加一）求出原码，再填上正负号，就得到了数值。  
呵呵，根本就不用这么麻烦！

况且，－128 根本就没有 8 位的原码和反码，怎么求数值？　根本就求不出来！  
实际上，用补码，直接就可以求出它所代表的数值！

先看看下图：

![](https://i-blog.csdnimg.cn/blog_migrate/4f3de3ad5458c49ef0eb3871c2066c3b.png)

由图可见：**八位补码首位的权，是－128。**  
　如果补码的首位是 0，这个位当然就是 0 了。  
　如果补码的首位是 1，这个位，就是－128 了。  
　首位之后的位，个个都是正数。

**因此，就可总结出如下结论：**

　如果是普通的 8 位二进制数，其各个位的权，如下所示：  
　　　**128**、64、32、16、8、4、2、1。  
　如果是 8 位二进制补码，其首位的权，可就不同了，如下所示：  
　　**－128**、64、32、16、8、4、2、1。

例如，有一个八位的补码，是：1110 0001，  
那么，它代表的十进制数就是：**－128** + 64 + 32 + 1= －31。

再看，另一个八位的补码，是：0110 0001，  
此时，它代表的十进制数则是：**0** + 64 + 32 + 1 = ＋97。

大家看看，仅仅使用【进制转换】，轻轻的一算，不就完事了！

**小结：数值与补码的转换方法，极其简单，根本就用不着原码和反码！**

___

掌握了这个【由补码求数值】的方法之后，再想【由数值求补码】，你一定会有新的思路，在此处，做而论道也就不多说了。

**做而论道的想法就是：原码和反码，都是多余的概念，不需要学习。**

  
**－－本文完－－**