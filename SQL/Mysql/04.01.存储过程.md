# 1. 存储过程的现状

```
问  现在的程序中，为什么不提倡使用存过程？
ChatGPT

虽然存储过程在某些情况下仍然是有用的，但在现代应用程序中，
	对存储过程的使用并不像【过去那样被强烈推崇】。以下是一些原因：

    难以维护： 存储过程通常是在数据库中定义和维护的，这使得它们与应用程序代码分离。这样的分离可能导致代码库的分散，使得维护变得更加困难。

    数据库无关性： 存储过程通常是特定于数据库系统的。如果需要切换到另一个数据库系统，可能需要重新编写存储过程。这违反了数据库无关性的原则。

    ORM 的普及： 对象关系映射（ORM）工具的广泛采用降低了对存储过程的需求。ORM工具使得在应用程序代码中使用面向对象的方式进行数据库交互更加容易，而不需要依赖存储过程。

    性能优化： 现代的数据库管理系统（DBMS）通常提供了强大的查询优化器和索引机制，使得在应用层进行查询优化的需求减少。这减轻了存储过程在性能优化方面的优势。

    分布式系统的复杂性： 在分布式系统中，存储过程可能面临一些复杂性和难以解决的问题，例如事务管理和数据一致性。

    测试难度： 存储过程的测试通常相对困难，因为它们在数据库中执行。相比之下，在应用程序中执行的查询可以更容易地进行单元测试和集成测试。

    代码可读性和维护性： 在应用层直接使用 SQL 查询可以使代码更直观、易读，并且更容易维护。

尽管存储过程在某些特定场景下仍然是有用的，例如复杂的业务逻辑、大量数据的批处理操作等，
  但在许多情况下，【现代应用程序】【更倾向于将数据库访问逻辑】【保留在应用程序层】，
  使用 ORM 工具或直接执行 SQL 查询。这样做有助于提高代码的可读性、维护性，
  并使应用程序更容易适应变化。
```

  

# 2. 大模型，如何写存储过程

1. 利用素材，让大数据模型写一个存储过程看一看

## 2.1. 存储过程入门

（1） 问

```
根据下面菜品表创建的SQL语句，帮我写一个指定菜品ID编号的起售和停售存储过程，要求：1.传入的参数status为1表示起售，0表停售；2.用传出参数retCode和retMsg表示执行结构的返回代码和返回消息，3.状态变更时，记录修改人和修改事件。 附菜品表SQL语句 问：  
下面有菜品表、菜品套餐表、菜品套餐关联表的SQL语句，以SQl语句为素材，
 写一个菜品起售和停售后的存储过程，
要求：1.基于mysql8,；2.菜品停售时，菜品套餐表中关联的套餐一起停售，
  同时修改表中的修改人和修改时间 ，3，菜品起售时，套餐表则不做对应处理 ；
  4.菜品起售和停售通过参数传递，例如1表示起售0表示停售其它表示参数错误，
  5.存储过程启用参数retCodehe和 retMsg，用于约定返回结果，例如retCode=1表示执行正确，
   此时retMsg内容是执行正确，在例如 状态参数=2时，retCod应填入参数错的错误代码，
    retMsg内容是参数无效。 
    
  附菜品套餐表： CREATE TABLE `t_dish`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '菜品名称',
  --  `category_id` bigint(0) NOT NULL COMMENT '菜品分类id',
  `category_id` bigint(0) NULL COMMENT '菜品分类id ,外键测试期间，值允许为空',
  `price` decimal(10, 2) NULL DEFAULT NULL COMMENT '菜品价格',
  `image` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '图片网址',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '描述信息',
  `status` tinyint(0) NULL DEFAULT 1 COMMENT '0 停售 1 起售',
  `sort` int(0) NOT NULL DEFAULT 0 COMMENT '排序',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `create_user` bigint(0) NULL DEFAULT NULL COMMENT '创建人',
  `update_user` bigint(0) NULL DEFAULT NULL COMMENT '修改人',
  `is_deleted` tinyint(0) NOT NULL DEFAULT 0 COMMENT '逻辑删除标记 0正常 1删除',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_t_dish_name`(`name`) USING BTREE,
  INDEX `category_id`(`category_id`) USING BTREE,
  CONSTRAINT `t_dish_ibfk_1` FOREIGN KEY (`category_id`) REFERENCES `t_category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 170 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin COMMENT = '菜品表' ROW_FORMAT = Dynamic;
```

（2） 答

```
DELIMITER //
CREATE PROCEDURE UpdateDishStatus(
  IN dish_id INT, IN status TINYINT, 
  OUT retCode TINYINT, OUT retMsg VARCHAR(255) )
BEGIN
    DECLARE update_time DATETIME;
    DECLARE update_user INT;
    
    SET update_time = NOW();
    SET update_user = 1; -- 假设当前用户ID为1
    
    IF status = 1 THEN
        UPDATE t_dish SET status = 1, update_time = update_time, update_user = update_user WHERE id = dish_id;
    ELSEIF status = 0 THEN
        UPDATE t_dish SET status = 0, update_time = update_time, update_user = update_user WHERE id = dish_id;
    ELSE
        SET retCode = 2;
        SET retMsg = '参数无效';
        LEAVE PROCEDURE;
    END IF;
    
    SET retCode = 1;
    SET retMsg = '执行成功';
END //
DELIMITER ;
```

## 2.2. 添加参数验证

（1） 问

```
为存储过程UpdateDishStatus 添加 参数status取值范围是否为1或者0的 验证，
	有效则执行启停操作，无效则终止并返回,注意继续是mysql8环境
```

（2）答

```
为了验证参数status的取值范围是否为1或者0，可以在存储过程UpdateDishStatus中添加一个条件判断。
	如果status的取值范围无效，则终止并返回错误信息。以下是修改后的存储过程代码：
```

```
DELIMITER //
CREATE PROCEDURE UpdateDishStatus(IN dishId INT, IN status INT)
BEGIN
    IF status NOT IN (0, 1) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Invalid status value. It should be 0 or 1.';
    ELSE
        UPDATE Dishes
        SET Status = status
        WHERE Id = dishId;
    END IF;
END //
DELIMITER ;
```

```
在这个存储过程中，我们首先使用IF语句检查参数@status的值是否为0或1。如果不是，
	我们使用RAISERROR函数抛出一个错误信息，并使用RETURN语句终止存储过程的执行。
  如果@status的值为0或1，则继续执行更新操作。

（内容由讯飞星火AI生成）
```

## 2.3. 来个复杂点，多表关联的

  

```
问：  
下面有菜品表、菜品套餐表、菜品套餐关联表的SQL语句，以SQl语句为素材，
 写一个菜品起售和停售后的存储过程，
要求：1.基于mysql8,；2.菜品停售时，菜品套餐表中关联的套餐一起停售，
  同时修改表中的修改人和修改时间 ，3，菜品起售时，套餐表则不做对应处理 ；
  4.菜品起售和停售通过参数传递，例如1表示起售0表示停售其它表示参数错误，
  5.存储过程启用参数retCodehe和 retMsg，用于约定返回结果，例如retCode=1表示执行正确，
   此时retMsg内容是执行正确，在例如 状态参数=2时，retCod应填入参数错的错误代码，
    retMsg内容是参数无效。 
    
  附菜品套餐表： CREATE TABLE `t_dish`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '菜品名称',
  --  `category_id` bigint(0) NOT NULL COMMENT '菜品分类id',
  `category_id` bigint(0) NULL COMMENT '菜品分类id ,外键测试期间，值允许为空',
  `price` decimal(10, 2) NULL DEFAULT NULL COMMENT '菜品价格',
  `image` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '图片网址',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '描述信息',
  `status` tinyint(0) NULL DEFAULT 1 COMMENT '0 停售 1 起售',
  `sort` int(0) NOT NULL DEFAULT 0 COMMENT '排序',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `create_user` bigint(0) NULL DEFAULT NULL COMMENT '创建人',
  `update_user` bigint(0) NULL DEFAULT NULL COMMENT '修改人',
  `is_deleted` tinyint(0) NOT NULL DEFAULT 0 COMMENT '逻辑删除标记 0正常 1删除',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_t_dish_name`(`name`) USING BTREE,
  INDEX `category_id`(`category_id`) USING BTREE,
  CONSTRAINT `t_dish_ibfk_1` FOREIGN KEY (`category_id`) REFERENCES `t_category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 170 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin COMMENT = '菜品表' ROW_FORMAT = Dynamic;
附套餐表： CREATE TABLE `t_setmeal`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `category_id` bigint(0) NOT NULL COMMENT '菜品分类id',
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '套餐名称',
  `price` decimal(10, 2) NOT NULL COMMENT '套餐价格',
  `status` tinyint(0) NULL DEFAULT 1 COMMENT '售卖状态 0:停售 1:起售',
  `code` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '二维条码',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '描述信息',
  `image` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '图片',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `create_user` bigint(0) NULL DEFAULT NULL COMMENT '创建人',
  `update_user` bigint(0) NULL DEFAULT NULL COMMENT '修改人',
  `is_deleted` tinyint(0) NOT NULL DEFAULT 0 COMMENT '逻辑删除标记 0正常 1删除',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_t_setmeal_name`(`name`) USING BTREE,
  INDEX `category_id`(`category_id`) USING BTREE,
  CONSTRAINT `t_setmeal_ibfk_1` FOREIGN KEY (`category_id`) REFERENCES `t_category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 200 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin COMMENT = '套餐表' ROW_FORMAT = Dynamic;
附套餐菜品表：CREATE TABLE `t_setmeal_dish`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `setmeal_id` bigint(0) NULL DEFAULT NULL COMMENT '套餐id',
  `dish_id` bigint(0) NULL DEFAULT NULL COMMENT '菜品id',
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL COMMENT '菜品名称 （冗余字段）',
  `price` decimal(10, 2) NULL DEFAULT NULL COMMENT '菜品单价（冗余字段）',
  `copies` tinyint(0) NULL DEFAULT 1 COMMENT '菜品份数',
  `sort` int(0) NOT NULL DEFAULT 0 COMMENT '排序',
  `create_time` datetime(0) NOT NULL COMMENT '创建时间',
  `update_time` datetime(0) NOT NULL COMMENT '更新时间',
  `create_user` bigint(0) NOT NULL COMMENT '创建人',
  `update_user` bigint(0) NOT NULL COMMENT '修改人',
  --  套餐中的菜品不能使用逻辑删除，必须物理删除
  -- `is_deleted` tinyint NOT NULL DEFAULT 0 COMMENT '逻辑删除标记 0正常 1删除',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `setmeal_id`(`setmeal_id`) USING BTREE,
  INDEX `dish_id`(`dish_id`) USING BTREE,
  CONSTRAINT `t_setmeal_dish_ibfk_1` FOREIGN KEY (`setmeal_id`) REFERENCES `t_setmeal` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `t_setmeal_dish_ibfk_2` FOREIGN KEY (`dish_id`) REFERENCES `t_dish` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 101 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin COMMENT = '套餐菜品关系' ROW_FORMAT = Dynamic;
```

## 2.4. 来自ChatGPT的回答

（1）

```
以下是一个基于给定要求的菜品起售和停售的存储过程示例。
请注意，为了方便理解，我将存储过程拆分为多个步骤，并在过程中添加了一些注释。
```

（2）

```
DELIMITER //

CREATE PROCEDURE UpdateDishStatus(
  IN dishIdParam INT,
  IN statusParam INT,
  OUT retCode INT,
  OUT retMsg VARCHAR(255)
)
BEGIN
    DECLARE vSetmealId INT default NULL;
    
    -- 初始化返回值
    SET retCode = 0;
    SET retMsg = '参数无效';

    -- 检查参数的有效性
    IF statusParam NOT IN (0, 1) THEN
        SET retCode = 2;
        SET retMsg = '参数无效';
        --  抛出异常 
        LEAVE;
    END IF;

    -- 开始事务
    START TRANSACTION;

    -- 更新菜品状态
    UPDATE t_dish
    SET status = statusParam,
        update_user = CURRENT_USER(),
        update_time = NOW()
    WHERE id = dishIdParam;

    -- 获取关联的套餐ID
    SELECT setmeal_id INTO vSetmealId
    FROM t_setmeal_dish
    WHERE dish_id = dishIdParam
    LIMIT 1;

    -- 如果有关联套餐，同时更新套餐状态
    IF setmealId IS NOT NULL THEN
        UPDATE t_setmeal
        SET status = statusParam,
            update_user = CURRENT_USER(),
            update_time = NOW()
        WHERE id = setmealId;
    END IF;

    -- 提交事务
    COMMIT;

    -- 更新返回值
    SET retCode = 1;
    SET retMsg = '执行正确';
    
END //

DELIMITER ;
```

（3）

```
这个存储过程接受三个输入参数：dishIdParam 表示菜品ID，statusParam 表示菜品状态（1表示起售，0表示停售），retCode 和 retMsg 作为输出参数，表示执行结果的代码和消息。

存储过程首先检查输入参数的有效性，如果参数无效，则设置返回值为参数无效。然后，它开始一个事务，并根据输入参数更新菜品的状态。接着，它检查是否有关联的套餐，如果有，则同时更新套餐的状态。最后，提交事务，并设置返回值为执行正确。

请根据实际需要调整存储过程，以适应特定的业务逻辑和数据库结构。
```

## 2.5. 来自星火的回答

```
DELIMITER $$
CREATE PROCEDURE UpdateDishStatus(IN status TINYINT, IN retCode TINYINT, IN retMsg VARCHAR(255))
BEGIN
    IF status = 1 THEN
        UPDATE t_dish SET status = 1, update_user = NULL, update_time = NOW() WHERE status = 0;
    ELSEIF status = 0 THEN
        UPDATE t_dish SET status = 0, update_user = NULL, update_time = NOW();
        UPDATE t_setmeal_dish SET status = 0, update_user = NULL, update_time = NOW() WHERE dish_id IN (SELECT id FROM t_dish WHERE status = 0);
    ELSE
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = retMsg;
    END IF;
    SET retCode = 1;
    SET retMsg = '执行成功';
END$$
DELIMITER ;
```

# 3. 练练手，我的第一个存储过程

## 3.1. 创建函数

（1）入口

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701044735995-9943853d-3485-4166-b61e-4890a3b1c61e.png)

（2）添加参数

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701045686027-c5556a7f-d9e6-4eaf-8f04-fad2b96d1d1c.png)

## 3.2. 自动生成的脚本

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_updateDishStatus_1`(
    IN `pDishId` BIGINT,
    IN `pStatus` TINYINT,
    IN `pUpdateUser` BIGINT,
    OUT `retCode` INT,
    OUT `retMsg` VARCHAR(255)
)
BEGIN	
    #Routine body goes here...  
END
```

## 3.3. 整理思路

```
#整理思路 
	# 1. 检查参数有效性，如果无效则抛出异常
	# 2. 根据指定的菜品ID更新菜品表中对应菜品的状态，并留痕
	# 3. 如果是下架，则带套餐表中包含此菜品的套餐也下架
	# 3.1 到套餐菜品表中，找出所有包含本菜品的套餐ID，
	# 3.2 根据找到的套餐ID，到套餐表表中，停售对应的套餐
	# 4.返回正确的返回值 
```

## 3.4. 添加参数验证处理

(1) 界面截图

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701046110427-eb2c645c-9eaf-4066-8f0b-4588aeb3f1be.png)

（2） 附，源代码

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_updateDishStatus_1`(
    IN `pDishId` BIGINT,
    IN `pStatus` TINYINT,
    IN `pUpdateUser` BIGINT,
    OUT `retCode` INT,
    OUT `retMsg` VARCHAR(255)
)
BEGIN	
    -- 初始化返回值
    SET retCode = 100, retMsg = '未知错误';
  	
    -- 调试，观察参数的值
    select '测试1，参数：', pDishId ,pStatus, pUpdateUser, retCode, retMsg;
    
    -- 检查参数的有效性
    IF status NOT IN (0, 1) or  dishId IS NULL THEN
			SET retCode = 11, retMsg = '参数无效';
         --  LEAVE p_updateDishStatus_1; -- 标签名和存储过程名一致
   
      SIGNAL SQLSTATE '45000'
         SET MESSAGE_TEXT = retMsg;
    END IF;
    
    --  业务处理   
    select '测试2,进入到业务处理环节';
		
		-- 设置执行成功时的返回值
		SET retCode = 1, retMsg = 'OK';    
END
```

## 3.5. 第一次，运行

（1） 入口，并填入参数

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701046225493-eae203f6-5ce8-4176-8ee7-c1b308abf37f.png)

（2）发现：测试2，没有执行

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701046472083-c387fb39-b415-4790-bcc3-584d502cfb79.png)

（3）查找错误

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701046426544-69f40fcc-6896-47e5-b91e-e2f2f006373f.png)

（4）修改代码

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701046723179-c275535c-03c9-4d57-9d25-654a53b1cf27.png)

（5）附，修改后的代码

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_updateDishStatus_1`(
    IN `pDishId` BIGINT,
    IN `pStatus` TINYINT,
    IN `pUpdateUser` BIGINT,
    OUT `retCode` INT,
    OUT `retMsg` VARCHAR(255)
)
BEGIN	
    -- 初始化返回值
    SET retCode = 100, retMsg = '未知错误';
  	
    -- 调试，观察参数的值
    select '测试1，参数：', pDishId ,pStatus, pUpdateUser, retCode, retMsg;
    
    -- 检查参数的有效性
    IF pStatus NOT IN (0, 1) or  pDishId IS NULL THEN
			SET retCode = 11, retMsg = '参数无效';
      --  LEAVE p_updateDishStatus_1; -- 标签名和存储过程名一致
      SIGNAL SQLSTATE '45000'
         SET MESSAGE_TEXT = retMsg;
    END IF;
    
    --  业务处理   
    select '测试2,进入到业务处理环节';
		
		-- 设置执行成功时的返回值
		SET retCode = 1, retMsg = 'OK';    
END
```

（6）跟预测一致，两个调试输出和一个返回结果

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701046897453-df6fc4dd-643b-4e34-89c5-ede4ba8ac952.png)

## 3.6. 添加业务处理，常规语句

（1）添加变量

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701048044976-99b51284-85f3-4ad1-89a0-0cff52e9a2bf.png)

（2）添加业务处理

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701048133360-26671806-ebbf-4793-a418-136afc30316d.png)

（3） 附，源代码

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_updateDishStatus_1`(
    IN `pDishId` BIGINT,
    IN `pStatus` TINYINT,
    IN `pUpdateUser` BIGINT,
    OUT `retCode` INT,
    OUT `retMsg` VARCHAR(255)
)

BEGIN	
		
		-- 提前声明后面代码中需要使用的变量 
   	DECLARE vSetmealId INT;
		
    -- 初始化返回值
    SET retCode = 100, retMsg = '未知错误';
  	
    -- 调试，观察参数的值
    select '测试1，参数：', pDishId ,pStatus, pUpdateUser, retCode, retMsg;
    
    -- 检查参数的有效性
    IF pStatus NOT IN (0, 1) or  pDishId IS NULL THEN
			SET retCode = 11, retMsg = '参数无效';
      SIGNAL SQLSTATE '45000'
         SET MESSAGE_TEXT = retMsg;
    END IF;
    
    
    -- 无论起售还是停售，都需要更新菜品表中指定ID的状态为新状态		
    UPDATE t_dish
			SET status = pStatus,	update_user = pUpdateUser,update_time = NOW()
			WHERE id = pDishId;
		SELECT "调试2，菜品表更新条数：",ROW_COUNT();
		
		-- 如果是停售，则先到套餐菜品表中查出本菜品ID对应的套餐ID，然后停售对应的套餐
		if pStatus=0 then
			BEGIN
				-- 获取关联的套餐ID
				SELECT setmeal_id INTO vSetmealId
					FROM t_setmeal_dish
					WHERE dish_id =  pDishId
					LIMIT 1;
				
				SELECT '调试，套餐ID:', vSetmealId ;
				
			  -- 如果有关联套餐，同时更新套餐状态
				IF vSetmealId IS NOT NULL THEN
						UPDATE t_setmeal
							SET status = pStatus,	update_user = pUpdateUser,	update_time = NOW()
							WHERE id = vSetmealId;
				END IF;
			END;
			
		END IF;
		
		-- 设置执行成功时的返回值
		SET retCode = 1, retMsg = 'OK';    
END
```

（4）运行，OK

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701048394513-7c0c2250-4a32-4185-b3de-ddfa8720e88f.png)

## 3.7. 附，Leave的用法

```
1. leave语句的基本概念

leave语句是MySQL中一种封装的跳出多层循环的语句。例如在MySQL脚本中嵌套循环时，通过使用leave语句可以在任意一层循环中跳出所有循环，停止后续的迭代操作。

2. leave语句的语法结构

leave语句的语法结构如下：

LEAVE label;

其中的label是一个用户定义的标识符，它必须由唯一的字符或数字组成，并且必须在此之前已经定义过。
3. leave语句的使用

在MySQL中，leave语句可以使用在循环语句中，因为这是我们必须掌握的指针控制结构之一。以下是一个简单的示例：

BEGIN

DECLARE x INT;

SET x=1;

loop1: WHILE x

SET x=x+1;

loop2: WHILE x

SET x=x+1;

IF x=13 THEN

LEAVE loop2;

END IF;

END WHILE loop2;

END WHILE loop1;

END;

在上面的示例中，我们定义了两个循环，其中第二个循环中if语句会在x等于13时执行leave语句，跳出循环。

4. leave语句的注意事项

– 在使用leave语句时，必须在循环的开头使用label，以便随时退出整个循环。

– 在使用leave语句时，必须注意在语句中使用正确的label，否则将引发错误。

– 在使用leave语句时，必须在标识符label的末尾添加冒号。
```

1. 修改了代码： 第8行、24行

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_updateDishStatus_1`(
    IN `pDishId` BIGINT,
    IN `pStatus` TINYINT,
    IN `pUpdateUser` BIGINT,
    OUT `retCode` INT,
    OUT `retMsg` VARCHAR(255)
)
mainBlock:   -- 主块标签,在第一个BEGIN之前
BEGIN	
		
		-- 提前声明后面代码中需要使用的变量 
   	DECLARE vSetmealId INT;
		
    -- 初始化返回值
    SET retCode = 100, retMsg = '未知错误';
  	
    -- 调试，观察参数的值
    select '测试1，参数：', pDishId ,pStatus, pUpdateUser, retCode, retMsg;
		
    
    -- 检查参数的有效性
    IF pStatus NOT IN (0, 1) or  pDishId IS NULL THEN
			SET retCode = 11, retMsg = '参数无效';
			LEAVE mainBlock;   #跳出标记为mainBlock的代码块
			# return  只能用于function 
			
     -- SIGNAL SQLSTATE '45000'
     --    SET MESSAGE_TEXT = retMsg;
    END IF;
    
    
    -- 无论起售还是停售，都需要更新菜品表中指定ID的状态为新状态		
    UPDATE t_dish
			SET status = pStatus,	update_user = pUpdateUser,update_time = NOW()
			WHERE id = pDishId;
		SELECT "调试2，菜品表更新条数：",ROW_COUNT();
		
		-- 如果是停售，则先到套餐菜品表中查出本菜品ID对应的套餐ID，然后停售对应的套餐
		if pStatus=0 then
			BEGIN
				-- 获取关联的套餐ID
				SELECT setmeal_id INTO vSetmealId
					FROM t_setmeal_dish
					WHERE dish_id =  pDishId
					LIMIT 1;
				
				SELECT '调试，套餐ID:', vSetmealId ;
				
			  -- 如果有关联套餐，同时更新套餐状态
				IF vSetmealId IS NOT NULL THEN
						UPDATE t_setmeal
							SET status = pStatus,	update_user = pUpdateUser,	update_time = NOW()
							WHERE id = vSetmealId;
				END IF;
			END;
			
		END IF;
		
		
		-- 设置执行成功时的返回值
		SET retCode = 1, retMsg = 'OK';    
END
```

# 4. 改用子查询实现起售停售功能

## 4.1. 新创建存储过程p_updateDishStatus_2

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_updateDishStatus_2`(
    IN `pDishId` BIGINT,
    IN `pStatus` TINYINT,
    IN `pUpdateUser` BIGINT,
    OUT `retCode` INT,
    OUT `retMsg` VARCHAR(255)
)
BEGIN	
		
		-- 初始化返回值
    SET retCode = 100, retMsg = '未知错误';
  	
    -- 调试，观察参数的值
    select '测试1，参数：', pDishId ,pStatus, pUpdateUser, retCode, retMsg;
    
    -- 检查参数的有效性
    IF pStatus NOT IN (0, 1) or  pDishId IS NULL THEN
			SET retCode = 11, retMsg = '参数无效';
      SIGNAL SQLSTATE '45000'
         SET MESSAGE_TEXT = retMsg;
    END IF;
    

		 -- 无论起售还是停售，都需要更新菜品表中指定ID的状态为新状态		
    UPDATE t_dish
			SET status = pStatus,	update_user = pUpdateUser,update_time = NOW()
			WHERE id = pDishId;
		SELECT "调试2，菜品表更新条数：",ROW_COUNT();
		
		-- 如果是停售，则先到套餐菜品表中查出本菜品ID对应的套餐ID，然后停售对应的套餐
		if pStatus=0 then
			UPDATE t_setmeal
				SET status = pStatus,update_user = pUpdateUser,	update_time = NOW()
				WHERE id in ( select DISTINCT setmeal_id 
												FROM t_setmeal_dish
												WHERE dish_id = pDishId );	
			 -- 子查询中不能使用limit 改成 DISTINCT
			SELECT "调试3，套餐表更新的行数：",ROW_COUNT();
				
		END IF;
		
		-- 设置执行成功时的返回值
		SET retCode = 1, retMsg = 'OK';    
END
```

## 4.2. 运行

（1）这儿也有个入口

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701048981692-78851a63-47af-404b-927b-100175f9b900.png)

（2）填入停售的参数

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701049100862-a9d1ca41-0992-4884-af94-a286aecbdfa9.png)

（3）三条调试输出和一个运行输出

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701049173814-9e378609-32de-4f85-8644-49d8f3a9ab30.png)

# 5. 巩固练习1.添加购物车

## 5.1. 创建过程名

（1）入口

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1700992152434-1ffa6f2f-1a8a-429e-94f9-1b63f3e66cd8.png)

（2）参数

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701004902485-4f36cd64-8ac5-49e3-8354-0fbe36f52cdb.png)

（3）过程名

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_addToShopCart_01`(
	IN `pUserId` bigint,
	IN `pDishId` bigint,IN `pDishQuantity` tinyint,
	IN `pSetmealId` bigint,IN `pSetmealQuantity` tinyint,
	INOUT `pId` bigint,
	OUT `retCode` int,OUT `retMsg` varchar(255) )
BEGIN
	#Routine body goes here...

END;
```

## 5.2. 流程图

![](https://cdn.nlark.com/yuque/0/2023/jpeg/1727964/1701093976664-ea245295-4ec4-432b-a63f-1a1ea734843f.jpeg)

（3）补充基础框架

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_addToShopCart_01`(
	IN `pUserId` bigint,
	IN `pDishId` bigint,IN `pDishQuantity` tinyint,
	IN `pSetmealId` bigint,IN `pSetmealQuantity` tinyint,
	INOUT `pId` bigint,
	OUT `retCode` int,OUT `retMsg` varchar(255) )
BEGIN
  -- 声明后续需要使用的变量
  DECLARE vPrice,vAmount DECIMAL(10,2);
	DECLARE vQuantity int;
	-- 初始化返回值
  SET retCode = 100, retMsg = '未知错误';

  -- 检查参数的有效性：用户ID，菜品和套餐必需二选一 
  IF pUserId IS NULL or ( pDishId IS NULL  and  pSetmealId IS NULL ) 
     or (pDishId  IS NOT NULL and pDishQuantity IS NULL	)  		  		 
     or (pSetmealId IS NOT NULL and pSetmealQuantity IS NULL	)  THEN
		SET retCode = 11, retMsg = '参数无效';
		SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = retMsg;
  END IF;
	
	-- 如果菜品ID不为空则为菜品，否则为套餐；
	if pDishId  IS NOT NULL THEN
   BEGIN
			-- 根据菜品ID处理
		END;
  else 	
		BEGIN
			-- 根据套餐ID处理
		END;
	END IF;

END
```

## 5.3. 梳理添加菜品到购物车的逻辑关系

1. 第27行到43行

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_addToShopCart_01`(
	IN `pUserId` bigint,
	IN `pDishId` bigint,IN `pDishQuantity` tinyint,
	IN `pSetmealId` bigint,IN `pSetmealQuantity` tinyint,
	INOUT `pId` bigint,
	OUT `retCode` int,OUT `retMsg` varchar(255) )
BEGIN
  -- 声明后续需要使用的变量
  DECLARE vPrice,vAmount DECIMAL(10,2);
	DECLARE vQuantity int;
	-- 初始化返回值
  SET retCode = 100, retMsg = '未知错误';

  -- 检查参数的有效性：用户ID，菜品和套餐必需二选一 
  IF pUserId IS NULL or ( pDishId IS NULL  and  pSetmealId IS NULL ) 
     or (pDishId  IS NOT NULL and pDishQuantity IS NULL	)  		  		 
     or (pSetmealId IS NOT NULL and pSetmealQuantity IS NULL	)  THEN
		SET retCode = 11, retMsg = '参数无效';
		SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = retMsg;
  END IF;
		
	-- 如果菜品不为空则为菜品，否则为套餐；
	if pDishId  IS NOT NULL THEN
		BEGIN      
      -- 先查询当前购物车内是否存在指定pDishId的菜品，根据查询结果执行下述操作： 
      --   如果没有则新插入一条，否则数量减到位零则删除，再否则增减数量      
			select id,price,quantity,amount into pId,vPrice,vQuantity,vAmount 
				from t_shopping_cart
				where user_id=pUserId and dish_id=pDishId;
			SELECT "调试,1:",pId,vPrice,vQuantity,vAmount; 	
			
      -- 如果ID为空则是新添加一条		
			if pId is null THEN
				BEGIN
					-- 新添加一条
				END;
 			ELSEIF (vQuantity + pDishQuantity = 0 ) THEN
      select 1;
 				-- 删除操作
			ELSE
      select 1;
				-- 增减数量操作
			end if;			
		END;
	else 	
		BEGIN
			-- 根据套餐ID处理
		END;
	END IF;
	
	-- 生成正确处理完毕返回信息 
	SET retCode = 1, retMsg = 'OK';
END
```

## 5.4. 填入对应的代码实现

1. 第33行到

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_addToShopCart_01`(
	IN `pUserId` bigint,
	IN `pDishId` bigint,IN `pDishQuantity` tinyint,
	IN `pSetmealId` bigint,IN `pSetmealQuantity` tinyint,
	INOUT `pId` bigint,
	OUT `retCode` int,OUT `retMsg` varchar(255) )
BEGIN
  -- 声明后续需要使用的变量
  DECLARE vPrice,vAmount DECIMAL(10,2);
	DECLARE vQuantity int;
	-- 初始化返回值
  SET retCode = 100, retMsg = '未知错误';

  -- 检查参数的有效性：用户ID，菜品和套餐必需二选一 
  IF pUserId IS NULL or ( pDishId IS NULL  and  pSetmealId IS NULL ) 
     or (pDishId  IS NOT NULL and pDishQuantity IS NULL	)  		  		 
     or (pSetmealId IS NOT NULL and pSetmealQuantity IS NULL	)  THEN
		SET retCode = 11, retMsg = '参数无效';
		SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = retMsg;
  END IF;
	
	
	-- 如果菜品不为空则为菜品，否则为套餐；
	if pDishId  IS NOT NULL THEN
		BEGIN
    	-- 先查询当前购物车内是否存在指定pDishId的菜品，根据查询结果执行下述操作： 
      --   如果没有则新插入一条，否则数量减到位零则删除，再否则增减数量  
			select id,price,quantity,amount into pId,vPrice,vQuantity,vAmount 
				from t_shopping_cart
				where user_id=pUserId and dish_id=pDishId;
			SELECT "调试,1:",pId,vPrice,vQuantity,vAmount; 	
      
			-- 如果ID为空则是新添加一条	
			if pId is null THEN
				BEGIN
					INSERT INTO t_shopping_cart 
						select null, pUserId,pDishId,null,d.name,d.image,'口味:等待合成处理',
							d.price,pDishQuantity,d.price*pDishQuantity,NOW() 
						FROM t_dish d
						where  d.id=pDishId;		
          -- 获取新增行自动增长列的ID，用于返回给调用方
					SELECT LAST_INSERT_ID() into pId;	
					SELECT "调试,2:","插入,pId=",pId;		
				END;
 			ELSEIF (vQuantity + pDishQuantity = 0 ) THEN
 				-- 删除操作
 				DELETE FROM t_shopping_cart where user_id=pUserId and dish_id=pDishId;
			ELSE
				-- 增减数量操作
				UPDATE t_shopping_cart 
					set amount=price*(quantity+pDishQuantity),quantity=quantity+pDishQuantity   
					where user_id=pUserId and dish_id=pDishId;				
			end if;			
		END;
	else 	
		BEGIN
			-- 根据套餐ID处理
		END;
	END IF;
	
	-- 生成正确处理完毕返回信息 
	SET retCode = 1, retMsg = 'OK';
END
```

## 5.5. 测试

（1）

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701005308882-e02b8601-998c-419b-9e62-2eae53c9ab09.png)

（2）

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701005372736-c3c06a77-ef02-4002-90d9-7b0b400d71ce.png)

（3）

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1701005393088-eaf9396d-ae44-4d32-889c-a7468ade6c7c.png)

## 5.6. 根据菜品代码，完成套餐代码