# 1. 事务的概念

## 1.1. 概念

问： 数据库中的事务的具体解释是什么？

```
答 ： ChatGPT 
在数据库管理系统中，事务（Transaction）是一组数据库操作单元，
	被视为一个不可分割的工作单位。事务中的操作要么全部执行成功，
  	要么全部失败回滚，保持数据库的一致性和完整性。
    事务具有四个关键属性，通常被称为 ACID 属性：

【原子性】（Atomicity）： 事务被视为一个原子操作单元，
	要么全部执行成功，要么全部失败回滚。
  如果在事务执行过程中发生错误，系统会将数据库回滚到事务开始前的状态，
  以保持数据的一致性。

【一致性】（Consistency）： 事务执行前后，数据库必须保持一致状态。
	这意味着事务执行过程中的任何中间状态都不能暴露给其他事务。
  只有在事务成功完成后，数据库才会进入下一个一致的状态。

【隔离性】（Isolation）： 多个事务可以并发执行，
	但每个事务的操作对其他事务是隔离的，一个事务的执行不应影响其他事务的执行。
  这确保了并发执行时的数据完整性。

【持久性】（Durability）： 一旦事务成功提交，其修改将永久保存在数据库中，
即使系统发生故障或重启，数据库也能够恢复到事务提交后的状态。

```

```
事务通常由以下几个关键步骤组成：

开始事务（Begin Transaction）： 标识事务的开始。
执行操作（Execute Operations）： 包括插入、更新、删除等数据库操作。
提交事务（Commit Transaction）： 将事务的操作永久保存到数据库。
回滚事务（Rollback Transaction）： 在事务执行过程中发生错误时，
撤销事务中的所有操作，将数据库回滚到事务开始前的状态。

数据库的事务支持是确保数据库系统在并发访问和故障发生时
	能够保持数据的一致性和完整性的重要机制。
```

## 1.2. 口诀

```
事务中的操作要么全部执行成功，要么全部失败回滚
```

## 1.3. 显式事务和隐式事务

```
问 MySQL中的隐式事务和显式事务的区别
答：星火模型 
MySQL中的事务主要可以分为隐式事务和显式事务。
	隐式事务没有明显的开启和结束标记，比如当我们执行insert、delete、update、select等语句时，
  数据库会自动开启事务、提交或回滚事务。这种自动的事务管理是由变量autocommit控制的。

相反，显式事务具有明显的开始和结束标记，它们适用于需要进行一组操作，
	并在所有操作完成后手动提交或回滚事务的场景。
```

# 2. 事务演示

## 2.1. 准备工作

```
-- 第16周数据库 
DROP DATABASE IF EXISTS Week16;

-- 创建数据库
CREATE DATABASE Week16 CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;


-- 切换到新创建的数据库
USE Week16;

DROP TABLE IF EXISTS `t_buyer`;
CREATE TABLE t_buyer (
    buyer_name VARCHAR(20),
    buyer_quantity int ,
    buyer_money DECIMAL(10, 2)
);
INSERT into t_buyer value("张三",0,9999.99);

DROP TABLE IF EXISTS `t_seller`;
CREATE TABLE t_seller (
    seller_name VARCHAR(20),
    seller_quantity int ,
    seller_money DECIMAL(10, 2)
);
INSERT into t_seller value("李四",5555,0.00);
```

## 2.2. 都成功的演示

（1）存储过程

```
DROP PROCEDURE IF EXISTS p_transaction_ok1;
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_transaction_ok1`()
BEGIN
	  DECLARE  pQuantity INT  DEFAULT  5;
		DECLARE  pMoeny DECIMAL(10, 2)  DEFAULT  10.00;
    -- 开启事务
    START TRANSACTION;

    -- 更新买方余额
    UPDATE t_buyer
				SET buyer_quantity = buyer_quantity + pQuantity,
						buyer_money=buyer_money - pMoeny 
				WHERE buyer_name =  "张三";

    -- 更新卖方余额
     UPDATE t_seller
				SET seller_quantity = seller_quantity - pQuantity,
						seller_money=seller_money + pMoeny 
				WHERE seller_name = "李四";

    -- 提交事务
    COMMIT;
END;
```

（2）执行

```
# 对比
select * from  t_buyer 
    UNION ALL 
    select * from t_seller;
    
CALL p_transaction_ok1;

select * from  t_buyer 
    UNION ALL 
    select * from t_seller;
```

  

（3）截图

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703145100916-e975fd39-2639-4dfe-a2f4-674103674346.png)![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703145117820-ee3eecf3-5342-415b-92f0-2b9931600c67.png)

## 2.3. 部分成功部分失败的演示

（1）存储过程

```

DROP PROCEDURE IF EXISTS p_transaction_error;
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_transaction_error`()
BEGIN
	  DECLARE  pQuantity INT  DEFAULT  5;
		DECLARE  pMoeny DECIMAL(10, 2)  DEFAULT  10.00;
    --  开启事务 利用数据库自带的隐式事务进行事务处理 
    -- START TRANSACTION;

    -- 更新买方余额， 利用隐式事务，自动提交买方数据
    UPDATE t_buyer
				SET buyer_quantity = buyer_quantity + pQuantity,
						buyer_money=buyer_money - pMoeny 
				WHERE buyer_name =  "张三";
    -- 提交事务
    --  COMMIT;

    -- 更新卖方余额 ，发生除数为零的异常，卖方数据不会更新
     UPDATE t_seller
				SET seller_quantity = seller_quantity - pQuantity,
						seller_money=seller_money + pMoeny /0
				WHERE seller_name = "李四";
   # 整个买和卖的交易，买正常卖异常，导致整个交易的数据是异常的
   
END;
```

（2）演示

```

-- 第1批执行 
select * from  t_buyer 
    UNION ALL 
    select * from t_seller;
CALL p_transaction_error;

-- -------------------------------
-- 第2批执行 
select * from  t_buyer 
    UNION ALL 
    select * from t_seller;
```

（3）截图

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703145360629-48c3720f-96a5-4bb8-a6be-8bec19937c46.png)

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703145373893-863eaf36-7e8d-42bd-b48c-3ad611d798f1.png)

## 2.4. 提交或者回滚的演示

（1）存储过程

```
CREATE DEFINER=`root`@`localhost` PROCEDURE `p_transaction_ok2`(in ok int)
BEGIN
	  DECLARE  pQuantity INT  DEFAULT  5;
		DECLARE  pMoeny DECIMAL(10, 2)  DEFAULT  10.00;
		
			select   '交易前', b.* from  t_buyer  b  UNION ALL 
				select '交易前', s.* from t_seller s;
		
    -- 开启事务
    START TRANSACTION;

    -- 更新买方余额
    UPDATE t_buyer
				SET buyer_quantity = buyer_quantity + pQuantity,
						buyer_money=buyer_money - pMoeny 
				WHERE buyer_name =  "张三";	
		
		
    -- 更新卖方余额
     UPDATE t_seller
				SET seller_quantity = seller_quantity - pQuantity,
						seller_money=seller_money + pMoeny 
				WHERE seller_name = "李四";
		
		select   '交易更行完成，等待审批 ', b.* from  t_buyer  b UNION ALL 
			select '交易更行完成，等待审批 ', s.* from t_seller s;
			
    if(ok =1) then
        -- 提交事务
        COMMIT;
    else
        -- 回滚事务
        ROLLBACK;	
    end if;
		
		select '交易结束', b.* from  t_buyer  b 	UNION ALL 
			select '交易结束', s.* from t_seller s;
END
```

（2）演示1，都成功，提交

```
-- 第1批执行 
CALL p_transaction_ok2(1);
```

截图

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703145896378-611b8714-1437-4eb4-aeb6-73d15f532b6e.png)

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703158406658-4afbacb1-2114-41fb-8800-508834c25505.png)

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703158425309-4d71c5f2-aea9-469d-a886-d19382e1d53e.png)

（3）演示2，都失败，回滚

```
-- 第2批执行 
CALL p_transaction_ok2(0);
```

截图

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703145907927-f1007528-dd91-4274-be61-1e8255aaabb5.png)

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703145916774-3fe1f020-4e64-46e3-8d6a-8fd2e8b35c04.png)

![](https://cdn.nlark.com/yuque/0/2023/png/40581665/1703145923872-9029f000-2485-4326-ae4a-5cd7147513c1.png)

# 3. 扩展延伸

## 3.1. 事务的隔离级别和读写权限

（1） 问

```
START TRANSACTION 后面的参数有哪几个？分别是什么意思
```

（2）答 ChatGPT

```
在MySQL中，START TRANSACTION语句用于开始一个事务。在标准SQL中，START TRANSACTION语句通常不带参数，但在MySQL中，它支持一些选项，可以在START TRANSACTION后面添加。

以下是MySQL中START TRANSACTION后面的可选参数：

    ISOLATION LEVEL：【设置事务的隔离级别】。可选的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。例如：

    sql

START TRANSACTION ISOLATION LEVEL READ COMMITTED;

这将设置事务的隔离级别为读已提交。

READ WRITE | READ ONLY：【指定事务的读写权限】。READ WRITE表示读写事务（默认），READ ONLY表示只读事务。例如：

sql

    START TRANSACTION READ ONLY;

    这将开始一个只读事务。

这两个参数都是可选的，如果没有提供，则使用默认的隔离级别和读写权限。在实际应用中，通常不需要显式地指定这些参数，因为MySQL有默认的隔离级别和读写权限。

请注意，使用START TRANSACTION语句的时候，需要搭配COMMIT或ROLLBACK语句来结束事务。
```

## 3.2. 脏读、脏写、幻读

（1） 问

```
事务隔离级别相关的三个问题，脏读、脏写、幻读分别是指什么？
```

（2）答

```
脏读（Dirty Read）、脏写（Dirty Write）、幻读（Phantom Read）是与事务隔离级别相关的三个问题，它们描述了在并发事务中可能出现的一些数据一致性问题：

    脏读（Dirty Read）：
        定义： 当一个事务读取了另一个事务未提交的数据时，就发生了脏读。
        示例： 事务A读取了事务B正在修改但还未提交的数据，如果事务B在后续回滚了，那么事务A读到的数据就是无效的。

    脏写（Dirty Write）：
        定义： 当一个事务覆盖了另一个事务已经提交的数据时，就发生了脏写。
        示例： 事务A修改了某个数据，但还未提交，此时事务B修改了相同的数据并提交，然后事务A回滚。这样事务B的修改就是基于事务A的未提交数据的，称为脏写。

    幻读（Phantom Read）：
        定义： 当一个事务在读取了一组数据后，另一个事务插入或删除了一条数据，导致第一个事务在后续读取时发现多了或少了一些数据，就发生了幻读。
        示例： 事务A查询某个范围内的数据，事务B在这个范围内插入了一条新数据，当事务A再次查询时，会发现多了一条数据，即发生了幻读。

这些问题是由并发事务可能导致的数据不一致性情况引起的。
	不同的事务隔离级别（如READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE）
  会影响这些问题的发生概率。在更高的隔离级别下，
  系统通常会采取更多的措施来防止这些问题，但这可能会增加资源消耗和性能开销。
```

## 3.3. 锁

（1）问

```
数据库中的锁是什么意思，主要有哪几种？
```

（2） 答 ChatGPT

```
在数据库中，锁是一种机制，用于控制并发访问数据库中共享资源的方式，
	以维护数据的一致性和完整性。当多个事务同时访问数据库时，
	锁可以防止它们之间发生冲突，确保数据的正确性。

主要的数据库锁包括：

    共享锁（Shared Lock）：
        特点： 多个事务可以同时持有共享锁，用于读取共享资源。
        作用： 当一个事务持有共享锁时，其他事务可以继续持有共享锁，但不能持有排它锁。
        示例： 多个事务可以同时读取同一数据，不会互斥。

    排它锁（Exclusive Lock）：
        特点： 一个事务持有排它锁时，其他事务无法同时持有任何类型的锁（共享锁或排它锁）。
        作用： 主要用于写操作，防止其他事务读取或写入相同的资源。
        示例： 当一个事务更新某个数据时，其他事务无法同时更新或读取该数据。

    意向锁（Intention Lock）：
        特点： 表示事务对表中某个范围的数据项或页的意图，它并不直接用于控制资源的访问，而是用于协调不同层次的锁。
        作用： 在获取锁之前，事务可以先获取意向锁，以表明它对资源的意图，避免冲突。
        类型： 意向共享锁（IS，Intention Share）和意向排它锁（IX，Intention Exclusive）。

    行级锁（Row-level Lock）：
        特点： 锁定数据表中的某一行，用于控制对该行数据的访问。
        作用： 可以精确地控制事务对数据的访问，减小锁的粒度，提高并发性。
        示例： 当一个事务修改某一行数据时，可以对该行应用行级锁，防止其他事务同时修改同一行数据。

    表级锁（Table-level Lock）：
        特点： 锁定整个数据表，限制对整个表的访问。
        作用： 适用于对整个表的大量数据进行批量操作的场景。
        示例： 当一个事务需要对整个表进行更新或删除时，可以对整个表应用表级锁。

    间隙锁（Gap Lock）：
        特点： 用于锁定一个范围的键之间的间隙，防止其他事务插入新的键值以确保数据一致性。
        作用： 防止幻读的发生，确保在事务范围内的数据完整性。
        示例： 当事务A读取某一范围内的数据时，可以对该范围应用间隙锁，防止其他事务插入新的数据。

这些锁的选择取决于应用的需求和数据库管理系统的支持。不同的数据库管理系统可能实现了更多种类的锁，并提供了不同的锁粒度和隔离级别。
```

# 4. 用户管理

## 4.1. 到大模型中查阅，MYSQL中的用户是全局的还是某个数据库实例的

（1） 问

```
mysql中 新建的用户，默认是全局的还是某个数据库实例的用户
```

（2）答 ChatGPT

```
在MySQL中，新建的用户可以是全局的，也可以是某个数据库实例的用户，这取决于用户的创建方式和授予权限的范围。

    全局用户：
        如果在创建用户时使用了CREATE USER语句，而没有在其中指定关联的数据库，则该用户将是全局用户，具有跨所有数据库实例的权限。
        示例：

        sql

    CREATE USER 'username'@'host' IDENTIFIED BY 'password';

    上述语句中，'username'@'host' 是全局用户，因为没有指定具体的数据库。

数据库实例用户：

    如果在创建用户时明确指定了关联的数据库，并且通过GRANT语句授予了特定数据库的权限，则该用户将是与特定数据库实例相关的用户。
    示例：

    sql

        CREATE USER 'username'@'host' IDENTIFIED BY 'password';
        GRANT SELECT, INSERT ON database_name.* TO 'username'@'host';

        上述语句中，'username'@'host' 用户被授予了对 database_name 数据库中的表的特定权限，因此是数据库实例用户。

需要注意的是，在MySQL中，用户的权限管理是相当灵活的，
可以针对不同的数据库、表和操作进行详细的授权。
因此，用户可以是全局用户，也可以是针对特定数据库实例的用户，
具体取决于管理员在创建用户和授予权限时的操作。
```

（3）继续问

```
上面示例中的代码CREATE USER 'username'@'host' IDENTIFIED BY 'password';
GRANT SELECT, INSERT ON database_name.* TO 'username'@'host';
，不是两条独立的SQL语句吗？ 
本质上创建的用户还是全局用户，	只不过是没有权限而已
```

（4）继续答

```
您是正确的，我失漏了一些关键点。感谢您的指正。

在MySQL中，CREATE USER 和 GRANT 两个语句可以分开执行，它们确实是两条独立的 SQL 语句。当使用 CREATE USER 语句创建用户时，如果没有使用 GRANT 语句为用户授予权限，那么这个用户将是全局用户，没有任何数据库实例的权限。

在我之前的回答中，我提到的 GRANT 语句是为了说明当您希望用户拥有某个数据库实例的权限时，可以在创建用户后使用 GRANT 语句为其授予权限。如果没有执行 GRANT 语句，用户将没有访问数据库的权限。

因此，您的理解是正确的：上述代码创建了用户，但由于没有使用 GRANT 语句为用户授予任何数据库实例的权限，该用户将是全局用户，但没有任何权限。谢谢您的指正，希望这能更清晰地解释相关概念。
```

## 4.2. 利用工具完成用户的创建、删除、并观察对应的脚本语句

（1）找到入口并填入用户名和密码

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1703160774939-60a43eef-39f2-4f1c-9c8b-1a8331d6cfb8.png)

（2）预览并保存

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1703160899669-7acdfb70-9d6d-4e3e-9066-66147a2e8a10.png)

（3）新添加的用户

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1703160978839-e12516c8-4238-44e2-82dd-b0f0631d5533.png)

## 4.3. 生活中的权限管理

## 4.4. MYSQL中的四种用户

```
在MySQL中，mysql.infoschema、mysql.session、mysql.sys、root 是系统内置的一些用户，它们分别用于不同的系统目的，拥有不同的权限。

    mysql.infoschema 用户：
        用途： 用于连接到information_schema数据库，该数据库包含有关数据库和表的元数据信息。
        权限： 允许执行与元数据相关的查询和检索操作，如查看数据库和表的结构信息。

    mysql.session 用户：
        用途： 用于系统会话，这是一个用于管理当前会话的内部用户。
        权限： 有一些内部权限，用于处理会话和连接管理。

    mysql.sys 用户：
        用途： 用于连接到sys数据库，该数据库包含有关MySQL服务器性能的信息。
        权限： 通常用于执行与性能和监控相关的查询，如查看性能架构和事件信息。

    root 用户：
        用途： root 是MySQL中的超级用户，具有最高权限。
        权限： root 用户拥有全局的、跨所有数据库的权限，可以执行任何操作，包括创建、修改和删除数据库，创建和管理用户等。这是最高权限的用户。

异同点：

    这些用户都是系统内置的，用于执行系统级别的操作，而不是普通应用程序用户。
    这些用户分别用于不同的系统目的，例如元数据查询、系统会话管理和性能监控。
    它们通常具有较高的权限，但 root 用户拥有最高的权限。
```

## 4.5. MySQL中的常用的权限

## 4.6. 利用工具，为指定的用户赋予执行的权限

(1)入口

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1703161210417-7cb0c57c-7fdd-46ee-9db6-7cf045be08c5.png)

（2）添加权限

  

![](https://cdn.nlark.com/yuque/0/2023/png/1727964/1703161430578-119cd598-361e-408d-9a92-cd1d733da2d2.png)

## 4.7. 小结

1. MySQL中，用户是MYSQL实例的用户，权限是用户在某个数据库实例中的权限

# 5. 备份

## 5.1. 常用的几种备份

1. 导出SQL
2. 连同数据一起导出
3. 单次手工备份
4. 自动定时备份

## 5.2. 单次手工备份

## 5.3. 自动定时备份