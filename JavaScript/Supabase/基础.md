研究Super Bass 的工作原理以及如何从前端应用程序连接到它，特别是我们将研究数据库并构建一个与该数据库交互的简单 CRUD 应用程序，因此用户可以在其中创建、读取、更新和删除数据。其他功能（如身份验证和函数）

### 连接到 Supabase
登录 [supabase](supabase.com) 创建项目后向下滚动，我们需要一些东西，我们需要我们的 api 密钥生成还有这个Project URL，所以我们复制这个网址，然后将其粘贴到记事本或类似的东西中，也可以复制这个公共 API 密钥
需要这两个来连接这个项目后端
接下来我们要将它们存储在环境变量中，因此我们需要创建一个新文件，它将是一个 .env(没有什么名字就是.env) 文件，用于存储环境变量
```
REACT_APP_SUPABASE_URL=https://yzdknxdlvekatvzckpws.supabase.co
REACT_APP_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl6ZGtueGRsdmVrYXR2emNrcHdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzcwODI3MDEsImV4cCI6MjA1MjY1ODcwMX0.osHa9CdL0Hppeh9R7Kzf9iMdRwYuDzlX3kPcEyrHT5M
```
现在可以在项目内的其他文件中使用这些环境变量

安装 superbase 客户端库来连接到后端   `npm install @supabase/supabase-js`
可以使用一些代码和客户端库将前端连接到后端，点击 supabase 项目左侧的 API Docs，有要用到的代码，用于与后端的 superbase 进行通信，以执行诸如与数据库交互之类的操作。
进入项目源文件夹在这里创建一个名为config的新文件夹，在里面我将创建一个名为 supabaseClient.js 的新文件，然后我将粘贴复制代码。
**supabaseUrl 和 Key 要与我们创建的环境变量对应**
```js
import { createClient } from "@supabase/supabase-js";
const supabaseUrl = process.env.REACT_APP_SUPABASE_URL;
const supabaseKey = process.env.REACT_APP_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;
```
调用 createClient 这个函数，并传递这两个东西来连接到后端有了这个 supabase 常量，我们将在剩下的部分使用它


### Fetching Data
创建一个新的数据库，然后我们将在该数据库中放入一些数据，然后我们将从前端获取该数据库中的数据并在我们的 React 应用程序中显示它
进入 Table Editor，设置一个新表格。两个选项 rls 启用级别安全性与谁可以访问数据库或表中的数据有关，下面的这个也与实时数据有关。下面是表中的列默认有一个id 属性，它是一个整数，这是主键，还有时间戳，称为created.property。可以添加自定义列。
简单示例：获取 smoothies 表（字段有 id、created_iat、title、method、rating）的数据
```js
import supabase from "../config/supabaseClient";

const fetchSmoothies = async () => {
  const { data, error } = await supabase
  	.from("smoothies")
  	.select();
  if (error) {
  }
  if (data) {
  }
};
```

### create data
添加数据自然需要表单提交（这里不讲解表单部分）
每个对象代表一行，我们只想添加一个，所以一个对象
**在 supabase 第一版是自动返回 data，第二版后需要调用 select 方法返回 data**
```js
import supabase from "../config/supabaseClient";

const handleSubmit = async (e) => {
  e.preventDefault();

  if (!title || !method || !rating) {
    //error
    return;
  }

  const { data, error } = await supabase
    .from("smoothies")
    .insert([{ title, method, rating }]) //insert([{},{},{}])
    .select(); 

  if (error) {
  }
  if (data) {
  	//重定向回主页
  }
};
```

### 仅获取单个记录或单个行
获取要更新的单个记录(例如在所有卡片中点击一个 edit)，并使用该记录预填充更新表单
通过使用 eq 方法，eq 允许我们传入几个参数，比如我们只想选择 id 等于第二个参数的，并且如果我们希望它只返回单个对象(而不是只有一个对象的列表)可以使用 single 方法
```js
import supabase from "../config/supabaseClient";

const fetchSmoothie = async () => {
  const { data, error } = await supabase
    .from("smoothies")
    .select()
    .eq("id", id)
    .single();

  if (error) {
    //重定向回主页
  }
  if (data) {
    //data.title
    //data.method
    //data.rating
  }
};
```

### Update data
指定要更新哪条记录，所以在 update 后我们要用 eq 方法
```js
import supabase from "../config/supabaseClient";

const handleSubmit = async (e) => {
  e.preventDefault();

  if (!title || !method || !rating) {
    //error
    return;
  }

  const { data, error } = await supabase
    .from("smoothies")
    .update({ title, method, rating })
    .eq("id", id)
    .select();

  if (error) {
    //error
  }
  if (data) {
    //error
    //重定向回主页
  }
};
```

### Delete data
在控制台将看到已被删除的 smoothie 但它尚未从 UI 中删除这是因为当我们发送一个删除请求，我们从数据库中删除它，但此组件内的本地状态仍然不变，我们不会重新获取任何数据或类似的东西，所以如果刷新，那么我们应该看到，那么那个已经消失了，因为我们刷新了数据。现在，这对用户来说不是一个很不好的体验，因此我们在下一个要做的就是在收到数据响应时删除本地状态，以更新本地状态以匹配数据库中的内容获取数据响应
```js
import supabase from "../config/supabaseClient";

const handleDelete = async () => {
  const { data, error } = await supabase
    .from("smoothies")
    .delete()
    .eq("id", smoothie.id)
    .select();

  if (error) {
    console.log(error);
  }
  if (data) {
    console.log(data);
  }
};
```

### Updating Local State 更新本地状态
简单方法：将删除的 data 的 id 进行传递，到 Fetching Data 处让总 data 进行 filter 更新

### 数据排序
当我们获取数据时，我们如何对数据进行排序，如果我想按评级或标题或其他内容排序，可以使用给定的特殊方法，超级基础客户端库可以做到这一点
根据用户选择的特定标准来更新该值，我们将在这里提供一些模板，我们有这个按钮排序有三个按钮是创建时间，然后是标题，然后是评级，当我们点击这些按钮时，它会调用函数设置顺序，按此顺序更新最初创建的状态
我们可以添加另一个方法名为 **order**，然后我们所做的就是传入我们想要排序的字段，第二个参数传递一个对象，我们可以将升序设置为 false，因为默认情况下升序为 true，但你可以通过将其设置为 false 来覆盖它
```html
<div className="order-by">
  <p>Order by:</p>
  <button onClick={() => setOrderBy("created_at")}>
    Time Created
  </button>
  <button onClick={() => setOrderBy("title")}>Title</button>
  <button onClick={() => setOrderBy("rating")}>Rating</button>
</div>
```
```js
import supabase from "../config/supabaseClient";

const fetchSmoothies = async () => {
  const { data, error } = await supabase
    .from("smoothies")
    .select()
    .order(orderBy, { ascending: false });

  if (error) {
    //error
  }
  if (data) {
  }
};
```


### Intro to RLS & Policies 行级安全性

默认情况下，如果有人拥有我们用来连接 supabase 数据库后端的公共 API 密钥他们就可以读取并写入我们的数据库，同样，通过在我们的网站上使用该 api 密钥任何用户都可以获取、创建、更新以及删除，因为当我们的网站使用该公钥连接到数据库时，它可以访问所有内容。默认情况密钥是公开的，请记住，如果您想保护数据以限制对数据库的访问，则需要从后端进行操作通过使用所谓的行级安全性和策略来实现这一点。

政策可能会规定任何人都可以阅读所有内容表中的行，但只有经过身份验证的登录用户才能创建和更新行，我们将创建几个非常简单的策略。首先启用 RLS 默认rls is not enabled。
启用了 rls 的表的**默认行为是阻止所有任何人或任何事物访问该表**。

我现在想做的是制定一些政策以便用户可以读取所有数据，并创建新的数据，但我想要锁定删除数据的能力，这样如果用户尝试删除就会失败，更新也是一样，我想保护表格免受任何类型的更新请求和删除请求的影响。

点击 **new policy** get started quickly 会为我们生成一个模板在这里为我们的政策启用对每个人的读取权限，for full customization 进行完全自定义，再增加一个 policy 让 insert 为 true

这是安全性和策略的介绍，它只涉及表面，因为当你制作一个真实的网络应用程序时，你可能会想要一个对数据访问进行更精细的控制，例如分析身份验证状态，查看用户是谁，并根据这些情况限制访问权限。