通过在用户提交登录表单时存储用户 cookie 来模拟用户登录应用程序，然后在路由之间的中间件中将检查该用户cookie 以确定用户是否可以查看某个页面，以及他们是否未通过身份验证，以及当注销时，我们可以将用户重定向回登录页面为此，我们将以各种不同的方式使用中间件。
### 创建初始项目
[github 库](https://github.com/iamshaunjp/Nuxt-Route-Middleware-Tutorial/tree/starter-project)
`npx nuxi@latest init <project-name>`

（进入开发者，到 Application 中查看 cookie）
进入登录页面，输入 Mario 这样的用户名，提交表单，它会创建记录用户 cookie，然后再次将我们导航回主页，这一次，因为我们有该用户cookie，所以我们已登录，我们可以看到用户名，如果我们转到注销页面，但实际上我们没有注销操作，也就是说 cookie 仍然留在浏览器中，但稍后要添加一些中间件在这个路由中，当我们导航到注销页面时，删除该 cookie 才算实际注销。

### 基本内联中间件
制作第一个中间件函数，该中间件将在我们输入注销路由之前运行。以便通过删除浏览器中的用户 cookie 来记录用户路由，然后将用户重定向回登录页面。
有几种不同的方法可以制作和使用路由中间件
直接在我们希望运行它的页面或路由中运行。**直接在页面内创建中间件时，称之为内联中间件。**
使用 Nuxt 提供的 `definePageMeta`，此函数接受一个对象作为参数，该对象包含许多不同的可选属性(像 loayout)来配置此页面，其中一个属性是 `middleware`，
middleware 属性的值可以是一个函数，这个中间感知函数将在我们导航到这个页面时运行。这个函数会自动提供几个不同的**参数**，这些参数被称为 `to` 和 `from`，**都是对象**。它们提供了用户 from (从哪里导航的)以及 to (要导航到哪条路线)的上下文。
```vue
<template>
  <div>
    <h2>Logout</h2>
  </div>
</template>

<script setup>
definePageMeta({
  middleware: function (to, from) {
    const user = useCookie("user");
    user.value = null;
    return navigateTo("/login");
  },
});
</script>
```

### 命名中间件
想要将相同类型的中间件功能应用到网站上的另一个页面，可以添加相同的内联中间件也可以手动复制，但这会导致**代码重复**，并使维护和更新代码变得更加困难。因此可以**在外部文件中运行中间件，然后可以在任何需要它的页面中引用该中间件**。
在根目录创建名为 `middleware` 文件夹，这是我们创建中间件函数的地方。
不仅仅是创建一个常规函数并导出它，而是我们需要在 Nuxt 提供的内置函数中包装中间件函数，称为 `defineNuxtRouteMiddleware()`，该函数的**参数是我们想要的实际运行的中间件函数**。
例如创建一个 aurh.ts
```ts
export default defineNuxtRouteMiddleware((to, from) => {
  const authenticated = useCookie("user");
  if (!authenticated.value) {
    return navigateTo("/login");
  }
});
```
```vue
<script setup>
definePageMeta({
  middleware: ["auth"],
});
</script>
```

### 中间件链
`middleware: []`，在这个数组中声明了要使用的中间件的名称，这个值是一个数组，这意味着我们可以将多个中间件函数传递给它
**中间件函数按照它们放入数组的顺序依次运行，当这种情况发生时，它被称为中间件链接(Middleware Chaining)**。


