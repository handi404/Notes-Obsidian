### 创建 Nuxt 应用程序
[官方文档](https://nuxt.com/docs/getting-started/installation)
```
npm create nuxt <project-name>
yarn create nuxt <project-name>
pnpm create nuxt <project-name>
bun create nuxt <project-name>

npm run dev -- -o
yarn dev --open
pnpm dev -o
bun run dev -o
```
或：
`npx nuxi init <project-name>`
`cd <project-name>
`npm install`

了解一下项目中所有这些文件是什么，首先我们有这个配置文件 `nuxt.config.ts` 是一个 Typescript文件，建议将此文件保留为 Typescript 文件，但应用程序的其余代码不必是 Typescript，可以是 JavaScript，此处的配置文件用于可以扩展或更改项目的默认接口配置，可以在此处添加自定义元数据或注册模块，还可以添加环境变量。
我们有视图文件，即 `app.vue` 文件这是应用程序的默认根组件，稍后会删除但现在如果我们预览网站，它将作为主页内容。像 `<NuxtWelcome />` 是一个完全内置的组件，其中包含很多我们实际上看不到的内容。
`.nuxt` 文件夹是在开发过程中使用的生成 next 应用程序，不需要探索这个文件夹，也不需要改变里面的任何内容。
之后 `npm run dev` 启动项目。

### 添加页面
[[添加页面]]
那么我们如何向网站添加更多使用不同组件和内容的路线和页面呢？Nuxt 让这一切变得非常简单，我们唯一需要做的就是在根目录中创建一个 `pages` 文件夹，然后在该 pages 文件夹中创建不同的 vue 文件，**其中每个文件代表不同的页面和 Route**，并且路径将由文件名决定。
删除 app.vue，在 pages 中新建 `index.vue`，这个 index.vue 将作为主页。接下来 nuxt 不会根据文件名 index.vue 为其创建 `/索引路由`，因为当 nuxt 看到这个 index.vue 组件时，它只会使用它作为应用程序主页面，即 `/`。
#### 子文件夹
现在我们知道我们可以将所有页面组件放在这个 pages 文件夹中，然后将根据该文件的名称为每个页面创建一个路由，但是关于**在 pages 目录中添加子文件夹**，我们可以这样做吗？当然可以，然后下一步会**自动**将名称（如果来自文件夹）添加到路由路径中。
例如：在 pages 中创建 products 文件夹，在 products 中创建 hello.vue，那么 hello.vue 的路由为 /products/hello，并且在子文件夹中创建 index.vue 就如同在 pages 中创建的 index.vue。比如在 products 中创建 index.vue 那么进入/products 看到的就是 products 中 index.vue 的内容，即**在子文件夹中创建的 index.vue 将作为子文件夹的"主页"**。


### 路由参数(动态路由)
[[动态路由（路由参数）]]
使用路由参数（路由的动态部分）设置页面和路由。
如果我们需要的路由，其中一部分是可更改的，但我们仍想显示相同的组件。如：在 products文件夹内，然后 /id 无论我们想要看到什么产品，对于每个产品，路线的 id 部分都会发生变化，但对于每个产品，我们仍然希望显示相同的产品详细信息组件，并且在该组件中，**只有路由和数据会根据 id 而变化**，但页面的实际结构是相同的。
这样做的方法是创建一个 `[路由参数名称].vue` 文件
在 products 中创建 `[id].vue`，路由将会是 /products/ `:id`
```vue
<template>
  <div>
    <p>This is a dynamic route, the id is {{ id }}</p>
  </div>
</template>

<script setup>
const { id } = useRoute().params;
</script>

<style></style>
```
我们可以使用此组件中的 id，从 API 中获取数据，然后在此页面上显示该数据

### NuxtLink
[[NuxtLink]]
`<NuxtLink to="">` 和常规 `<a href="" >` 区别
理想情况下，在网站上有某种导航栏，这样我们就可以浏览不同的页面，使用这些链接，我们不必一直在地址栏中输入内容。
NuxtLink 也是内置组件，不必导入。
```vue
<template>
  <div>
    <header>
      <nav>
        <NuxtLink to="/">Nuxt</NuxtLink>
        <ul>
          <li><NuxtLink to="/">Home</NuxtLink></li>
          <li><NuxtLink to="/about">About</NuxtLink></li>
          <li><NuxtLink to="/products">Merch</NuxtLink></li>
        </ul>
        <a href="/about">normal link -- about page</a>
      </nav>
    </header>
  </div>
</template>
```
### layout 布局
[[Layout（布局）]]
为页面制作布局文件。
我们只需创建定义一次布局，这些代码对每个页面都是通用的，然后如果我们想更新它，我们只需要做一次。布局就会把所有这些不同的页面组件包裹起来
在根目录中创建一个 `layouts` 文件夹然后我们可以创建不同类型的布局，如果你想要一个默认布局，基本上可以包裹应用程序中的每个页面。
创建 default.vue，将需要在每个页面输出的（如导航栏）写进去，那么我们需要输出页面内容的地方在哪里？我们使用一个叫做 slot 的内置组件，所有页面都会去到这个 slot。
```vue
<template>
  <div>
    <header>
      <nav>
        <NuxtLink to="/">Nuxt Dojo</NuxtLink>
        <ul >
          <li><NuxtLink to="/">Home</NuxtLink></li>
          <li><NuxtLink to="/about">About</NuxtLink></li>
          <li><NuxtLink to="/products">Merch</NuxtLink></li>
        </ul>
      </nav>
    </header>
    <div>
      <slot />
    </div>
  </div>
</template>
```
那么，如何创建自定义布局，并将其应用于某些页面。比如现在就算进入 /products/:id 中依旧会有导航栏，但我不希望这样。
简单，要做的就是在 layouts 文件夹中创建一个新文件。比如创建 products.vue（便于匹配）
```vue
<template>
  <div>
    <header>
      <nav>
        <NuxtLink to="/products">Nuxt Dojo Merch</NuxtLink>
      </nav>
    </header>
    <div>
      <slot />
    </div>
    <footer>
      <ul >
        <li><NuxtLink to="/">Home</NuxtLink></li>
        <li><NuxtLink to="/about">About</NuxtLink></li>
        <li><NuxtLink to="/products">Merch</NuxtLink></li>
      </ul>
    </footer>
  </div>
</template>
```
接下来要做的是，在想要使用自定义布局的 vue 文件中在 `<script seup>` 脚本中使用提供的一个特殊可组合函数 `definePageMeta`，此函数接受一个对象作为参数，在那里我们可以指定一个布局属性来指定我们要使用的布局。
```vue
<script setup>
definePageMeta({
  layout: "products",
});
</script>
```

### 添加 Tailwind CSS
[Nuxt Module](https://nuxt.com/modules)，有各种库的设置使用。
添加外部库 [Tailwind](https://tailwindcss.nuxtjs.org/getting-started/installation)，同时美化一下应用。
`npm install --save-dev @nuxtjs/tailwindcss`
进入 `nuxt.config.{ts,js}` 配置文件，在这个对象中定义下一个配置函数，在这里声明任何我们添加到应用程序中的额外模块，这些模块位于 `modules` 数组中，每个值都是一个字符串值。
```js
export default defineNuxtConfig({
  modules: [
    '@nuxtjs/tailwindcss'
  ]
})
```

添加 TailwindCSS 文件来扩展 Tailwind 并添加额外的类和组件，并且该文件需要位于根目录中的 assets 文件夹中，在其中创建一个 CSS 文件夹，然后在里面创建 tailwind.css。
导入 Tailwind 库的所有不同部分，这样我们就有了基础部分
```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```
可以添加额外的类，然后去使用我们添加的类。

### Fetching Data
[[数据获取（Fetching Data）]]
从第三方 API 获取数据并将其注入到组件中。
使用Composition API 编码的语法糖，Nuxt 为这项任务提供了一个内置可组合函数，因此我们将使用的是一个函数 `useFetch()`。记住，此代码可以在服务器和浏览器中触发，这很重要，因为并非所有代码都可以在服务器和浏览器中使用。
在响应中解构出数据，若不想将数据的属性名称为 data，想将其称为 products，可以通过 `:` 来做到这一点。
```vue
<template>
  <div>
    <div class="grid grid-cols-4 gap-5">
      <div v-for="product in products" :key="product.id">
        <NuxtLink :to="`/products/${product.id}`">{{ product.title }}</NuxtLink>
      </div>
    </div>
  </div>
</template>

<script setup>
definePageMeta({
  layout: "products",
});
const { data: products } = await useFetch("https://fakestoreapi.com/products");
</script>

<style lang="scss" scoped></style>
```
然后进入 `[id].vue`，通过 api + id 获得单个 product 详细数据。
（若遇此问题，每次我们进入不同的 product 详情页面时，即使我们每次从路由参数中使用不同的 id，不同的 product 详细信息显示的数据都相同，如果我们打开开发工具，每当我们进入新产品页面时，转到网络选项卡，你都会看到目前没有额外的请求来获取新 produt，这是因为 useFetch 函数默认会尽量减少它为了提高性能而需要做的工作上次获取的组件相同的数据，解决这个问题的方法是，为我们在产品详细信息组件内进行的每个获取添加一个唯一的键，以便 useFetch 函数有办法区分不同的产品，并且这个 key 应该是每个产品独有的，如 id。`useFetch(url, {key: id})`）
```vue
<template>
  <div>
    <p>{{ product.title }}</p>
    <p>{{ product.price }}</p>
    <p>{{ product.id }}</p>
  </div>
</template>

<script setup>
definePageMeta({
  layout: "products",
});
const { id } = useRoute().params;
const url = "https://fakestoreapi.com/products/" + id;
const { data: product } = await useFetch(url);
</script>

<style></style>
```


### 可复用组件(components)
[[可复用组件（Components）]]
在根目录创建 components 文件夹，里面创建编写需要重复使用的组件。
与 vue 类似。
```vue
<!--------------------pages/products/index.vue-------->
<template>
  <div>
    <div class="grid grid-cols-4 gap-5">
      <div v-for="product in products" :key="product.id">
        <ProductCard :product="product" />
      </div>
    </div>
  </div>
</template>

<script setup>
definePageMeta({
  layout: "products",
});
const { data: products } = await useFetch("https://fakestoreapi.com/products");
</script>
<!--------------------components/ProductCard.vue-------->
<template>
  <div class="card text-center">
    <img :src="product.image" class="thumb" />
    <p class="font-bold text-gray-500 m-4 truncate">{{ product.title }}</p>
    <NuxtLink :to="`/products/${product.id}`">
      <p class="btn my-4">View Details</p>
    </NuxtLink>
  </div>
</template>

<script setup>
const { product } = defineProps(["product"]);
</script>
<!--------------------pages/products/[id].vue-------->
<template>
  <div>
    <ProductDetails :product="product" />
  </div>
</template>

<script setup>
definePageMeta({
  layout: "products",
});
const { id } = useRoute().params;
const url = "https://fakestoreapi.com/products/" + id;
const { data: product } = await useFetch(url);
</script>
<!--------------------components/ProductDetails.vue-------->
<template>
  <div class="card">
    <div class="grid grid-cols-2 gap-10">
      <div class="p-7">
        <img :src="product.image" class="mx-auto my-7" />
      </div>
      <div class="p-7">
        <h2 class="text-4xl my-7">{{ product.title }}</h2>
        <p class="text-xl my-7">Price - ${{ product.price }}</p>
        <h3 class="font-bold border-b-2 mb-4 pb-2">Product description:</h3>
        <p class="mb-7">{{ product.description }}</p>
      </div>
    </div>
  </div>
</template>

<script setup>
const { product } = defineProps(["product"]);
</script>
```


### 错误页面
[[自定义错误页面]]
如果我们转到一个不存在的页面，我们将获取默认的 404 页面，或不存在数据的页面。
显示自定义错误页面。
创建自定义错误页面的方式很简单，只需在根目录中创建一个名为 `error.vue` 的新文件，
```vue
<template>
  <div class="mt-7 max-w-sm mx-auto text-center card">
    <p class="mt-7 text-7xl font-bold">{{ error.statusCode }}</p>
    <p class="mt-7 text-6xl">Ooops.</p>
    <p class="mt-7">{{ error.message }}</p>
  </div>
</template>

<script setup>
defineProps(["error"]);
</script>
```
这样进入不存在的页面就会看到自定义的错误页面，但是若进入像 `/products/不存在的id` 这种不存在数据的页面，仍无法进入自定义错误页面。
这时候需要我们编辑 `[id].vue` 文件去 throw 一个自定义 error 对象。
```vue
<script setup>
definePageMeta({
  layout: "products",
});
const { id } = useRoute().params;
const url = "https://fakestoreapi.com/products/" + id;
const { data: product } = await useFetch(url);
if (!product) {
  throw createError({
    statusCode: 404,
    statusMessage: "Product not found",
  });
}
</script>
```
现在对 error.vue 添加一个按钮，实现清除应用程序的错误并重定向到主页。
```vue
<template>
  <div class="mt-7 max-w-sm mx-auto text-center card">
    <p class="mt-7 text-7xl font-bold">{{ error.statusCode }}</p>
    <p class="mt-7 text-6xl">Ooops.</p>
    <p class="mt-7">{{ error.message }}</p>
    <button class="btn my-7" @click="handleError">Go Home...</button>
  </div>
</template>

<script setup>
defineProps(["error"]);
const handleError = (params) => clearError({ redirect: "/" });
</script>
```
若是点击一个不存在的链接会发生什么。比如在主页添加一个去 /products/abc 的链接，
点击后你会发现浏览器控制台报错，但并不会去到自定以错误页面。
这是因为我们在 `[id].vue` 中 throw 自定义 error 对象是在服务器中创建并运行的，而点击链接是在浏览器中触发，而不是在服务器上。
必须向 createError 里的对象添加一个额外的属性，`fatal` 将它设为 true 会强制应用程序显示错误页面。
```vue
<script setup>
definePageMeta({
  layout: "products",
});
const { id } = useRoute().params;
const url = "https://fakestoreapi.com/products/" + id;
const { data: product } = await useFetch(url);
if (!product) {
  throw createError({
    statusCode: 404,
    statusMessage: "Product not found",
    fatal: true,
  });
}
</script>
```


### Metadata & useHead
[[Metadata & useHead]]
(类似编写 html 中 head 部分)
将注意力转移到网站的元数据上，而不是网站内容上，比如文档中的标题标签、指向外部样式表的链接网站描述的元标记之类的东西。可以通过几种方式来控制它，第一种方法是将所有这些头部内容添加到 `nuxt.config.ts` 配置文件中
```ts
export default defineNuxtConfig({
  modules: [
    '@nuxtjs/tailwindcss'
  ],
  app: {
    head: {
      title: 'Nuxt Dojo',
      meta: [
        {name: 'description', content: 'Everything about Nuxt 3'}
      ],
      link: [
        {rel: 'stylesheet', href: 'https://fonts.googleapis.com/icon?family=Material+Icons'}
      ]
    }
  }
})
```
这是全局的，所以它将应用相同的值到应用程序中的每个页面，但你可能有些页面不想用这些想要覆盖它，那么就可以使用 `useHead()`。
```vue
<script setup>
  useHead({
    title: 'Nuxt | Merch',
    meta: [
      { name: 'description', content: 'Nuxt 3 Merch'}
    ]
  })
</script>
```
还有一种方法是使用内置的组件或标签。
```vue
<template>
  <div>
    <Head>
      <Title>Nuxt | {{ product.title }}</Title>
      <Meta name="description" :content="product.description" />
    </Head>

    <ProductDetails :product="product" />
  </div>
</template>
```


### Server Routes 服务器路由
[[服务端 API 路由]]
创建自定义服务器路由
Nuxt 使用一个名为 **Nitro** 的后端服务器，它允许我们为应用程序创建服务器端路由或 API 端点（如果熟悉使用node 和 express 来创建 API）。我们已经可以在组件中的脚本标签中执行获取数据之类的操作，为什么还要创建这些后端 API 路由？在浏览器的前端，你可能需要使用一些敏感数据，比如私钥，而服务器路由，或者你有一个身份验证系统，你需要为此提供端点，**基本上任何你不想在前端公开的代码都可以使用服务器路由，因为任何事情你把脚本标签放在组件中，无论它在服务器上还是在浏览器中运行，最终都会暴露给前端用户**。
如何创建这些服务器路由呢？
要在 Nuxt 中做到这一点，需要做的就是在应用程序的根目录中创建一个名为 `server` 的文件夹，然后在该文件夹中创建另一个名为 `api` 的文件夹，然后我们所有的 api 路由都将位于此文件夹中，并且这些 api 端点的路径将是 `/api/文件名`。
例如：在 api 中创建一个 one.js，可以使用服务器函数进行 fetch data，然后返回数据。
```js
export default defineEventHandler((event) => {
	return {
		message: "hello Nuxt"
	}
})
```
然后从前端脚本标签中获取。
```vue
<script setup>
const { data } = awati useFetch("/api/one");
</script>
```
并且 `event` 对象会包含有关请求的信息，使用 `getQuery(event)` 可以得到请求参数。
```vue
<script setup>
const { data } = awati useFetch("/api/one?name=mario");
</script>
```
```js
export default defineEventHandler((event) => {
	const { name } = getQuery(event);
	return {
		message: `hello ${name}`
	}
})
```
也可以使用服务器函数来接受其他请求(post)，我们也可以再次使用这个 event 对象从请求中提取任何数据。使用 `readBody(event)`
```vue
<script setup>
const { data } = awati useFetch("/api/one?name=mario", {
	method: 'post',
	body: {
		age: 30
	}
});
</script>
```
```js
export default defineEventHandler(async (event) => {
  //handle query params
  const { name } = getQuery(event)
  //handle post data
  const { age } = await readBody(event)
  return {
    message: `Hello, ${name}! You are ${age} years old.`
  }
})
```
我们想要创建服务器路由的原因之一是我们正在使用某种**需要私钥的第三方 API**，而我们不想暴露它到前端，所以展示如何使用这种示例，在这里使用货币 API [currencyapi](https://currencyapi.com/)，一个相对于美元汇率的 api。
`https://api.currencyapi.com/v3/latest?apikey=YOUR-API-KEY`
申请的 free apikey 为 `cur_live_z2F97cQJF60iDRCc3tgugl8KsKywJt7Q7PhLLAPS`
从 API 中获取数据，在服务器中使用 `$fetch`，useFetch 是 $fetch 的包装器，为了在前端使用更简单。
```js
export default defineEventHandler(async (event) => {
  const { data } = await $fetch(
    "https://api.currencyapi.com/v3/latest?apikey=cur_live_z2F97cQJF60iDRCc3tgugl8KsKywJt7Q7PhLLAPS"
  );
  return data;
});
```
```vue
<script setup>)
const { data } = useFetch("/api/demo");
</script>
```


### Dynamic Server Routes（动态服务器路由）
就像前端路由一样，我们可以先做一些额外的事情，我们可以在 API 文件夹中创建子文件夹，然后该文件夹名称将添加到路由中。其次，我们还可以拥有路由参数或路由的动态部分。
与前端路由参数相同，在子文件夹中新建一个 `[参数名].js/ts` 文件，即为路由参数或路由的动态部分。例如：在子文件夹 currency 中创建 `[code].js`，那么此路径的服务器路由为 `/api/currency/:code`。
接下来在 `[code].js` 中获取路由参数(货币代码)，很容易地通过从事件对象中解构它：
```js
export default defineEvnetHandler(async (event) => {
	const { code } = event.context.params;
	const url = `https://api.currencyapi.com/v3/latest?currnecies=${code}apikey=`
})
```
这次我们不粘贴 **key，我们将它设为环境变量，这样如果我们需要将它推送到远程存储库，它就不会暴露该私钥在 Repository 中，因为我们不推送环境变量**。
那么我们如何在 nuxt3 应用程序中添加环境变量呢？
首先，我们需要在应用程序的根目录中创建一个 `.env` 文件，然后在里面定义环境变量。
```
CURRENCY_API_KEY=cur_live_z2F97cQJF60iDRCc3tgugl8KsKywJt7Q7PhLLAPS
```
现在想使用它，就需要通过 nuxt.config.ts 配置文件将环境变量暴露给应用程序。
```ts
// https://nuxt.com/docs/api/configuration/nuxt-config
export default defineNuxtConfig({
  compatibilityDate: "2025-01-21",
  devtools: { enabled: false },
  modules: ["@nuxtjs/tailwindcss"],
  app: {
    head: {
      title: "Nuxt",
      meta: [{ name: "description", content: "Everything about Nuxt 3" }],
      link: [
        {
          rel: "stylesheet",
          href: "https://fonts.googleapis.com/icon?family=Material+Icons",
        },
      ],
    },
  },
  runtimeConfig: {
    currencyKey: process.env.CURRENCY_KEY,
  },
});
```
**这些键直接嵌套在运行时配置对象中不会暴露给前端，所以不能在前端 vue 使用它们，但是如果确实想将某些变量暴露给前端，可以将它们放在一个名为 `public` 的嵌套属性中，然后将密钥放在其中。**
```ts
export default defineNuxtConfig({
  runtimeConfig: {
    currencyKey: process.env.CURRENCY_KEY,
    public: {
    }
  },
});
```
我们这里不用它。
现在从运行时配置中结构出 currencyKey
```js
export default defineEventHandler(async (event) => {
  const { code } = event.context.params;
  const { currencyKey } = useRuntimeConfig();
  const url = `https://api.currencyapi.com/v3/latest?currencies=${code}&apikey=${currencyKey}`;
  const { data } = await $fetch(url);
  return data;
});
```
(也可以使用**以"NUXT_"为前缀的环境变量名称**，然后您就不需要用 `process.env.` 来获取它们。在例子中，它可能是 `.env` 文件中的"NUXT_CURRENCY_KEY=12345"。在 `nuxt.config.ts` 文件中，只需为 `currencyKey` 设置一个空字符串。)

### 部署到 Netlify
