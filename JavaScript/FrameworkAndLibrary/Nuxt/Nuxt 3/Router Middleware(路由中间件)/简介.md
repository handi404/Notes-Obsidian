讲解 Nuxt 3 中的 **路由中间件 (Router Middleware)**。这是 Nuxt 提供的一个强大钩子，允许你在导航到某个路由（页面）**之前**执行特定的逻辑。

**核心理念：路由的“守卫”与“预处理器”**

你可以把路由中间件想象成是你网站/应用路由跳转过程中的**检查点**或**预处理站**。当用户试图访问一个页面时，对应的中间件会先运行，它可以：

1.  **执行检查**: 比如检查用户是否已登录、是否有访问权限等。
2.  **重定向**: 如果检查不通过，可以将用户重定向到其他页面（如登录页）。
3.  **修改或添加数据**: （虽然现在更推荐在页面组件内用 `useFetch/useAsyncData` 获取数据）理论上可以在这里做一些准备工作，但要小心副作用。
4.  **设置布局**: 动态地为特定路由设置不同的布局。
5.  **日志记录/分析**: 记录路由访问信息。

**工作方式与创建：`middleware/` 目录**

1.  **创建目录**: 在你的 Nuxt 项目根目录下，创建一个 `middleware` 文件夹。
    ```
    your-nuxt-project/
    ├── middleware/   <-- 路由中间件文件放在这里
    │   ├── auth.ts
    │   └── stats.global.ts
    ├── pages/
    ├── components/
    └── nuxt.config.ts
    ```
2.  **创建中间件文件 (`.js` 或 `.ts`)**: 在 `middleware/` 目录下创建 JS 或 TS 文件。**文件名（去掉后缀）就是中间件的名称**。
3.  **编写中间件逻辑**: 每个中间件文件需要导出一个由 `defineNuxtRouteMiddleware()` 函数包装的函数。这个函数接收两个参数：
    *   `to`: 目标路由对象 (RouteLocationNormalized)，包含即将导航到的页面的信息（路径、参数、查询等）。
    *   `from`: 当前路由对象 (RouteLocationNormalized)，包含用户离开的页面的信息。

**`defineNuxtRouteMiddleware` 的返回值/行为：**

中间件函数的执行结果决定了导航的行为：

*   **无返回值 (`undefined` / `void`) 或 `return;`**: 允许导航继续，会执行后续的中间件（如果有）或最终导航到目标页面。**这是最常见的成功情况。**
*   **`return navigateTo('/login')` 或 `return navigateTo({ path: '/login', query: { redirect: to.fullPath } })`**: **中断当前导航**，并将用户**重定向**到指定的路径。`navigateTo` 是 Nuxt 提供的全局辅助函数。
*   **`return abortNavigation()`**: **中断当前导航**，但停留在当前页面（URL 不会改变）。可以接受一个可选的错误消息参数 (`abortNavigation('Permission denied')`)，该消息主要用于开发调试，不会显示给用户。
*   **`return false`**: (Nuxt 3 不推荐，行为可能不明确，优先使用 `abortNavigation`) 理论上也是中断导航。
*   **`throw createError(...)` 或直接 `throw new Error(...)`**: **中断导航**，并显示 Nuxt 的错误页面 (`error.vue`)。`createError` 是 Nuxt 提供的辅助函数，用于抛出带有 HTTP 状态码的错误。

**中间件类型与应用：**

Nuxt 3 主要有两种类型的路由中间件：

1.  **具名（路由）中间件 (Named Route Middleware)**
    *   **定义**: 就是普通的 `middleware/auth.ts` 文件。
    *   **应用**: 需要在**页面组件** (`pages/*.vue`) 的 `<script setup>` 中使用 `definePageMeta` 宏来**手动应用**。
    *   **执行时机**: 仅当导航到**明确指定**了该中间件的页面时执行。

    ```typescript
    // middleware/auth.ts
    export default defineNuxtRouteMiddleware((to, from) => {
      // 假设 useAuth() 是你的认证逻辑 Composable
      const { isLoggedIn, user } = useAuth(); // 需要能在此上下文访问状态

      // 如果目标路由需要认证，但用户未登录
      if (to.meta.requiresAuth && !isLoggedIn.value) {
        console.log('Auth middleware: User not logged in, redirecting to /login');
        // 保存尝试访问的路径，以便登录后重定向回来
        return navigateTo({ path: '/login', query: { redirect: to.fullPath } });
      }

      // 如果目标路由需要特定角色，但用户角色不符
      if (to.meta.requiredRole && user.value?.role !== to.meta.requiredRole) {
          console.log(`Auth middleware: User role mismatch (${user.value?.role} vs ${to.meta.requiredRole})`);
          return abortNavigation(`Insufficient permissions for role: ${to.meta.requiredRole}`);
          // 或者重定向到权限不足页面
          // return navigateTo('/unauthorized');
          // 或者抛出错误显示错误页
          // throw createError({ statusCode: 403, message: 'Forbidden - Insufficient role' });
      }

      // 如果检查通过，则不返回任何内容，允许导航继续
      console.log('Auth middleware: Check passed.');
    });
    ```

    ```vue
    <!-- pages/dashboard.vue -->
    <script setup>
    definePageMeta({
      middleware: 'auth', // 应用名为 'auth' 的中间件
      // 你也可以传递一个数组来应用多个中间件，它们会按顺序执行
      // middleware: ['auth', 'check-subscription'],
      // 可以在 meta 中添加自定义字段供中间件读取
      requiresAuth: true,
      requiredRole: 'admin'
    });
    </script>
    <template>
      <h1>仪表盘 (需要登录和 Admin 角色)</h1>
      <!-- ... -->
    </template>
    ```

2.  **全局中间件 (Global Middleware)**
    *   **定义**: 文件名需要以 `.global` 后缀结尾，例如 `middleware/logger.global.ts`。
    *   **应用**: **自动应用**于每一次路由导航，无需在页面中指定。
    *   **执行时机**: 在**每次**路由变化时都会执行，且在具名中间件**之前**执行。

    ```typescript
    // middleware/logger.global.ts
    export default defineNuxtRouteMiddleware((to, from) => {
      // 这个中间件会在每次路由变化时运行
      console.log(`[Global Logger] Navigating from ${from.fullPath} to ${to.fullPath}`);

      // 全局中间件也可以执行检查或重定向逻辑
      // if (to.path === '/maintenance' && !isAdmin()) {
      //   return navigateTo('/');
      // }

      // 通常全局中间件用于日志、分析或非常通用的检查
      // 记得不要在这里做耗时操作，因为它会影响每次导航
    });
    ```

**执行顺序：**

当导航到一个新页面时，中间件的执行顺序如下：

1.  **全局中间件**：按照**文件名**的字母顺序依次执行。
2.  **具名（路由）中间件**：按照在页面 `definePageMeta` 中 `middleware` 数组里定义的顺序依次执行。

**重要：如果任何一个中间件执行了 `navigateTo`, `abortNavigation` 或抛出错误，后续的所有中间件（包括全局和具名）以及最终的页面导航都将被取消。**

**异步中间件：**

中间件函数可以是 `async` 函数，允许你在内部执行异步操作（例如，检查服务器上的会话）。

```typescript
// middleware/async-check.ts
export default defineNuxtRouteMiddleware(async (to, from) => {
  console.log('Starting async check...');
  try {
    // 假设 checkUserSession 是一个返回 Promise 的异步函数
    const sessionValid = await checkUserSession();
    if (!sessionValid && to.meta.requiresAuth) {
      console.log('Async check: Session invalid, redirecting.');
      return navigateTo('/login');
    }
    console.log('Async check: Session valid or not required.');
  } catch (error) {
    console.error('Async check failed:', error);
    // 可以根据错误类型决定是中止导航还是显示错误页
    return abortNavigation('Session check failed');
    // throw createError({ statusCode: 500, message: 'Session check error' });
  }
});
```

**总结：**

*   路由中间件是在导航到页面**之前**执行的钩子函数。
*   放在 `middleware/` 目录下，使用 `defineNuxtRouteMiddleware` 定义。
*   通过文件名区分**全局** (`*.global.ts`) 和**具名** (`*.ts`) 中间件。
*   全局中间件自动应用于所有路由；具名中间件需在 `definePageMeta` 中指定。
*   使用 `navigateTo`, `abortNavigation`, `createError` 控制导航流程。
*   无返回值表示允许导航继续。
*   可用于认证、授权、重定向、日志记录等场景。
*   可以是异步函数。

路由中间件是 Nuxt 中控制和保护页面访问权限、实现通用路由逻辑的重要工具。