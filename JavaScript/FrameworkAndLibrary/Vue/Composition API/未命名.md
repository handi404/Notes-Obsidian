Drawbacks of the Options API选项 API 的缺点
Composition API basics组合式 API 基础
Template refs (again)模板引用（再次）
Using refs for reactivity使用 refs 进行响应式
Refs vs Reactive引用 vs 响应式
Computed values计算值
watch & watchEffect监视 & 观察效果

```vue
<script>
export default {
  //setup 最先其次 created mounted
  setup() {
    console.log("setup")
  },
  created() {
    console.log("created")
  },
  mounted() {
    console.log("mounted")
  }
}
</script>
```

setup 和 data 的不同
setup 中的值不是反应值，data 中的时被动的反应值，若改变会反映在 template 中

使用 Composition API 的最基础的方法创建一个设置函数或一个设置钩子，总是先运行，然后是创建，然后是挂载

Template refs模板引用 ref 与 dom 元素关联 
```vue
<template>
  <div class="home">
    Home
    <p ref="p">My name is {{ name }}, age is {{ age }}</p>
    <button @click="handleClick">click me</button>
  </div>
</template>


<script>
import { ref } from "vue";
export default {
  setup() {
    let name = "Home";
    let age = 25;
    let p = ref(null);
    console.log(p, p.value);//这里的p.value与下面的不同
    const handleClick = (params) => {
      console.log(p, p.value);//
      p.value.textContent = "hello, world";
    };
    return {
      name,
      age,
      handleClick,
      p,
    };
  },
};
</script>
<style></style>
```
很少使用模板引用因为我觉得就像我需要做的所有操作 dom 内容的事情都可以通过其他方式使用 vue 来完成, 但在使用 Composition API 时 ref 还有另一个非常非常重要的作用可以用来使值具有响应性

Using refs for reactivity 使用 refs 进行响应式
setup 中的变量不是反应变量，这意味着当它们改变时它不会自动更新模板中的这些值
```vue
<template>
  <div class="home">
    Home
    <p>My name is {{ name }}, age is {{ age }}</p>
    <button @click="handleClick">click me</button>
    <button @click="age++">add 1 to age</button>
    <input type="text" v-model="name" />
  </div>
</template>

<script>
import { ref } from "vue";
export default {
  setup() {
    const name = ref("Home");
    const age = ref(25);
    console.log(name, age);
    const handleClick = (params) => {
      name.value = "Home Clicked";
      age.value = 26;
    };
    return {
      name,
      age,
      handleClick,
    };
  },
};
</script>
<style></style>

```
ref 是被动的，当它们像这样更新时，它们也会在模板中更新,这样它们就是响应式值

Refs vs Reactive 引用 vs 响应式
已经了解了如何使用 refs 来创建响应式值, 还有另一种方法可以在 vue 中创建它们，那就是通过使用从 vue 库中导入的 Reactive
```vue
<template>
  <div class="home">
    <h1>Home</h1>
    <h2>Refs</h2>
    <p>{{ personOne.name }} - {{ personOne.age }}</p>
    <button @click="personOneUpdate">Update person one</button>
    <h2>Reactive</h2>
    <p>{{ personTwo.name }} - {{ personTwo.age }}</p>
    <button @click="personTwoUpdate">Update person two</button>
  </div>
</template>

<script>
import { reactive, ref } from "vue";
export default {
  setup() {
    const personOne = ref({ name: "mario", age: 25 });
    const personTwo = reactive({ name: "luigi", age: 30 });
    const personOneUpdate = (params) => {
      personOne.value.age = 40;
    };
    const personTwoUpdate = (params) => {
      personTwo.age = 35;
    };
    return {
      personOne,
      personOneUpdate,
      personTwo,
      personTwoUpdate,
    };
  },
};
</script>
<style></style>
```
当我们使用 Reactive 时，我们不需要说 .value，可以直接访问它的属性,这是主要原因之一 ref reactive 之间的区别使用
但是使用 Reactive 有一些缺点第一个缺点是我们不能在 Reactive 中使用原始值，所以如果我要做一下代码时无法实现的
```js
const name = reactive("mario")
const nameupdate = () => {
	name = "luio"
	name = reactive("luio")
}
```
其次，当我们稍后创建外部组合函数时，refs 也会更好地工作，它们在被这些外部函数暴露时保留了它们的反应性。所以通常我只会使用refs

Computed values 计算值
定义**基于响应式数据的派生值**，在数据依赖发生变化时自动更新，同时具备缓存机制，避免不必要的重新计算。(就是**根据已有数据计算出一个新数据**，而且只有当原数据变了，才会重新计算，节省性能。)
```vue
<template>
  <div class="home">
    <h1>Home</h1>
    <input type="text" v-model="search" />
    <p>search term - {{ search }}</p>
    <div v-for="name in matchingNames" :key="name">
      {{ name }}
    </div>
  </div>
</template>

<script>
import { computed, reactive, ref } from "vue";
export default {
  setup() {
    const names = ref(["John", "Mario", "Jane", "Doe", "Foo", "Bar"]);
    const search = ref("");
    const matchingNames = computed(() => {
      return names.value.filter((name) => name.includes(search.value));
    });
    return {
      names,
      search,
      matchingNames,
    };
  },
};
</script>
<style></style>
```

watch & watchEffect 监视 & 观察效果
当使用 composition api 还可以访问几个特殊的钩子或函数称为 watch 和 watch effect，两个函数是我们在特定值发生变化时运行一些代码的一种方式
**watch** 第一个参数，即我们想要监视的内容，第二个参数，即每次数值发生变化时 watch 都会触发的一个函数
**watchEffect** 与 watch 类似，但 watchEffect **不需要参数**并且**当组件首次加载时或当setup 函数首次运行时最初运行的第一件事就是执行 watchEffect**，它会观看函数内部的任何依赖项(我们在其中使用的任何值)，例如 search.value，它都会监视该值，并且当该值发生变化时，它将自动运行此函数，就我个人而言，我发现自己使用 watch effect 的次数比watch 多得多，部分原因是我**不需要列出我的监视列表**，但也因为有时我希望该功能立即运行获取组件的一些数据
watch 和 watchEffect 的返回值都是函数，要想 stop watch 执行返回的函数即可
```vue
<template>
  <div class="home">
    <h1>Home</h1>
    <input type="text" v-model="search" />
    <p>search term - {{ search }}</p>
    <div v-for="name in matchingNames" :key="name">
      {{ name }}
    </div>
    <button @click="stopAllWatch">stop watching</button>
  </div>
</template>

<script>
import { computed, watch, ref, watchEffect } from "vue";
export default {
  setup() {
    const names = ref(["John", "Mario", "Jane", "Doe", "Foo", "Bar"]);
    const search = ref("");
    const stopWatch = watch(search, () => {
      console.log("watch function run");
    });
    const stopWatchEffect = watchEffect(() => {
      console.log("watchEffect function run", search.value);
    });
    const stopAllWatch = (params) => {
      stopWatch();
      stopWatchEffect();
    };
    const matchingNames = computed(() => {
      return names.value.filter((name) => name.includes(search.value));
    });
    return {
      names,
      search,
      matchingNames,
      stopAllWatch,
    };
  },
};
</script>
<style></style>

```


展示如何在 Composition API 中使用 props