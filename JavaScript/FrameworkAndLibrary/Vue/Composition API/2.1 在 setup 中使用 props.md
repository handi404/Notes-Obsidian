在 setup 函数中访问 props, setup(props) 即可
```vue
<!--------------------Home.vue----------------------->
<template>
  <div class="home">
    <h1>Home</h1>
    <PostList :posts="posts" />
  </div>
</template>
<script>
import { computed, watch, ref, watchEffect } from "vue";
import PostList from "../components/PostList.vue";
export default {
  components: {
    PostList,
  },
  setup() {
    const posts = ref([
      {
        title: "welcome to the blog",
        body: "Lorem ipsum dolor, sit amet consectetur adipisicing elit. Minus quo repudiandae labore iusto ut nisi suscipit, mollitia ex, rem id obcaecati consectetur tenetur commodi doloribus facilis rerum autem beatae ab!",
        id: 1,
      },
      { title: "top 5 css tips", body: "Lorem ipsum", id: 2 },
    ]);
    return {
      posts,
    };
  },
};
</script>
<!--------------------PostList.vue------------------------->
<template>
  <div class="post-list">
    <div v-for="post in posts" :key="post.id">
      <SinglePost :post="post" />
    </div>
  </div>
</template>
<script>
import SinglePost from "./SinglePost.vue";
export default {
  props: ["posts"],
  components: {
    SinglePost,
  },
  setup(props) {
    console.log(props.posts);
  },
};
</script>
<!--------------------SinglePost.vue------------------------->
<template>
  <div class="post">
    <h3>{{ post.title }}</h3>
    <p>{{ snippet }}</p>
  </div>
</template>
<script>
import { computed } from "vue";
export default {
  props: ["post"],
  setup(props) {
    const snippet = computed(() => {
      return props.post.body.substring(0, 100) + "....";
    });
    return {
      snippet,
    };
  },
};
</script>
```

---

# **在 `setup()` 中使用 `props` 详解**

在 Vue 3 的 `setup()` 组合式 API (`Composition API`) 中，`props` 用于接收父组件传递的数据。Vue 3 的 `setup()` 使 `props` 更加直观，但也有一些新的注意事项。

---

## **1. `setup(props)` 的基本使用**

`setup()` 的第一个参数是 `props`，它是一个**只读的响应式对象**，用于接收父组件传递的值。

### **示例：基础 `props` 传递**

#### **父组件 (`Parent.vue`)**

```vue
<template>
  <Child message="Hello Vue 3!" />
</template>

<script>
import Child from './Child.vue';

export default {
  components: { Child }
};
</script>
```

#### **子组件 (`Child.vue`)**

```vue
<template>
  <p>父组件传来的消息: {{ message }}</p>
</template>

<script>
export default {
  props: {
    message: String
  },
  setup(props) {
    console.log(props.message); // "Hello Vue 3!"
    return { message: props.message };
  }
};
</script>
```

### **📌 解析**

1. `setup(props)` 直接接收父组件传来的 `props`。
2. **`props` 是响应式的**，当 `message` 发生变化时，组件会自动更新。
3. **`props` 是只读的**，不能直接修改 `props.message`，否则 Vue 会抛出警告。

---

## **2. 直接解构 `props`（要小心！）**

如果直接使用 ES6 解构 `props`，会丢失其响应性。

### **错误示例（丢失响应性）**

```vue
<script>
export default {
  props: {
    message: String
  },
  setup({ message }) { // ❌ 直接解构，message 不是响应式的
    console.log(message); // 不是响应式数据
    return { message };
  }
};
</script>
```

> 这样 `message` **不会在 `props` 变化时更新**，因为解构赋值会丢失响应性。

### **正确示例（保持响应性）**

```vue
<script>
import { toRefs } from 'vue';

export default {
  props: {
    message: String
  },
  setup(props) {
    const { message } = toRefs(props); // ✅ 保持响应性
    return { message };
  }
};
</script>
```

### **📌 解析**

- `toRefs(props)` 让 `message` 仍然保持响应式，不会丢失 `props` 的 reactivity。

---

## **3. 使用 `defineProps()`（在 `<script setup>` 语法中）**

如果使用 `<script setup>` 语法，可以用 `defineProps()` 代替 `props`。

### **示例：`defineProps()` 方式**

```vue
<template>
  <p>父组件传来的消息: {{ message }}</p>
</template>

<script setup>
const props = defineProps({
  message: String
});

console.log(props.message); // "Hello Vue 3!"
</script>
```

### **📌 解析**

- `defineProps()` 只在 `<script setup>` 语法中可用，且不需要 `export default`。
- `props` 仍然是只读的，不能直接修改。

---

## **4. 设置默认值**

`props` 没有传值时，可以设置默认值。

### **示例：使用 `default` 设置默认值**

```vue
<template>
  <p>用户名: {{ username }}</p>
</template>

<script>
export default {
  props: {
    username: {
      type: String,
      default: '游客'
    }
  },
  setup(props) {
    return { username: props.username };
  }
};
</script>
```

### **📌 解析**

- 如果父组件未传 `username`，`props.username` 默认值为 `'游客'`。

---

## **5. 传递对象 `props`**

可以传递对象类型的 `props`，并在 `setup()` 中解构。

### **示例：对象类型 `props`**

```vue
<template>
  <p>姓名: {{ user.name }}</p>
  <p>年龄: {{ user.age }}</p>
</template>

<script>
import { toRefs } from 'vue';

export default {
  props: {
    user: Object
  },
  setup(props) {
    const { user } = toRefs(props); // 保持响应性
    return { user };
  }
};
</script>
```

### **📌 解析**

- `toRefs(props)` 确保 `user` 保持响应性，否则 `user` 变更不会触发更新。

---

## **6. `props` 与 `computed` 结合**

可以使用 `computed` 处理 `props`，生成**新的计算属性**。

### **示例：计算属性基于 `props`**

```vue
<template>
  <p>原价: {{ price }}</p>
  <p>折扣价: {{ discountedPrice }}</p>
</template>

<script>
import { computed } from 'vue';

export default {
  props: {
    price: Number
  },
  setup(props) {
    const discountedPrice = computed(() => props.price * 0.9);
    return { discountedPrice };
  }
};
</script>
```

### **📌 解析**

- `computed(() => props.price * 0.9)` 创建折扣价，`props.price` 变更时会自动更新。

---

## **7. `props` 与 `watch` 结合**

可以用 `watch` 监听 `props` 变化，并执行操作。

### **示例：监听 `props` 变化**

```vue
<template>
  <p>当前计数: {{ count }}</p>
</template>

<script>
import { watch } from 'vue';

export default {
  props: {
    count: Number
  },
  setup(props) {
    watch(() => props.count, (newVal, oldVal) => {
      console.log(`计数变化: ${oldVal} -> ${newVal}`);
    });

    return {};
  }
};
</script>
```

### **📌 解析**

- `watch(() => props.count, callback)` 监听 `props.count` 变化并执行回调。

---

## **8. `props` 与 `emit` 结合**

Vue 组件通常**不能直接修改 `props`**，应通过 `emit` 让父组件更新 `props`。

### **示例：使用 `emit` 更新 `props`**

#### **父组件 (`Parent.vue`)**

```vue
<template>
  <Child :count="count" @update-count="count = $event" />
</template>

<script>
import Child from './Child.vue';
import { ref } from 'vue';

export default {
  components: { Child },
  setup() {
    const count = ref(0);
    return { count };
  }
};
</script>
```

#### **子组件 (`Child.vue`)**

```vue
<template>
  <p>计数: {{ count }}</p>
  <button @click="updateCount">增加</button>
</template>

<script>
export default {
  props: {
    count: Number
  },
  emits: ['update-count'],
  setup(props, { emit }) {
    const updateCount = () => {
      emit('update-count', props.count + 1);
    };

    return { updateCount };
  }
};
</script>
```

### **📌 解析**

- 子组件不能直接修改 `props.count`，应使用 `emit('update-count', 新值)` 让父组件更新。

---

## **9. 总结**

|功能|代码示例|
|---|---|
|**基础 `props` 传递**|`setup(props) { return { message: props.message } }`|
|**保持响应性**|`const { message } = toRefs(props);`|
|**默认值**|`default: '游客'`|
|**监听 `props` 变化**|`watch(() => props.count, callback)`|
|**`computed` 计算 `props`**|`computed(() => props.price * 0.9)`|
|**更新 `props`（使用 `emit`）**|`emit('update-count', props.count + 1)`|

Vue 3 在 `setup()` 中使用 `props` 变得更加直观，但要注意 `props` 是**只读的**，不能直接修改！