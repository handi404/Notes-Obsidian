定义**基于响应式数据的派生值**，在数据依赖发生变化时自动更新，同时具备缓存机制，避免不必要的重新计算。(就是**根据已有数据计算出一个新数据**，而且只有当原数据变了，才会重新计算，节省性能。)
```vue
<template>
  <div class="home">
    <h1>Home</h1>
    <input type="text" v-model="search" />
    <p>search term - {{ search }}</p>
    <div v-for="name in matchingNames" :key="name">
      {{ name }}
    </div>
  </div>
</template>

<script>
import { computed, reactive, ref } from "vue";
export default {
  setup() {
    const names = ref(["John", "Mario", "Jane", "Doe", "Foo", "Bar"]);
    const search = ref("");
    const matchingNames = computed(() => {
      return names.value.filter((name) => name.includes(search.value));
    });
    return {
      names,
      search,
      matchingNames,
    };
  },
};
</script>
<style></style>
```

---

# **Vue 3 Computed 详解（使用 `setup()` 形式）**

在 Vue 3 组合式 API (`Composition API`) 中，`computed`（计算属性）用于基于**现有数据**派生出新的数据，并在依赖数据变更时**自动更新**。它可以有效优化性能，避免重复计算。

---

## **1. `computed` 的基本用法**

在 `setup()` 中，`computed` 创建的计算属性是**响应式**的，会自动监听依赖的 `ref` 变量，并在它们变化时更新值。

### **示例：基本计算属性**

```vue
<template>
  <p>原价: {{ price }}</p>
  <p>折扣价: {{ discountedPrice }}</p>
  <button @click="increasePrice">涨价</button>
</template>

<script>
import { ref, computed } from 'vue';

export default {
  setup() {
    const price = ref(100); // 原价
    const discountedPrice = computed(() => price.value * 0.9); // 计算折扣价

    const increasePrice = () => {
      price.value += 10;
    };

    return { price, discountedPrice, increasePrice };
  }
};
</script>
```

### **📌 解析**

- `computed(() => price.value * 0.9)` 定义 `discountedPrice` 计算属性。
- `discountedPrice` **依赖 `price.value`**，当 `price` 变化时，它会自动更新。
- `computed` **内部有缓存机制**，如果 `price` 没变，`discountedPrice` 不会重新计算。

---

## **2. `computed` VS `methods`**

|方式|计算方式|是否缓存|适用场景|
|---|---|---|---|
|**computed**|依赖数据变化时自动计算|**是**|适用于计算开销大、依赖数据会改变的情况|
|**methods**|每次调用时都重新计算|**否**|适用于不依赖数据的计算|

### **示例：对比 `computed` 与 `methods`**

```vue
<template>
  <p>Computed: {{ computedResult }}</p>
  <p>Method: {{ getMethodResult() }}</p>
  <button @click="count++">增加</button>
</template>

<script>
import { ref, computed } from 'vue';

export default {
  setup() {
    const count = ref(0);

    // computed 方式（有缓存）
    const computedResult = computed(() => {
      console.log("Computed 计算");
      return count.value * 2;
    });

    // methods 方式（无缓存，每次调用都执行）
    const getMethodResult = () => {
      console.log("Method 计算");
      return count.value * 2;
    };

    return { count, computedResult, getMethodResult };
  }
};
</script>
```

### **📌 解析**

- `computed` 只有 `count` 变化时才会重新计算，**不会在每次调用时重复计算**。
- `methods` **每次渲染都会执行**，性能较低。

---

## **3. 计算属性的 `getter` 和 `setter`**

`computed` 默认是**只读**的，但可以提供 `getter` 和 `setter` 让其变为可写。

### **示例：可写计算属性**

```vue
<template>
  <p>摄氏温度: {{ celsius }}</p>
  <p>华氏温度: <input v-model="fahrenheit" /></p>
</template>

<script>
import { ref, computed } from 'vue';

export default {
  setup() {
    const celsius = ref(0);

    const fahrenheit = computed({
      get: () => (celsius.value * 9) / 5 + 32, // 读取时转换为华氏度
      set: (newValue) => {
        celsius.value = ((newValue - 32) * 5) / 9; // 设置时转换回摄氏度
      }
    });

    return { celsius, fahrenheit };
  }
};
</script>
```

### **📌 解析**

- `computed({ get, set })` 创建**可读写**计算属性。
- `fahrenheit` 绑定 `input`，输入值变化时自动更新 `celsius`。
- `celsius` 变更时，`fahrenheit` 也会自动更新。

---

## **4. 计算属性依赖多个 `ref`**

`computed` 可以依赖多个 `ref` 数据。

### **示例：依赖多个 `ref`**

```vue
<template>
  <p>姓名: {{ fullName }}</p>
  <button @click="updateName">修改姓</button>
</template>

<script>
import { ref, computed } from 'vue';

export default {
  setup() {
    const firstName = ref('张');
    const lastName = ref('三');

    const fullName = computed(() => `${firstName.value} ${lastName.value}`);

    const updateName = () => {
      firstName.value = '李';
    };

    return { fullName, updateName };
  }
};
</script>
```

### **📌 解析**

- `computed(() => firstName.value + lastName.value)` 监听 `firstName` 和 `lastName`。
- 修改 `firstName.value` 时，`fullName` 也会自动更新。

---

## **5. `computed` 结合 `watch`**

如果需要在**计算属性变化时执行额外操作**，可以使用 `watch` 监听 `computed` 值。

### **示例：监听 `computed`**

```vue
<script>
import { ref, computed, watch } from 'vue';

export default {
  setup() {
    const count = ref(0);

    const doubleCount = computed(() => count.value * 2);

    watch(doubleCount, (newValue, oldValue) => {
      console.log(`doubleCount 变化: ${oldValue} -> ${newValue}`);
    });

    return { count, doubleCount };
  }
};
</script>
```

### **📌 解析**

- `watch(doubleCount, callback)` 监听 `computed` 值的变化。
- 只有 `count` 变化导致 `doubleCount` 变更时，`watch` 才会触发。

---

## **6. `computed` VS `watch`**

|特性|`computed`|`watch`|
|---|---|---|
|**是否返回值**|返回新值|监听变化，通常不返回|
|**是否有缓存**|**有缓存**|无缓存，每次依赖变更都会触发|
|**适用场景**|需要派生新值的情况|依赖变化时执行副作用（如 API 调用）|

---

## **7. `computed` 在 `template` 中的使用**

`computed` 直接在模板中使用，无需 `.value`。

```vue
<template>
  <p>价格: {{ discountedPrice }}</p>
</template>

<script>
import { ref, computed } from 'vue';

export default {
  setup() {
    const price = ref(100);
    const discountedPrice = computed(() => price.value * 0.9);

    return { discountedPrice };
  }
};
</script>
```

**Vue 自动解包 `computed` 的 `.value`**，所以模板中可直接使用 `discountedPrice`。

---

## **8. 总结**

|功能|代码示例|
|---|---|
|**基本计算属性**|`computed(() => count.value * 2);`|
|**可读写计算属性**|`computed({ get, set });`|
|**依赖多个数据**|`computed(() => firstName.value + lastName.value);`|
|**监听 `computed`**|`watch(computedVar, callback);`|

`computed` 适用于派生新数据，避免重复计算，并且 Vue 内部提供**缓存机制**，可以优化性能。