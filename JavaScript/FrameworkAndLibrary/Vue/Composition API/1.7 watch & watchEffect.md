当使用 composition api 还可以访问几个特殊的钩子或函数称为 watch 和 watch effect，两个函数是我们在特定值发生变化时运行一些代码的一种方式
**watch** 第一个参数，即我们想要监视的内容，第二个参数，即每次数值发生变化时 watch 都会触发的一个函数
**watchEffect** 与 watch 类似，但 watchEffect **不需要参数**并且**当组件首次加载时或当 setup 函数首次运行时最初运行的第一件事就是执行 watchEffect**，它会观看函数内部的任何依赖项(我们在其中使用的任何值)，例如 search.value，它都会监视该值，并且当该值发生变化时，它将自动运行此函数，就我个人而言，我发现自己使用 watch effect 的次数比 watch 多得多，部分原因是我**不需要列出我的监视列表**，但也因为有时我希望该功能立即运行获取组件的一些数据
watch 和 watchEffect 的返回值都是函数，要想 stop watch 执行返回的函数即可
```vue
<template>
  <div class="home">
    <h1>Home</h1>
    <input type="text" v-model="search" />
    <p>search term - {{ search }}</p>
    <div v-for="name in matchingNames" :key="name">
      {{ name }}
    </div>
    <button @click="stopAllWatch">stop watching</button>
  </div>
</template>

<script>
import { computed, watch, ref, watchEffect } from "vue";
export default {
  setup() {
    const names = ref(["John", "Mario", "Jane", "Doe", "Foo", "Bar"]);
    const search = ref("");
    const stopWatch = watch(search, () => {
      console.log("watch function run");
    });
    const stopWatchEffect = watchEffect(() => {
      console.log("watchEffect function run", search.value);
    });
    const stopAllWatch = (params) => {
      stopWatch();
      stopWatchEffect();
    };
    const matchingNames = computed(() => {
      return names.value.filter((name) => name.includes(search.value));
    });
    return {
      names,
      search,
      matchingNames,
      stopAllWatch,
    };
  },
};
</script>
<style></style>
```

---

# **Vue 3 `watch` 和 `watchEffect` 详解（使用 `setup()` 形式）**

在 Vue 3 组合式 API (`Composition API`) 中，`watch` 和 `watchEffect` 用于监听数据变化并执行副作用操作。

- `watch` **监听指定的响应式数据**，适用于精确控制监听的依赖。
- `watchEffect` **自动收集依赖**，适用于**不确定依赖项**的情况。

---

# **1. `watch` 的基本用法**

`watch` 监听**指定的响应式数据**（`ref` 或 `computed`），当数据变化时执行回调函数。

## **示例：监听 `ref`**

```vue
<template>
  <p>计数: {{ count }}</p>
  <button @click="count++">增加</button>
</template>

<script>
import { ref, watch } from 'vue';

export default {
  setup() {
    const count = ref(0);

    watch(count, (newValue, oldValue) => {
      console.log(`count 变化: ${oldValue} -> ${newValue}`);
    });

    return { count };
  }
};
</script>
```

### **📌 解析**

- `watch(count, callback)` 监听 `count.value` 的变化。
- 当 `count.value` 变化时，会执行回调，并打印**旧值 → 新值**。

---

# **2. `watch` 监听多个数据**

`watch` 也可以监听**多个响应式变量**。

## **示例：监听多个 `ref`**

```vue
<script>
import { ref, watch } from 'vue';

export default {
  setup() {
    const firstName = ref('张');
    const lastName = ref('三');

    watch([firstName, lastName], ([newFirst, newLast], [oldFirst, oldLast]) => {
      console.log(`姓名变化: ${oldFirst} ${oldLast} -> ${newFirst} ${newLast}`);
    });

    return { firstName, lastName };
  }
};
</script>
```

### **📌 解析**

- `watch([firstName, lastName], callback)` 监听**多个 `ref`** 变量。
- **回调的参数**：
    - `newValues = [newFirst, newLast]`
    - `oldValues = [oldFirst, oldLast]`

---

# **3. `watch` 监听对象的某个属性**

如果 `watch` 监听对象，默认不会**深度监听**（对象的属性变化不会触发 `watch`）。

## **示例：监听对象属性**

```vue
<script>
import { ref, watch } from 'vue';

export default {
  setup() {
    const user = ref({ name: '张三', age: 18 });

    watch(
      () => user.value.name, // 监听 user.name
      (newName, oldName) => {
        console.log(`姓名变化: ${oldName} -> ${newName}`);
      }
    );

    return { user };
  }
};
</script>
```

### **📌 解析**

- `watch(() => user.value.name, callback)` **只监听 `name` 变化**，而 `age` 变化不会触发。

---

# **4. `watch` 监听整个对象（深度监听）**

如果要监听**对象内部所有属性的变化**，需要使用 `deep: true`。

## **示例：深度监听对象**

```vue
<script>
import { ref, watch } from 'vue';

export default {
  setup() {
    const user = ref({ name: '张三', age: 18 });

    watch(
      user,
      (newUser, oldUser) => {
        console.log('用户数据变更:', newUser);
      },
      { deep: true } // 深度监听
    );

    return { user };
  }
};
</script>
```

### **📌 解析**

- `{ deep: true }` 使 `watch` 监听**对象的所有属性**。
- 修改 `user.value.age` 或 `user.value.name` 都会触发 `watch`。

---

# **5. `watch` 监听 `computed` 计算属性**

`watch` 也可以监听 `computed` 派生的值。

## **示例：监听 `computed`**

```vue
<script>
import { ref, computed, watch } from 'vue';

export default {
  setup() {
    const price = ref(100);
    const discountPrice = computed(() => price.value * 0.9);

    watch(discountPrice, (newVal, oldVal) => {
      console.log(`折扣价变化: ${oldVal} -> ${newVal}`);
    });

    return { price, discountPrice };
  }
};
</script>
```

### **📌 解析**

- `watch(discountPrice, callback)` 监听 `computed` 值的变化。

---

# **6. `watchEffect`（自动收集依赖）**

`watchEffect` **自动追踪依赖项**，适用于不确定要监听哪些数据的情况。

## **示例：`watchEffect` 自动追踪**

```vue
<script>
import { ref, watchEffect } from 'vue';

export default {
  setup() {
    const count = ref(0);
    const doubleCount = ref(0);

    watchEffect(() => {
      doubleCount.value = count.value * 2;
      console.log(`count: ${count.value}, doubleCount: ${doubleCount.value}`);
    });

    return { count, doubleCount };
  }
};
</script>
```

### **📌 解析**

- `watchEffect()` **自动监听 `count` 变化**，无需手动指定依赖项。
- 当 `count.value` 变化时，`doubleCount` 也会自动更新。

---

# **7. `watchEffect` VS `watch`**

|特性|`watch`|`watchEffect`|
|---|---|---|
|**监听方式**|监听**指定**变量|**自动收集**依赖|
|**是否需要返回值**|`newValue, oldValue`|无参数|
|**是否支持深度监听**|需要 `deep: true`|默认监听所有依赖|
|**适用场景**|监听特定数据|监听多个数据变化|

---

# **8. `watchEffect` 立即执行**

`watchEffect` 在**组件加载时立即执行一次**，而 `watch` 只在数据变化时执行。

## **示例：`watchEffect` 立即执行**

```vue
<script>
import { ref, watchEffect } from 'vue';

export default {
  setup() {
    const message = ref('Hello');

    watchEffect(() => {
      console.log(`message: ${message.value}`);
    });

    return { message };
  }
};
</script>
```

### **📌 解析**

- `watchEffect()` **在 `setup()` 时立即执行一次**，然后每次 `message.value` 变化时都会执行。

---

# **9. `watchEffect` 取消监听**

可以使用 `watchEffect()` 返回的 `stop()` 方法**取消监听**。

## **示例：手动停止监听**

```vue
<script>
import { ref, watchEffect } from 'vue';

export default {
  setup() {
    const count = ref(0);

    const stopWatch = watchEffect(() => {
      console.log(`count: ${count.value}`);
    });

    const stop = () => stopWatch(); // 停止监听

    return { count, stop };
  }
};
</script>
```

### **📌 解析**

- `watchEffect()` 返回 `stop()` 方法，可手动停止监听。

---

# **10. 总结**

|功能|`watch`|`watchEffect`|
|---|---|---|
|**是否指定监听变量**|**是**，必须指定|**否**，自动收集依赖|
|**回调参数**|`(newVal, oldVal)`|无参数|
|**立即执行**|**否**，仅在数据变化时执行|**是**，立即执行一次|
|**深度监听**|需要 `deep: true`|默认监听所有依赖|

`watch` 适用于监听**指定的数据**，而 `watchEffect` 适用于**自动收集依赖**的场景，例如监听多个变量的变化。