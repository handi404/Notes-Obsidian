setup 中的变量不是反应变量，这意味着当它们改变时它不会自动更新模板中的这些值，这个时候就需要在 setup 中使用 ref
```vue
<template>
  <div class="home">
    Home
    <p>My name is {{ name }}, age is {{ age }}</p>
    <button @click="handleClick">click me</button>
    <button @click="age++">add 1 to age</button>
    <input type="text" v-model="name" />
  </div>
</template>

<script>
import { ref } from "vue";
export default {
  setup() {
    const name = ref("Home");
    const age = ref(25);
    console.log(name, age);
    const handleClick = (params) => {
      name.value = "Home Clicked";
      age.value = 26;
    };
    return {
      name,
      age,
      handleClick,
    };
  },
};
</script>
<style></style>
```
ref 是被动的，当它们像这样更新时，它们也会在模板中更新,这样它们就是响应式值

---

## **Vue 3 `ref` 详解（使用 `setup()` 形式）**

在 Vue 3 组合式 API (`Composition API`) 中，`ref` 是创建**响应式数据**的核心 API 之一。它允许在 `setup()` 中创建响应式变量，并在模板中自动更新 UI。

---

## **1. `setup()` 中使用 `ref`**

在 `setup()` 中，`ref` 创建的变量可以直接绑定到模板。

### **示例：基本数据类型**

```vue
<template>
  <p>当前计数：{{ count }}</p>
  <button @click="increment">增加</button>
</template>

<script>
import { ref } from 'vue';

export default {
  setup() {
    const count = ref(0); // 创建响应式变量

    const increment = () => {
      count.value++; // 修改 ref 变量
    };

    return { count, increment }; // 必须返回给模板
  }
};
</script>
```

### **📌 解析**

- `ref(0)`: `count` 变成响应式数据。
- `count.value++`: `ref` 变量必须通过 `.value` 访问和修改。
- `setup()` 返回的 `count` 和 `increment` 可在模板中使用。

---

## **2. `ref` 绑定对象**

### **示例：使用 `ref` 绑定对象**

```vue
<template>
  <p>姓名：{{ user.name }}</p>
  <button @click="updateName">修改姓名</button>
</template>

<script>
import { ref } from 'vue';

export default {
  setup() {
    const user = ref({ name: '张三' });

    const updateName = () => {
      user.value.name = '李四'; // 修改 ref 对象的属性
    };

    return { user, updateName };
  }
};
</script>
```

### **📌 解析**

- `ref({ name: '张三' })`: `user` 变成一个响应式对象。
- **修改 `user.value.name` 时，Vue 自动更新 UI**。

---

## **3. `ref` 绑定数组**

### **示例：操作响应式数组**

```vue
<template>
  <ul>
    <li v-for="(item, index) in list" :key="index">{{ item }}</li>
  </ul>
  <button @click="addItem">添加项</button>
</template>

<script>
import { ref } from 'vue';

export default {
  setup() {
    const list = ref(['苹果', '香蕉', '橙子']);

    const addItem = () => {
      list.value.push('新项'); // 添加新元素
    };

    return { list, addItem };
  }
};
</script>
```

### **📌 解析**

- `ref([])`: `list` 变成一个响应式数组。
- `list.value.push('新项')`: 修改数组时**仍然需要 `.value`**。

---

## **4. `ref` 监听数据变化**

### **示例：`watch()` 监听 `ref`**

```vue
<script>
import { ref, watch } from 'vue';

export default {
  setup() {
    const count = ref(0);

    watch(count, (newVal, oldVal) => {
      console.log(`count 变化: ${oldVal} -> ${newVal}`);
    });

    const increment = () => {
      count.value++;
    };

    return { count, increment };
  }
};
</script>
```

### **📌 解析**

- `watch(count, callback)`: 监听 `count.value` 的变化。
- 触发 `increment()` 后，`watch()` 会打印出 `oldVal -> newVal`。

---

## **5. `ref` 绑定到 `computed` 计算属性**

### **示例：计算 `ref` 的新值**

```vue
<template>
  <p>原始价格: {{ price }}</p>
  <p>折扣价: {{ discountPrice }}</p>
  <button @click="increasePrice">涨价</button>
</template>

<script>
import { ref, computed } from 'vue';

export default {
  setup() {
    const price = ref(100);
    const discountPrice = computed(() => price.value * 0.9);

    const increasePrice = () => {
      price.value += 10;
    };

    return { price, discountPrice, increasePrice };
  }
};
</script>
```

### **📌 解析**

- `computed()` 创建基于 `ref` 计算的值 (`discountPrice`)。
- `price.value += 10` 后，**`discountPrice` 也会自动更新**。

---

## **6. `ref` 绑定到 DOM**

可以通过 `ref` 获取 DOM 元素。

### **示例：获取按钮元素**

```vue
<template>
  <button ref="myButton" @click="focusButton">点击聚焦</button>
</template>

<script>
import { ref, onMounted } from 'vue';

export default {
  setup() {
    const myButton = ref(null);

    const focusButton = () => {
      myButton.value.focus(); // 访问 DOM 方法
    };

    return { myButton, focusButton };
  }
};
</script>
```

### **📌 解析**

- `myButton.value` 获取到的是 `button` DOM 元素。
- `focusButton()` 直接调用 `focus()` 方法。

---

## **7. `setup()` 返回 `ref` 数据的方式**

在 `setup()` 中，可以用两种方式返回 `ref` 变量：

1. **直接返回 `ref`**（模板会自动解包 `.value`）。
2. **返回 `ref.value`**（在 `setup()` 内手动解包）。

### **方式 1：直接返回 `ref`**

```vue
<template>
  <p>{{ count }}</p>  <!-- Vue 自动解包 .value -->
</template>

<script>
import { ref } from 'vue';

export default {
  setup() {
    const count = ref(0);
    return { count };  // 直接返回 ref
  }
};
</script>
```

**✔️ `count` 会自动解包 `count.value`**

---

### **方式 2：返回 `ref.value`**

```vue
<template>
  <p>{{ count }}</p> <!-- 这里的 count 不是 ref -->
</template>

<script>
import { ref } from 'vue';

export default {
  setup() {
    const count = ref(0);
    return { count: count.value }; // 这里返回的是普通变量
  }
};
</script>
```

**🚨 这样 `count` 就不会是响应式的！**

---

## **8. 总结**

|功能|代码示例|
|---|---|
|**基本类型**|`const count = ref(0);`|
|**对象**|`const user = ref({ name: '张三' });`|
|**数组**|`const list = ref(['苹果', '香蕉']);`|
|**监听 `ref`**|`watch(count, (newVal) => {});`|
|**计算属性**|`const discount = computed(() => price.value * 0.9);`|
|**绑定 DOM**|`const el = ref(null);`|

`ref` 是 Vue 3 组合式 API 中最常用的响应式数据管理方式，结合 `computed`、`watch` 等功能，可以实现强大的响应式逻辑。