### Composition API 是什么？

**核心概念**

Composition API（组合式 API）是 Vue 3 引入的一套函数式 API，旨在解决 Vue 2 中 Options API（选项式 API）在大型项目中遇到的两个主要痛点：

1.  **逻辑分散**：在 Options API 中，一个功能（比如，用户数据获取）的逻辑被迫分散在 `data`、`methods`、`computed`、`watch` 等不同选项中，难以阅读和维护。
2.  **逻辑复用困难**：传统的 Mixins 复用方式存在命名冲突、数据来源不清晰等问题。

Composition API 的核心思想是 **“按逻辑功能组织代码”**。你可以将同一个功能相关的所有代码（响应式状态、方法、计算属性等）都放在一起，然后将这些逻辑块轻松地抽离、复用。

使用 Composition API 的最佳实践是在 `*.vue` 文件的 `<script setup>` 块中，这是目前最简洁、最高效的写法。

---
### 优雅地组织代码

掌握了 API 后，如何将它们组织得像一件艺术品？

1.  **逻辑相关性分组**：在 `<script setup>` 内部，使用注释或空行将相关的代码块放在一起。例如：
    ```ts
    <script setup lang="ts">
    import { ref, computed } from 'vue';

    // --- Props & Emits ---
    const props = defineProps</* ... */>();

    // --- State ---
    const form = reactive({ /* ... */ });
    const isLoading = ref(false);

    // --- Computed ---
    const isFormValid = computed(() => /* ... */);

    // --- Logic & Methods ---
    async function submit() { /* ... */ }

    // --- Watchers & Lifecycle ---
    watch(form, () => { /* ... */ });
    onMounted(() => { /* ... */ });
    </script>
    ```

2.  **积极抽离为 Composables**：一旦发现某个“逻辑组”变得复杂（超过 20-30 行），或者这个逻辑可能在其他组件中被复用，立即将它抽离成一个 `useXXX.ts` 文件。
    *   **组件的职责**：组件的 `<script setup>` 应该像一个“指挥官”，它调用各种 Composables (`useForm`, `useDataFetching`)，并将它们返回的状态和方法连接到模板上。组件本身应该保持简洁，只关心“做什么”，而将“怎么做”的细节交给 Composables。

3.  **清晰的文件结构**：
    *   `src/composables/` (或 `src/hooks/`)：存放所有可复用的 `use` 函数。
    *   `src/types/`：存放共享的 TypeScript 接口和类型定义。
    *   `src/services/` 或 `src/api/`：存放与后端 API 交互的函数。Composables (如 `useFetch`) 内部可以调用这些服务。

当然。这是一个极好的问题，也是 Composition API 的核心优势所在。

**Composition API 的精髓在于，它允许我们根据“逻辑功能”来组织代码，而不是像过去 Options API 那样被“选项类型”（data, methods, computed）所分割。**

实现这一点的核心武器就是 **Composable 函数**（组合式函数）。

---

### Composable 是什么？

**一个 Composable 就是一个函数**，它利用 Vue 的 Composition API（如 `ref`, `computed`, `watch`, `onMounted` 等）来**封装和复用有状态的逻辑**。

**关键特征：**
*   **它是一个普通函数**：通常以 `use` 开头，例如 `useCounter`, `useFetch`。这是一种社区约定，能清晰地表明其用途。
*   **它可以有状态**：内部可以使用 `ref` 或 `reactive` 创建响应式数据。
*   **它可以有副作用**：可以包含生命周期钩子（`onMounted`, `onUnmounted` 等）来处理例如事件监听、数据请求等副作用。
*   **它返回一个普通对象**：通常返回一个包含响应式状态和方法的对象，供组件解构使用。

通过 Composable，我们可以将一个复杂组件中“与用户头像上传相关的所有逻辑”（状态、方法、校验）都抽离到一个 `useAvatarUpload.ts` 文件中，而不是分散在 `data`, `methods`, `computed` 等各个角落。

---

### 创建和使用一个 Composable

我们以一个非常常见的场景为例：**封装一个异步数据请求的逻辑 `useFetch`**。这个 Composable 将处理加载状态、错误状态和最终数据。

#### 第 1 步：创建 Composable 文件

在你的项目中创建一个 `composables` 目录（约定俗成），然后新建 `useFetch.ts` 文件。

```typescript
// src/composables/useFetch.ts

import { ref, watch, toValue } from 'vue'
import type { Ref } from 'vue'

// 使用泛型 <T> 使其可以用于任何数据类型
// url 参数可以是 ref，也可以是普通字符串，toValue 会智能处理
export function useFetch<T>(url: Ref<string> | string) {

  // 1. 封装的状态 (State)
  const data = ref<T | null>(null)
  const error = ref<Error | null>(null)
  const isLoading = ref(true)

  // 2. 封装的逻辑 (Logic / Action)
  const fetchData = async () => {
    // 重置状态
    isLoading.value = true
    error.value = null

    try {
      // toValue() 是 Vue 3.3+ 的新 API，可以智能地获取 ref 的 .value 或返回普通值本身
      const response = await fetch(toValue(url))
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      data.value = await response.json()
    } catch (e: any) {
      error.value = e
    } finally {
      isLoading.value = false
    }
  }

  // 3. 封装的副作用 (Side Effect)
  // 使用 watch 监听 url 变化，自动重新请求数据
  // { immediate: true } 确保了组件一挂载就会立即执行一次 fetchData
  watch(
    () => toValue(url),
    fetchData,
    { immediate: true }
  )

  // 4. 返回需要暴露给组件的接口
  return { data, error, isLoading, refetch: fetchData }
}
```

#### 第 2 步：在组件中使用 Composable

现在，任何需要请求数据的组件都可以优雅地使用这个 `useFetch` Composable。

```vue
<!-- src/components/UserProfile.vue -->
<template>
  <div class="user-profile">
    <div v-if="isLoading">正在加载用户数据...</div>
    <div v-else-if="error" class="error">加载失败: {{ error.message }}</div>
    <div v-else-if="user">
      <h1>{{ user.name }}</h1>
      <p>邮箱: {{ user.email }}</p>
      <button @click="refetch">刷新数据</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useFetch } from '@/composables/useFetch'

// 定义期望的数据类型
interface User {
  id: number;
  name: string;
  email: string;
}

// 一行代码，就拥有了数据请求的全部能力！
// 使用解构和重命名，让模板代码更具可读性
const { data: user, error, isLoading, refetch } = useFetch<User>('https://api.example.com/users/1')

// 你看，<script> 部分是如此的干净和声明式。
// 所有的复杂逻辑都被封装在了 useFetch 内部。
</script>
```

**看到了吗？这就是优雅！** 组件只关心“我需要用户数据”，而不用关心“如何请求、如何处理加载和错误状态、如何在 URL 变化时重新请求”。

---

### 扩展与应用

这种模式的应用场景极其广泛，几乎所有可复用的逻辑都可以被封装：

*   **`useForm(initialState)`**：封装表单状态、校验逻辑和提交方法。
*   **`useLocalStorage(key, defaultValue)`**：封装与 `localStorage` 的双向同步逻辑。
*   **`useEventListener(target, event, callback)`**：封装事件监听，并在组件卸载时自动移除监听器。
*   **`useMouse()`**：封装获取鼠标位置的响应式坐标。
*   **`useDebounce(value, delay)`**：封装一个防抖的 ref。

**强大的社区库**：[VueUse](https://vueuse.org/) 已经为我们提供了海量高质量、开箱即用的 Composable 函数，强烈推荐在项目中使用。学习它的源码也是理解 Composable 最佳实践的绝佳方式。

---

### 要点与注意事项

1.  **命名约定**：始终使用 `use` 作为 Composable 函数的前缀。这不仅是约定，也能让 Vue 的开发工具更好地理解你的代码。

2.  **TypeScript 的威力**：务必使用 TypeScript 和泛型 (`<T>`)。这让你的 Composable 变得类型安全、可预测，并且拥有完美的自动补全体验。

3.  **返回 Ref，而非值**：务必返回 `ref` 或 `reactive` 对象本身，而不是它们的 `.value`。组件需要的是响应式引用，以便在值变化时更新视图。
    *   **错误**：`return { data: data.value }`
    *   **正确**：`return { data }`

4.  **输入参数的响应式**：如果 Composable 的行为依赖于一个可能变化的输入（比如 props），应该接收一个 `Ref` 作为参数（如 `useFetch` 中的 `url`），并在内部使用 `watch` 或 `computed` 来响应其变化。`toValue` (Vue 3.3+) 是处理这种“可能为 Ref”的参数的现代最佳实践。

5.  **生命周期管理**：如果你的 Composable 创建了需要手动清理的副作用（如 `setInterval` 或全局事件监听），**必须**在 `onUnmounted` 钩子中进行清理，以防止内存泄漏。

    ```ts
    // 示例：useInterval.ts
    import { onUnmounted } from 'vue'

    export function useInterval(callback: () => void, delay: number) {
      const timer = setInterval(callback, delay)
      
      // 组件销毁时，清除定时器
      onUnmounted(() => {
        clearInterval(timer)
      })
    }
    ```

通过遵循以上原则，就能利用 Composition API 编写出高内聚、低耦合、易于测试和无限复用的优雅代码。这正是 Vue 3 如此强大的原因之一。