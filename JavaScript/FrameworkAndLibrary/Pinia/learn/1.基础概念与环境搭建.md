为什么我们需要 Pinia，并创建并运行第一个 Store，建立最直观的感受。

---

### **理解状态管理的核心思想**

#### **【概念讲解】**

想象一下你在盖一栋大楼（你的 Vue 应用）。

*   **组件（Component）**：就是这栋大楼里的一个个房间，比如客厅、卧室、厨房。
*   **状态（State）**：就是这栋大楼里所有人都需要知道的公共信息，比如“今天的 WIFI 密码”、“中央空调的温度”、“大楼的入口密码”。

现在问题来了，如果“WIFI 密码”变了，你怎么通知所有房间里的人？

*   **没有状态管理 (Prop Drilling - 逐层传递)**：你（父组件）需要跑到客厅（子组件 A），告诉他们新密码；然后客厅的人再跑到卧室（子组件 B），告诉他们新密码；卧室的人再跑到阳台（子组件 C）... 这个过程非常繁琐，难以维护，我们称之为“**Prop 逐层传递**”。如果厨房和客厅不是父子关系，而是邻居（兄弟组件），通信就更麻烦了。

*   **有了状态管理 (Pinia)**：你在大楼的大厅里放了一块“**中央信息公告板**”（这就是 Pinia Store）。
    *   **集中管理**：所有公共信息（WIFI 密码、空调温度）都写在这块板上。
    *   **响应式**：任何人都可以去修改板上的信息（比如管理员更新了 WIFI 密码）。一旦信息被修改，所有关注这块板的人（各个组件）都会**立即**看到最新的信息。
    *   **轻松访问**：任何房间的人，无论远近，都可以直接去大厅看公告板，而不需要一层层传话。

**总结：Pinia 就是你应用的“中央信息公告板”，专门用来管理那些需要在多个组件之间共享、响应式变化的数据。**

---

### **Pinia 为何是首选 (vs Vuex)**

#### **【概念讲解】**

Vuex 是 Vue 之前的官方状态管理库，它非常优秀，但有点像一个流程严格的大公司。而 Pinia 则是 Vue 3 时代一个更现代、更敏捷的团队。

**Pinia 的核心优势：**

1.  **完美的 TypeScript 支持**：Pinia 的 API 设计与 TypeScript 完美契合。你几乎不需要做任何额外的类型配置，就能获得极其强大的类型推断和自动补全。这是它最显著的优势。
2.  **极致简洁的 API**：
    *   **没有 `mutations`**：在 Vuex 中，你必须通过 `mutations` 来同步修改 state，通过 `actions` 来处理异步。Pinia 废除了 `mutations`，你可以直接在 `actions` 中修改 state，代码更直观，心智负担更小。
    *   **没有模块嵌套**：Vuex 的模块（`modules`）有复杂的命名空间概念。Pinia 的每个 Store 本身就是一个独立的模块，你可以像导入一个普通函数一样导入并使用它，非常符合现代前端的模块化思想。
3.  **更小巧的体积**：Pinia 非常轻量，压缩后体积仅有约 1 KB，对你的应用性能更有利。
4.  **更符合组合式 API (Composition API) 的心智模型**：我们稍后会看到，定义一个 Pinia Store 就像在写一个 Vue 3 的 `setup` 函数，一切都显得那么自然。

**一句话总结：对于所有新的 Vue 3 项目，Pinia 是毫无疑问的、官方推荐的首选方案。**

---

### **动手搭建与你的第一个 Store**

现在，理论足够了，让我们卷起袖子开始编码！我们将创建一个最简单的计数器应用。

#### **【代码示例】**

假设你已经通过 `npm create vite@latest` 创建了一个 Vue + TypeScript 的项目。

**Step 1: 安装 Pinia**

在你的项目根目录下打开终端，运行：

```bash
npm install pinia
```

**Step 2: 创建并注册 Pinia 实例**

这是告诉你的 Vue 应用：“嘿，我们要开始使用 Pinia 了！”

打开 `src/main.ts` 文件，修改如下：

```typescript
// src/main.ts

import { createApp } from 'vue'
import { createPinia } from 'pinia' // 1. 引入 createPinia
import App from './App.vue'
import './style.css'

const app = createApp(App)
const pinia = createPinia() // 2. 创建 Pinia 实例

app.use(pinia) // 3. 将 Pinia 实例挂载到应用上
app.mount('#app')
```

**Step 3: 编写你的第一个 Store**

这是最核心的一步。我们推荐在 `src` 目录下创建一个 `stores` 文件夹来统一管理所有的 Store。

1.  在 `src` 目录下新建 `stores` 文件夹。
2.  在 `stores` 文件夹下新建 `counter.store.ts` 文件。

```typescript
// src/stores/counter.store.ts

import { ref, computed } from 'vue'
import { defineStore } from 'pinia'

// 1. 定义 Store
// `defineStore` 的第一个参数是 Store 的唯一 ID，Pinia 会用它来连接 Store 和开发者工具。
// 第二个参数是一个 setup 函数，我们在这里面定义 state, getters, actions。
export const useCounterStore = defineStore('counter', () => {
  // --- State (状态) ---
  // 就像组件里的 data，使用 ref() 或 reactive() 创建响应式数据。
  const count = ref(0)

  // --- Getters (计算属性) ---
  // 就像组件里的 computed，用于派生状态。
  const doubleCount = computed(() => count.value * 2)

  // --- Actions (方法) ---
  // 就像组件里的 methods，用于封装业务逻辑，修改 state。
  function increment() {
    count.value++
  }

  // 必须 return 出去，这样组件中才能访问。
  return { count, doubleCount, increment }
})
```

**Step 4: 在组件中使用 Store**

现在，我们可以在任何组件中轻松使用这个 `counterStore`。

修改 `src/App.vue` 文件：

```vue
<script setup lang="ts">
// 1. 导入你创建的 Store
import { useCounterStore } from './stores/counter.store'

// 2. 获取 Store 实例
// 这就像一个 hook，调用它会返回 Store 的单例。
const counterStore = useCounterStore()

// 现在你可以像访问一个普通对象一样，访问 store 里的所有内容。
// counterStore.count
// counterStore.doubleCount
// counterStore.increment()
</script>

<template>
  <div>
    <h1>Pinia 计数器</h1>
    <!-- 直接在模板中使用 state 和 getters -->
    <p>当前计数值: {{ counterStore.count }}</p>
    <p>双倍计数值: {{ counterStore.doubleCount }}</p>

    <!-- 调用 action 来修改 state -->
    <button @click="counterStore.increment">点我 +1</button>
  </div>
</template>

<style scoped>
button {
  margin-top: 1rem;
}
</style>
```

现在运行你的项目 (`npm run dev`)，你就能看到一个可以工作的计数器了！你已经成功迈出了第一步！

#### **【扩展与应用】**

这个简单的计数器模式可以扩展到任何真实场景：

*   `count` 可以换成 `user: ref<User | null>(null)` 来存储用户信息。
*   `doubleCount` 可以换成 `isLoggedIn: computed(() => !!user.value)` 来判断登录状态。
*   `increment` 可以换成 `async function login(payload) { ... }` 来处理登录逻辑。

#### **【要点 / 注意事项】**

1.  **Store ID 必须唯一**：`defineStore` 的第一个参数（我们例子中的 `'counter'`）在整个应用中必须是独一无二的。这是 Pinia 内部识别不同 Store 的关键。
2.  **`use...Store` 命名约定**：将你的 Store 命名为 `use...Store` (例如 `useUserStore`, `useCartStore`) 是一种社区推荐的最佳实践，因为它看起来和用起来都像 Vue 的组合式函数（Composables）。
3.  **Setup Store vs Options Store**：Pinia 支持两种定义 Store 的语法。我们刚刚使用的是官方首推的 **Setup Store**，它更符合 Vue 3 的心智模型且类型推断最完美。另一种是 **Options Store**，语法类似 Vue 2 的选项式 API，我们暂时不必关心，专注掌握 Setup Store 即可。