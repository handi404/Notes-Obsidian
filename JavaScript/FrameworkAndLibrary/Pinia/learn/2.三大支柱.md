逐一剖析构成 Pinia Store 的 `State`、`Getters` 和 `Actions`。掌握它们，你就掌握了 Pinia 80% 的核心功能。

---

### **State (状态) - 数据的基石**

**目标**：熟练定义、读取和修改 State，特别是掌握多种修改方式的适用场景。

#### **【概念讲解】**

State 是 Store 的灵魂，它就是你需要跨组件共享的、响应式的原始数据。在 `setup` store 中，它通常由 `ref()` 或 `reactive()` 创建。

*   `ref()`: 用于定义基本类型 (如 `string`, `number`, `boolean`) 或需要整个替换的对象/数组。
*   `reactive()`: 用于定义一个复杂对象，当你希望对象内部的属性也是响应式的，并且你会频繁地修改对象内部的多个属性时。

#### **【代码示例】**

让我们来创建一个更丰富的用户信息 Store。

**Step 1: 定义一个包含多种类型 State 的 Store**

```typescript
// src/stores/user.store.ts

import { ref, reactive } from 'vue'
import { defineStore } from 'pinia'

// 定义一个用户信息的接口，增强类型安全
export interface UserInfo {
  name: string
  age: number
  isAdmin: boolean
}

export const useUserStore = defineStore('user', () => {
  // 使用 ref 定义一个可能为 null 的对象
  const user = ref<UserInfo | null>(null)

  // 使用 reactive 定义一个设置对象
  const settings = reactive({
    theme: 'dark',
    notifications: {
      email: true,
      sms: false
    }
  })

  // 必须 return
  return { user, settings }
})
```

**Step 2: 在组件中读取和修改 State**

修改 `src/App.vue` 来使用这个新的 `userStore`。

```vue
<script setup lang="ts">
import { useUserStore, type UserInfo } from './stores/user.store'

const userStore = useUserStore()

// --- 修改 State 的几种方式 ---

// 1. 直接修改 (最简单直接，适用于简单的单个修改)
function login() {
  userStore.user = { name: 'Alice', age: 30, isAdmin: false }
}

function logout() {
  userStore.user = null
}

function toggleEmailNotifications() {
  // 对于 reactive 对象，可以直接修改其属性
  userStore.settings.notifications.email = !userStore.settings.notifications.email
}

// 2. 使用 $patch 方法 (推荐用于多个状态的批量同步修改)
function updateUserProfile() {
  // $patch 可以接收一个对象
  userStore.$patch({
    user: {
      // 注意：这里会合并 user 对象，而不是替换它
      // 如果 user 是 ref<UserInfo | null>，这里的 patch 行为是对 ref.value 的 patch
      name: 'Bob', 
      age: 35
      // isAdmin 不会被修改
    },
    settings: {
      theme: 'light'
    }
  })
}

// 3. 使用 $patch + 函数 (当修改依赖于当前状态时，功能更强大)
function celebrateBirthday() {
  userStore.$patch((state) => {
    if (state.user) {
      state.user.age++
      // 可以在一个函数里做更复杂的逻辑
      if (state.user.age >= 60) {
        state.user.isAdmin = true // 假设年满60自动成为管理员
      }
    }
  })
}
</script>

<template>
  <div>
    <h2>用户信息</h2>
    <div v-if="userStore.user">
      <p>姓名: {{ userStore.user.name }}</p>
      <p>年龄: {{ userStore.user.age }}</p>
      <p>是管理员吗: {{ userStore.user.isAdmin }}</p>
    </div>
    <p v-else>用户未登录</p>
    
    <h2>设置</h2>
    <p>主题: {{ userStore.settings.theme }}</p>
    <p>邮件通知: {{ userStore.settings.notifications.email }}</p>

    <hr>
    
    <button @click="login">登录</button>
    <button @click="logout">登出</button>
    <button @click="toggleEmailNotifications">切换邮件通知</button>
    <button @click="updateUserProfile">更新个人资料 (Patch Object)</button>
    <button @click="celebrateBirthday">过生日 (Patch Function)</button>
  </div>
</template>
```

#### **【扩展与应用】**

*   **`$state`**：你可以通过 `store.$state` 直接访问或替换整个 Store 的 state，这在某些场景下（如服务端渲染后的状态同步）非常有用。例如：`userStore.$state = { user: newUserInfo, settings: newSettings }`。这会完全替换掉 Store 的所有 State，请谨慎使用。
*   **`$reset()`**：如果你想将 Store 重置回其初始状态（即 `defineStore` 时定义的状态），可以调用 `store.$reset()` 方法。这需要使用 **Options Store** 语法定义 `state` 函数才能工作，在 Setup Store 中需要自己实现一个 `reset` action。

**自己实现 reset Action (Setup Store 推荐方式):**
```typescript
// in user.store.ts
export const useUserStore = defineStore('user', () => {
  const user = ref<UserInfo | null>(null)
  // ... 其他 state

  function reset() {
    user.value = null
    // ...重置其他 state
  }

  return { user, reset }
})
```

#### **【要点 / 注意事项】**

1.  **直接修改 vs `$patch`**：
    *   **直接修改** (`store.prop = ...`) 简单直观，但如果你在短时间内进行多次修改，可能会触发多次组件更新，虽然 Vue 会进行优化，但语义上不是最优。
    *   **`$patch`** 在性能上更优，因为它将多次修改合并为一次更新通知。这对于性能敏感的大型应用或频繁更新的场景尤其重要。**当你要同时修改多个 state 属性时，强烈推荐使用 `$patch`**。

2.  **`$patch` 对象的合并行为**：当使用 `$patch` 传递一个对象时，它会进行**浅合并 (shallow patch)**。在上面的 `updateUserProfile` 例子中，`user` 对象里的 `isAdmin` 属性没有被修改，因为它不在 patch 对象中。`settings.notifications` 也同理。

3.  **类型安全**：始终为你的 State（尤其是复杂对象）定义 TypeScript 接口 (`interface`) 或类型 (`type`)，这会让你的代码更健壮，并享受完美的自动补全。

---

我们已经深入了解了 `State`。它就像是应用程序的数据仓库。但是，我们常常需要基于这些原始数据进行计算，得到一些派生数据。这就是 `Getters` 的用武之地了。

接下来，我们将探索 **`Getters` (计算属性)**，了解如何创建派生状态，以及如何在一个 Getter 中访问其他 Getter。

---

### **Getters (计算属性) - 数据的衍生与加工**

**目标**：理解 Getters 的作用，熟练定义和使用它们，并掌握 Getter 之间的相互调用。

#### **【概念讲解】**

如果你熟悉 Vue 的 `computed` 属性，那么恭喜你，你已经理解了 Pinia Getters 的 90%。**Getters 本质上就是 Store 的计算属性**。

它们的作用是：

1.  **派生状态**：基于已有的 State 计算出新的值。例如，从一个用户列表中筛选出已激活的用户。
2.  **缓存结果**：和 `computed` 一样，Getter 的结果会被缓存。只要它依赖的 State 没有发生变化，多次访问 Getter 都会立即返回之前计算好的结果，而不会重新计算，这能提升性能。
3.  **简化模板**：将复杂的逻辑从组件模板中抽离到 Store 中，让模板更干净、更具可读性。

#### **【代码示例】**

让我们回到之前的 `user.store.ts`，并为其添加一些 Getters。

**Step 1: 在 Store 中定义 Getters**

```typescript
// src/stores/user.store.ts

// (我们继续使用上一节的 UserInfo 接口和 state)
import { ref, reactive, computed } from 'vue' // 引入 computed
import { defineStore } from 'pinia'

export interface UserInfo {
  name: string
  age: number
  isAdmin: boolean
}

export const useUserStore = defineStore('user', () => {
  // --- State ---
  const user = ref<UserInfo | null>({ name: 'Alice', age: 30, isAdmin: false })
  const settings = reactive({ theme: 'dark' })

  // --- Getters ---
  
  // Getter 1: 一个简单的布尔值 Getter
  const isLoggedIn = computed(() => user.value !== null)

  // Getter 2: 一个依赖 State 中复杂对象的 Getter
  // 返回一个格式化后的欢迎信息
  const welcomeMessage = computed(() => {
    if (user.value) {
      return `欢迎, ${user.value.name}!`
    }
    return '欢迎, 游客!'
  })

  // Getter 3: 在一个 Getter 中访问其他 Getter (这是高级用法)
  // 注意：要访问其他 getter，直接使用 .value 即可
  const fullUserDetails = computed(() => {
    if (isLoggedIn.value && user.value) { // 使用了 isLoggedIn getter
      return `${user.value.name} (年龄: ${user.value.age}, 主题: ${settings.theme})`
    }
    return '无用户详情'
  })


  // --- Actions --- (先定义一个简单的 Action 用于演示)
  function updateUser(newUser: UserInfo) {
    user.value = newUser
  }
  
  function logout() {
    user.value = null
  }

  // 必须 return 出去才能在组件中使用
  return {
    user,
    settings,
    isLoggedIn,         // <-- 导出 Getter
    welcomeMessage,     // <-- 导出 Getter
    fullUserDetails,    // <-- 导出 Getter
    updateUser,
    logout
  }
})
```

**Step 2: 在组件中使用 Getters**

现在，在组件中使用这些 Getters 就像访问普通属性一样简单。

修改 `src/App.vue`:

```vue
<script setup lang="ts">
import { useUserStore, type UserInfo } from './stores/user.store'
import { storeToRefs } from 'pinia' // 稍后会详细讲解这个重要的工具

const userStore = useUserStore()

// 像访问 state 一样直接访问 getters
// userStore.isLoggedIn
// userStore.welcomeMessage
// userStore.fullUserDetails
</script>

<template>
  <div>
    <h1>Getters 演示</h1>
    
    <!-- 使用 Getter 来控制 UI 显示 -->
    <div v-if="userStore.isLoggedIn">
      <p><strong>来自 Getter:</strong> {{ userStore.welcomeMessage }}</p>
      <p><strong>组合 Getter:</strong> {{ userStore.fullUserDetails }}</p>
    </div>
    <p v-else><strong>来自 Getter:</strong> 请先登录。</p>

    <hr>
    <button @click="userStore.updateUser({ name: 'Charlie', age: 40, isAdmin: true })">
      切换用户
    </button>
    <button @click="userStore.logout">登出</button>
  </div>
</template>
```

当你点击按钮切换用户或登出时，你会看到所有依赖 `user` state 的 Getters 都会自动更新，这就是响应式的魔力。

#### **【扩展与应用】**

*   **带参数的 Getters**：有时你可能希望 Getter 能接收参数。在 Pinia 中，这可以通过 **让 Getter 返回一个函数** 来实现。

**示例：按 ID 查找用户的 Getter**

```typescript
// 在一个管理用户列表的 store 中
const users = ref([
  { id: 1, name: 'Alice', active: true },
  { id: 2, name: 'Bob', active: false },
  { id: 3, name: 'Charlie', active: true },
])

// 这个 getter 返回了一个函数，该函数接收 id 作为参数
const getUserById = computed(() => {
  return (userId: number) => users.value.find(user => user.id === userId)
})

// 在组件中使用
// const userStore = useUserStore()
// const userTwo = userStore.getUserById(2) // { id: 2, name: 'Bob', active: false }
```

**注意**：带参数的 Getter **不会被缓存**！因为它们每次调用都可能传入不同参数，无法像普通 `computed` 那样缓存结果。每次调用都会重新执行。

#### **【要点 / 注意事项】**

1.  **Getter 是只读的**：你不能直接修改一个 Getter 的值 (`userStore.isLoggedIn = false` 会报错)。它完全由其依赖的 State 决定。想要改变 Getter 的值，必须去修改它所依赖的 State。
2.  **Getter vs. Actions**：
    *   **Getters** 用于 **同步** 派生数据，且具有缓存。它们是**计算**。
    *   **Actions** 用于处理用户交互、异步操作、和 **修改** State。它们是**行为**。
    .
    如果只是基于现有 state 计算一个新值，用 Getter；如果需要处理逻辑（比如 API 请求）或改变 state，用 Action。

3.  **Getter 中访问其他 Store**：和我们稍后会讲到的在 Action 中访问其他 Store 一样，你可以在一个 Getter 中导入并使用另一个 Store。

```typescript
// 在 cart.store.ts 的 getter 中
import { useUserStore } from './user.store'

// ...
const cartSummary = computed(() => {
  const userStore = useUserStore() // 在 getter 内部获取实例
  return `${userStore.user?.name} 的购物车有 ${items.value.length} 件商品。`
})
```

---

我们已经成功掌握了 `State` 和 `Getters`。State 是原始数据，Getters 是派生数据。现在，我们还缺少改变这些数据的“手臂”——那就是 `Actions`。

接下来，我们将进入最重要、也是实战中最核心的部分：**Actions (动作)**。了解如何定义同步和异步 Actions，以及如何优雅地处理加载和错误状态。

---

### **Actions (动作) - 逻辑的执行者与状态的改变者**

**目标**：掌握定义和使用 Actions，特别是能够熟练处理异步操作（如 API 请求），并管理伴随的加载（loading）和错误（error）状态。

#### **【概念讲解】**

**Actions 就是 Store 里的“方法”**。它们是封装业务逻辑的地方。与 Getters 不同，Actions 可以是**同步的**，也可以是**异步的**。

**Actions 的核心职责：**

1.  **封装业务逻辑**：比如“用户登录”、“添加到购物车”、“从服务器获取文章列表”等。这些逻辑可能很复杂，将它们放在 Action 中能让组件代码保持干净。
2.  **修改 State**：Actions 是修改 State 的主要场所。虽然我们之前可以直接修改 State，但在复杂的应用中，将修改逻辑统一放在 Actions 中是一种最佳实践，使得状态变更的来源更清晰、可追溯。
3.  **处理异步操作**：这是 Actions 最重要的用途。任何与后端 API 的交互、定时器等异步任务都应该在 Actions 中完成。

#### **【代码示例】**

我们将创建一个 `posts.store.ts`，模拟从一个假 API 获取文章列表。这个例子将涵盖同步和异步 Action，以及 loading 和 error 状态管理。

**Step 1: 创建 Posts Store 并定义 Actions**

```typescript
// src/stores/posts.store.ts

import { ref } from 'vue'
import { defineStore } from 'pinia'

// 定义文章的数据结构
export interface Post {
  userId: number
  id: number
  title: string
  body: string
}

// 模拟一个会延迟并可能失败的 API 请求
const fakeApi = {
  fetchPosts: async (): Promise<Post[]> => {
    console.log('正在请求文章列表...')
    await new Promise(resolve => setTimeout(resolve, 1500)) // 模拟网络延迟
    
    // 模拟 20% 的概率请求失败
    if (Math.random() < 0.2) {
      throw new Error('服务器开小差了，请稍后再试！')
    }
    
    // 模拟成功返回的数据
    const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5')
    return response.json()
  }
}

export const usePostsStore = defineStore('posts', () => {
  // --- State ---
  const posts = ref<Post[]>([])
  const isLoading = ref(false)
  const error = ref<string | null>(null)

  // --- Action 1: 同步 Action ---
  // 用于在列表头部添加一篇新文章
  function addPost(post: Post) {
    //可以直接修改 state
    posts.value.unshift(post)
  }

  // --- Action 2: 核心！异步 Action ---
  // 用于从服务器获取文章列表
  async function fetchPosts() {
    // 1. 开始加载，清空旧错误
    isLoading.value = true
    error.value = null
    
    try {
      // 2. 执行异步操作 (API 请求)
      const data = await fakeApi.fetchPosts()
      
      // 3. 异步操作成功，更新 state
      posts.value = data
    } catch (e: any) {
      // 4. 异步操作失败，记录错误信息
      error.value = e.message
    } finally {
      // 5. 无论成功与否，结束加载状态
      isLoading.value = false
    }
  }

  return {
    posts,
    isLoading,
    error,
    addPost,
    fetchPosts
  }
})
```

**Step 2: 在组件中使用 Actions 和相关状态**

现在，我们可以在组件中调用这些 Actions，并根据 `isLoading` 和 `error` 状态来渲染不同的 UI。

修改 `src/App.vue`:

```vue
<script setup lang="ts">
import { usePostsStore } from './stores/posts.store'

const postsStore = usePostsStore()

// 组件挂载时，自动调用 action 获取数据
import { onMounted } from 'vue'
onMounted(() => {
  postsStore.fetchPosts()
})

function handleAddNewPost() {
  postsStore.addPost({
    id: Date.now(),
    userId: 1,
    title: '一篇新文章',
    body: '这是通过同步 Action 添加的内容。'
  })
}
</script>

<template>
  <div>
    <h1>Actions 演示：文章列表</h1>
    
    <button @click="postsStore.fetchPosts" :disabled="postsStore.isLoading">
      {{ postsStore.isLoading ? '正在加载...' : '重新加载文章' }}
    </button>
    <button @click="handleAddNewPost" style="margin-left: 10px;">
      添加一篇新文章
    </button>

    <!-- 错误状态展示 -->
    <div v-if="postsStore.error" class="error">
      <p>出错了: {{ postsStore.error }}</p>
    </div>

    <!-- 加载状态展示 -->
    <div v-else-if="postsStore.isLoading" class="loading">
      <p>数据加载中，请稍候...</p>
    </div>

    <!-- 成功获取数据并展示 -->
    <ul v-else-if="postsStore.posts.length > 0">
      <li v-for="post in postsStore.posts" :key="post.id">
        <h3>{{ post.title }}</h3>
        <p>{{ post.body }}</p>
      </li>
    </ul>

    <!-- 无数据状态 -->
    <p v-else>没有文章可展示。</p>
  </div>
</template>

<style scoped>
.error { color: red; border: 1px solid red; padding: 10px; margin-top: 10px; }
.loading { color: blue; margin-top: 10px; }
ul { list-style: none; padding: 0; }
li { border-bottom: 1px solid #ccc; padding-bottom: 10px; margin-bottom: 10px; }
h3 { margin-bottom: 5px; }
</style>
```

现在运行你的应用，你会看到：
1.  页面加载时，会显示“数据加载中...”。
2.  1.5 秒后，如果请求成功，文章列表会显示出来。
3.  如果你多次点击“重新加载文章”，有概率会看到红色的错误提示信息。
4.  点击“添加一篇新文章”会立即在列表顶部插入一条新数据。

这就是一个完整的、健壮的异步数据获取流程！

#### **【扩展与应用】**

*   **Action 的参数与返回值**：Actions 可以接收任意参数，并且可以有返回值。这在需要将异步操作的结果直接返回给调用方时非常有用。

```typescript
// 在 store 中
async function createUser(name: string): Promise<{ success: boolean; userId?: number }> {
  try {
    const response = await api.createUser(name)
    // 成功后修改 state
    this.users.push(response.data) // 'this' 在 action 中指向 store 实例
    return { success: true, userId: response.data.id }
  } catch (e) {
    return { success: false }
  }
}

// 在组件中
async function onRegister() {
  const result = await userStore.createUser('NewUser')
  if (result.success) {
    console.log(`用户创建成功，ID: ${result.userId}`)
  } else {
    console.log('用户创建失败')
  }
}
```

*   **`this` 的使用**：在 `defineStore` 的 setup 函数中，`this` 是 `undefined`。但在返回的 Actions 函数内部，Pinia 做了一些处理，使得 `this` 指向 Store 实例本身。这意味着你可以用 `this.count++` 来代替 `count.value++`，或用 `this.increment()` 调用另一个 action。**不过，为了保持与 Composition API 的一致性，我个人更推荐直接使用 ref/reactive 定义的变量本身（如 `count.value`），而不是 `this`。**

#### **【要点 / 注意事项】**

1.  **Action 的职责分离**：一个 Action 应该只做一件事情。例如，`fetchPosts` 只负责获取文章，而不应该包含创建文章的逻辑。保持 Action 的单一职责原则。
2.  **优雅的 Loading/Error 管理**：为每个可能需要独立加载状态的异步 Action 创建对应的 `isLoading` 标记。例如，`isFetchingList`, `isCreatingUser`。不要用一个全局的 `isLoading` 来管理所有异步操作，这会导致 UI 状态混乱。
3.  **Action 是业务逻辑的核心**：组件应该尽可能地“傻瓜化”。它只负责调用 Action 并根据 Store 的状态来渲染 UI。所有复杂的、可复用的逻辑都应该沉淀到 Actions 中。