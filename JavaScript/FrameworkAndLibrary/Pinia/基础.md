---
categories:
- [JavaScript,Framework and Library,Pinia]
title: Pinia 基础使用
date: 2025-05-24
index_img: img/vue/pinia.png
sticky: 40
tags:
- vue
- pinia
---
### 项目设置

设置一个新的 Vue 3 应用并安装 Pinia
`npm create vue`

### Installing Pinia & Making a Store
`npm install pinia`

现在要做的就是在 Vue 应用程序中将其**注册为中间件**，为此需要转到 main.js 文件，我们实际在其中创建应用程序并挂载它，即在 `use()` 中创建并调用。
```js
import { createPinia } from 'pinia'
import { createApp } from 'vue'
import App from './App.vue'
import './assets/main.css'

createApp(App).use(createPinia()).mount('#app')
```

已经在 main.js 文件中注册了 pinia，接下来我们要使用 pinia 来创建一个 store，该 store 将跟踪应用程序的任何全局状态。（例子中，状态将是任务列表，其中每个任务都是具有不同属性的对象）

- 创建一个 stores 文件夹，然后新建 TaskStore.js，这个文件就是 task store 现在要存放的地方。**对于所拥有的每一个单独的全局状态，你可以为每一个创建一个新的 store 并为其归档，因此对于身份验证或用户状态，可以创建一个 UserStore 文件，对于跟踪实时评论的状态，可以创建一个 CommentsStore 文件**。
- 调用 `defineStore()` 函数来创建 store，接受两个参数，第一个 store 的标识符，因此它有一个唯一的名称；第二个参数是一个对象，在这个对象里面，定义状态之类的东西。defineStore 返回值是函数，导出这个 store，就可以在其他文件中使用它来访问状态。
- 当我们在视图组件中使用自定义函数时，典型的**命名约定是 use + 使用的 Store**。
- 使用 `state` 属性在里面存储一些状态，是一个函数，这个函数基本上会返回一对象。因为要返回一个值，所以把对象放在括号里。这个对象是一个状态对象，它可以有不同的属性。
```js
import { defineStore } from "pinia";

export const useTaskStore = defineStore("taskStore", {
  state: () => ({
    tasks: [
      { id: 1, title: "buy some milk", isFav: false },
      { id: 2, title: "play Gloomhaven", isFav: true },
    ],
  }),
});
```

### 访问 Store 状态
从应用中的任何组件访问 store 状态。
首先需要导入创建的 store，然后调用。
```vue
<template>
 <div class="task-list">
   <div v-for="task in taskStore.tasks" :key="task.id">
     <TaskDetails :task="task" />
   </div>
 </div>
</template>
<script>
import { useTaskStore } from "./stores/taskStore";
export default {
  setup() {
    const taskStore = useTaskStore();
    return {
      taskStore,
    };
  },
};
</script>
```

### Getters
什么是 getters，以及为什么要使用它。

getters 是大多数状态管理解决方案中的一种特殊类型的函数，它的作用基本上就是获取某个东西，这个东西就是 state 或 state 的一部分。

不过可以直接从 vue 组件中的 store 中访问 state，那么为什么要创建 getter 函数来执行本质上是一样的操作？**getters 函数可以打包一些操作逻辑来改变返回给我们的值**。例如：可以有一个 getter 来获取所有 isFav 属性为 true 的任务；或者我可以有一个 getter，它能让我得到所有的任务，但返回的只是 title 数组，而不是对象。
```js
import { defineStore } from "pinia";

export const useTaskStore = defineStore("taskStore", {
  state: () => ({
    tasks: [
      { id: 1, title: "buy some milk", isFav: false },
      { id: 2, title: "play Gloomhaven", isFav: true },
    ],
  }),
  getters: {
    favs() {
      return this.tasks.filter((task) => task.isFav);
    },
    totalCount: (state) => {
      return state.tasks.length;
    },
  },
});
```

```vue
<template>
 <div>
   <div v-for="task in taskStore.favs" :key="task.id">
     <TaskDetails :task="task" />
   </div>
 </div>
</template>
```

### Actions
更新(增删改) store 中的 state。

在 Pinia 中，如果我们想要更新 store 中的 state，通常使用称为 `actions` 的特定函数，并且像 getters 一样，这些操作位于 store 中，并将任何操作逻辑打包在其中，然后当我们想要调用这些操作时，我们可以可以从任何 vue 组件轻松完成此操作。
```js
import { defineStore } from "pinia";

export const useTaskStore = defineStore("taskStore", {
  state: () => ({
    tasks: [
      { id: 1, title: "buy some milk", isFav: false },
      { id: 2, title: "play Gloomhaven", isFav: true },
    ],
  }),
  getters: {
  },
  actions: {
    addTask(task) {
      this.tasks.push(task);
    },
    deleteTask(id) {
      this.tasks = this.tasks.filter((task) => task.id !== id);
    },
    toggleFav(id) {
      const task = this.tasks.find((task) => {
        return task.id === id;
      });
      task.isFav = !task.isFav;
    },
  },
});
```

### 使用 Vue Devtools 的 Pinia
将 vue devtools 扩展添加到 Chrome 浏览器中。

### 异步操作（第一部分）
在 actions 中执行异步代码。
目前所有这些数据和状态实际上只在前端使用，如果我们对 state 进行更改然后刷新页面，这些更改不会保留，因为每次加载页面时，默认情况下都是起始 state，因此，当我们在此处创建操作时，它只是在应用程序本地更新此 state，但通常**当应用程序中有数据驱动时，会将数据存储在数据库或其他地方，当执行操作以及更新本地 state 时，你可能会向后端发出某种异步请求，以更新后端的数据，以便当我们刷新页面并首次获取数据时，数据是最新的，并且在我们进行这些更改时会保留下来。**
在这里用 json-server 充当数据库。`npm install -g json-server`
```js
import { defineStore } from "pinia";

export const useTaskStore = defineStore("taskStore", {
  state: () => ({
    tasks: [],
    loading: false,
  }),
  getters: {
  },
  actions: {
    async getTasks() {
      this.loading = true;
      const res = await fetch("http://localhost:3000/tasks");
      const data = await res.json();
      this.tasks = data;
      this.loading = false;
    },
  },
});
```
```vue
<template>
    <div class="task-list" v-if="filter === 'all'">
      <p>You have {{ taskStore.totalCount }} tasks left to do.</p>
      <div v-for="task in taskStore.tasks" :key="task.id">
        <TaskDetails :task="task" />
      </div>
    </div>
</template>
<script>
import { useTaskStore } from "./stores/taskStore";
import TaskDetails from "./components/TaskDetails.vue";
import { ref } from "vue";
export default {
  components: {
    TaskDetails,
  },
  setup() {
    const taskStore = useTaskStore();
    taskStore.getTasks();
    return {
      taskStore,
      filter,
    };
  },
};
</script>
```

### 异步操作（第二部分）
执行更新(增删改)异步。
对 state 和数据库的更新都要有，先 state 后数据库。（如果只更新 state 那么刷新后更新无法保留，如果只更新数据库那么需要刷新页面。）
```js
import { defineStore } from "pinia";

export const useTaskStore = defineStore("taskStore", {
  state: () => ({
    tasks: [],
    loading: false,
  }),
  getters: {
  },
  actions: {
    async getTasks() {
      this.loading = true;
      const res = await fetch("http://localhost:3000/tasks");
      const data = await res.json();
      this.tasks = data;
      this.loading = false;
    },
    async addTask(task) {
      this.tasks.push(task);
      const res = await fetch("http://localhost:3000/tasks", {
        method: "POST",
        body: JSON.stringify(task),
        headers: {
          "Content-type": "application/json",
        },
      });
      if (res.error) {
        console.log(res.error);
      }
    },
    async deleteTask(id) {
      this.tasks = this.tasks.filter((task) => task.id !== id);
      const res = await fetch("http://localhost:3000/tasks/" + id, {
        method: "DELETE",
      });
      if (res.error) {
        console.log(res.error);
      }
    },
    async toggleFav(id) {
      const task = this.tasks.find((task) => task.id === id);
      task.isFav = !task.isFav;
      const res = await fetch("http://localhost:3000/tasks/" + id, {
        method: "PATCH",
        body: JSON.stringify({ isFav: task.isFav }),
        headers: {
          "Content-type": "application/json",
        },
      });
      if (res.error) {
        console.log(res.error);
      }
    },
  },
});

```

### 重置 state & storeToRefs
将 state 恢复到其在 store 本身的 state 属性中指定原始默认值。
因此，这样做需要访问一个特殊的函数，称为 `$reset`。
`<button @click="taskStore.$reset">reset the state</button>`

从 Pinia 中使用的一个 hook，名为 storeToRefs，这个 hook 的作用是从 store 中获取所有不同的 state 属性和 Getters，然后创建refs。（这只是一个选项，但是以这种方式无法获取 actions 并使用。**因此如果需要 store 中的 actions，那么肯定只需使用 store 本身**）
```vue
<template>
  <main>

    <!-- heading -->
    <header>
      <img src="https://pinia.vuejs.org/logo.svg" alt="pinia logo">
      <h1>Pinia Tasks</h1>
    </header>

    <!-- new task form -->
    <div class="new-task-form">
      <TaskForm />
    </div>

    <!-- filter -->
    <nav class="filter">
      <button @click="filter = 'all'">All tasks</button>
      <button @click="filter = 'favs'">Fav tasks</button>
    </nav>

    <!-- loading -->
    <div class="loading" v-if="loading">Loading tasks...</div>

    <!-- task list -->
    <div class="task-list" v-if="filter === 'all'">
      <p>You have {{ totalCount }} tasks left to do.</p>
      <div v-for="task in tasks" :key="task.id">
        <TaskDetails :task="task" />
      </div>
    </div>
    <div class="task-list" v-if="filter === 'favs'">
      <p>You have {{ favCount }} tasks in your favs list.</p>
      <div v-for="task in favs" :key="task.id">
        <TaskDetails :task="task" />
      </div>
    </div>

    <button @click="taskStore.$reset">reset the state</button>

  </main>
</template>

<script>
  import TaskDetails from './components/TaskDetails.vue'
  import TaskForm from './components/TaskForm.vue'

  import { useTaskStore } from './stores/TaskStore'
  import { ref } from 'vue'
  import { storeToRefs } from 'pinia'

  export default {
    components: { TaskDetails, TaskForm },
    setup() {
      const taskStore = useTaskStore()

      const { tasks, loading, favs, totalCount, favCount } = storeToRefs(taskStore)

      // fetch tasks
      taskStore.getTasks()

      const filter = ref('all')

      return { taskStore, filter, tasks, loading, favs, totalCount, favCount }
    }
  }
</script>
```


