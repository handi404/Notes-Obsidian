学习如何在 Pinia store 中管理 Firestore 数据。Pinia 是一种状态管理解决方案，用于 Nuxt 和 Vue。 以及 Firestore，这是一种真正的 Firebase 提供的时间托管数据库。
[github 库](https://github.com/iamshaunjp/pinia-with-firestore/blob/lesson-9/plugins/firebase.client.js)
### 设置
`npx nuxi@latest init <project-name>`

安装 Tailwind，后面会使用 Tailwind 类来设置组件的样式。
`npm install --save-dev @nuxtjs/tailwindcss` 后在 nuxt.config.ts 中配置。

### Firebase 设置
设置一个 firestore 数据库并从应用程序连接到它。
进入你的基本控制台，其中列出了你当前的所有基于 Fire 的项目，创建一个全新的项目。
将 Firebase 添加至我们的网页应用（不需要 `Firebase Hosting托管`），完成注册后，它会告诉您如何将其添加到项目中。
```js
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyBa9Pk1Ju-nYcdeuYSX740J5FgaE5ROriM",
  authDomain: "habitsapp-aa8ae.firebaseapp.com",
  projectId: "habitsapp-aa8ae",
  storageBucket: "habitsapp-aa8ae.firebasestorage.app",
  messagingSenderId: "455333457135",
  appId: "1:455333457135:web:19b916491f497ed90aff1a"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
```
然后点击继续到控制台，我们想激活 Firestore 存储数据库，所以点击 Build 和然后转到这 `Firestore Database`，单击创建数据库，然后选择位置。启用 `测试模式(test mode)`，现在 `生产模式(prodection mode)` 已经设置一些**基本规则(所有第三方读写操作都将被拒绝)**。我们从测试模式开始，不要分享你的详细信息。
可以开始一个新的集合(Start collection)，但我们不这样做，因为我们实际上稍后会**通过代码创建集合**。

继续从应用程序连接到我们的 Firebase 应用程序。
首先 `npm install firebase`
创建一个 `no plugin` 程序来运行所有的连接逻辑。使用无插件程序是一种封装方法，可以在 Nuxt 应用启动时自动运行一些自定义逻辑，在它完全启动之前初始化，所以这是注册任何第三方服务（如 Firebase）的好方法，以确保在浏览器中查看应用程序时已准备就绪。
因此要制作自定义插件(custom plugin)，首先需要一个 **`plugins` 文件夹，该文件夹不会自动扫描**，对于在该文件夹中创建的插件，我们需要通过创建一个名为 `firebase.client.js` 的文件来创建一个新插件，现在 **.client** 后缀告诉 nuxt，此插件文件只能在客户端浏览器上运行而不是服务器上，因为记住**不能在客户端和服务器上同时运行代码，但对于 Firebase 代码，我们需要运行的代码只需要在浏览器中运行**。（但如果你在 plugins 里嵌套文件夹中创建一个插件，那么 nuxt 不会自动扫描它，你需要在 nuxt 配置文件中注册该插件）

在 firebase.client.js 文件中使用 `defineNuxtPlugin()` 插件函数来(这个函数本身已经完全嵌入 nuxt 中)创建一个新的插件。将一个函数作为参数传入，将在 firebase 复制的代码粘贴。
使用导入的初始化应用程序函数并传入 filebaseConfig 对象，因此 `initializeApp` 函数返回一个 firebase 应用程序的实例，我们将其存储在 `app` 常量，然后可以使用它来初始化所有 firebase 服务，例如 firestore 服务。所以通过 app 设置 firestore 连接，然后我们可以使用它与 firestore 进行存储数据库交互操作。
```js
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
export default defineNuxtPlugin((params) => {
  const firebaseConfig = {
    apiKey: "AIzaSyBa9Pk1Ju-nYcdeuYSX740J5FgaE5ROriM",
    authDomain: "habitsapp-aa8ae.firebaseapp.com",
    projectId: "habitsapp-aa8ae",
    storageBucket: "habitsapp-aa8ae.firebasestorage.app",
    messagingSenderId: "455333457135",
    appId: "1:455333457135:web:19b916491f497ed90aff1a",
  };
  // 初始化firebase
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  return {
    provide: {
      firebaseApp: app,
      db: db,
    },
  };
});
```

### 设置 Pinia store
[[JavaScript/FrameworkAndLibrary/Pinia/基础|基础]]
`npm i pinia @pinia/nuxt`
在配置文件中注册该模块：
```ts
export default defineNuxtConfig({
    modules: ['@pinia/nuxt'],
})
```
```js
import { defineStore } from "pinia";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //fetch habits from server
    //add habit
    //delete habit
    //update habit
    // completing a daily habit
    // calculate habit streak
  },
});
```

### Adding New Documents
首先，将新文档保存到 firestore 数据库中的集合；其次，将在 store 中的 state 中添加一个新的对象。
```js
import { defineStore } from "pinia";
import { addDoc, collection } from "firebase/firestore";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //add habit
    async addHabit(name) {
      const { $db } = useNuxtApp();
      const habit = {
        name,
        completions: [],
        streak: 0,
      };
      const docRef = await addDoc(collection($db, "habits"), habit);
      this.habits.push({ id: docRef.id, ...habit });
    },
  },
});
```
之后在组件表单中使用此操作：
```vue
<script setup>
import { useHabitStore } from "~/stores/habitStore";

const name = ref("");
const habitStore = useHabitStore();

const handleSubmit = async () => {
  if (name.value.trim()) {
    await habitStore.addHabit(name.value);
    name.value = "";
  }
};
</script>
```

### Fetching Documents
从 firestore 中获取所有文档，然后一旦获取了这些文档，就可以更新本地 pinia state。
```js
import { defineStore } from "pinia";
import { addDoc, collection, doc, getDocs } from "firebase/firestore";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //fetch habits from server
    async fetchHabits() {
      const { $db } = useNuxtApp();
      const snapshot = await getDocs(collection($db, "habits"));
      this.habits = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
    },
  },
});

```
应用程序首次启动时从主页（索引页）调用此操作，以便可以从数据库中获取所有初始数据。
之后将集合传递到 HabitList
```vue
<template>
  <div class="mx-auto p-6 max-w-2xl">
    <h1 class="text-4xl font-bold text-center mb-8">Habit Tracker</h1>
    <HabitForm />
    <HabitList :habits="habitStore.habits" />
  </div>
</template>

<script setup>
import { useHabitStore } from "~/stores/habitStore";
const habitStore = useHabitStore();
habitStore.fetchHabits();
</script>
```
在 HabitList 将文档显示：
```vue
<script setup>
const props = defineProps({
  habits: Array,
});
</script>
```
那么当再次添加文档，我们也会在页面上看到这个新文档，这并不是因为我们从 Firebase 重新获取了数据，而是因为当我们添加新文档时，pinia store 中的添加操作也会将该文档添加到本地 store state，然后**当 state 发生改变时，它会将变化传播到使用该 state 的任何组件并触发渲染**，因此我们可以看到添加后就显示。

### Deleting Documents
