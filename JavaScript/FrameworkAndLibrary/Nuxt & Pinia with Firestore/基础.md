学习如何在 Pinia store 中管理 Firestore 数据。Pinia 是一种状态管理解决方案，用于 Nuxt 和 Vue。 以及 Firestore，这是一种真正的 Firebase 提供的时间托管数据库。
[github 库](https://github.com/iamshaunjp/pinia-with-firestore/blob/lesson-9/plugins/firebase.client.js)
### 设置
`npx nuxi@latest init <project-name>`

安装 Tailwind，后面会使用 Tailwind 类来设置组件的样式。
`npm install --save-dev @nuxtjs/tailwindcss` 后在 nuxt.config.ts 中配置。

### Firebase 设置
设置一个 firestore 数据库并从应用程序连接到它。
进入你的基本控制台，其中列出了你当前的所有基于 Fire 的项目，创建一个全新的项目。
将 Firebase 添加至我们的网页应用（不需要 `Firebase Hosting托管`），完成注册后，它会告诉您如何将其添加到项目中。
```js
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyBa9Pk1Ju-nYcdeuYSX740J5FgaE5ROriM",
  authDomain: "habitsapp-aa8ae.firebaseapp.com",
  projectId: "habitsapp-aa8ae",
  storageBucket: "habitsapp-aa8ae.firebasestorage.app",
  messagingSenderId: "455333457135",
  appId: "1:455333457135:web:19b916491f497ed90aff1a"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
```
然后点击继续到控制台，我们想激活 Firestore 存储数据库，所以点击 Build 和然后转到这 `Firestore Database`，单击创建数据库，然后选择位置。启用 `测试模式(test mode)`，现在 `生产模式(prodection mode)` 已经设置一些**基本规则(所有第三方读写操作都将被拒绝)**。我们从测试模式开始，不要分享你的详细信息。
可以开始一个新的集合(Start collection)，但我们不这样做，因为我们实际上稍后会**通过代码创建集合**。

### 配置插件连接 Firabase
[[插件 (Plugins)]]
继续从应用程序连接到我们的 Firebase 应用程序。
首先 `npm install firebase`
创建一个 `no plugin` 程序来运行所有的连接逻辑。使用无插件程序是一种封装方法，可以在 Nuxt 应用启动时自动运行一些自定义逻辑，在它完全启动之前初始化，所以这是注册任何第三方服务（如 Firebase）的好方法，以确保在浏览器中查看应用程序时已准备就绪。
因此要制作自定义插件(custom plugin)，首先需要一个 **`plugins` 文件夹，该文件夹不会自动扫描**，对于在该文件夹中创建的插件，我们需要通过创建一个名为 `firebase.client.js` 的文件来创建一个新插件，现在 **.client** 后缀告诉 nuxt，此插件文件只能在客户端浏览器上运行而不是服务器上，因为记住**不能在客户端和服务器上同时运行代码，但对于 Firebase 代码，我们需要运行的代码只需要在浏览器中运行**。（但如果你在 plugins 里嵌套文件夹中创建一个插件，那么 nuxt 不会自动扫描它，你需要在 nuxt 配置文件中注册该插件）

在 firebase.client.js 文件中使用 `defineNuxtPlugin()` 插件函数来(这个函数本身已经完全嵌入 nuxt 中)创建一个新的插件。将一个函数作为参数传入，将在 firebase 复制的代码粘贴。
使用导入的初始化应用程序函数并传入 filebaseConfig 对象，因此 `initializeApp` 函数返回一个 firebase 应用程序的实例，我们将其存储在 `app` 常量，然后可以使用它来初始化所有 firebase 服务，例如 firestore 服务。所以通过 app 设置 firestore 连接，然后我们可以使用它与 firestore 进行存储数据库交互操作。
```js
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
export default defineNuxtPlugin((params) => {
  const firebaseConfig = {
    apiKey: "AIzaSyBa9Pk1Ju-nYcdeuYSX740J5FgaE5ROriM",
    authDomain: "habitsapp-aa8ae.firebaseapp.com",
    projectId: "habitsapp-aa8ae",
    storageBucket: "habitsapp-aa8ae.firebasestorage.app",
    messagingSenderId: "455333457135",
    appId: "1:455333457135:web:19b916491f497ed90aff1a",
  };
  // 初始化firebase
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  return {
    provide: {
      firebaseApp: app,
      db: db,
    },
  };
});
```

### 设置 Pinia store
[[JavaScript/FrameworkAndLibrary/Pinia/基础|基础]]
`npm i pinia @pinia/nuxt`
在配置文件中注册该模块：
```ts
export default defineNuxtConfig({
    modules: ['@pinia/nuxt'],
})
```
```js
import { defineStore } from "pinia";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //fetch habits from server
    //add habit
    //delete habit
    //update habit
    // completing a daily habit
    // calculate habit streak
  },
});
```

### Adding New Documents
首先，将新文档保存到 firestore 数据库中的集合；其次，将在 store 中的 state 中添加一个新的对象。
**使用 collection 函数获取集合引用**。
```js
import { defineStore } from "pinia";
import { addDoc, collection } from "firebase/firestore";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //add habit
    async addHabit(name) {
      const { $db } = useNuxtApp();
      const habit = {
        name,
        completions: [],
        streak: 0,
      };
      const docRef = await addDoc(collection($db, "habits"), habit);
      this.habits.push({ id: docRef.id, ...habit });
    },
  },
});
```
之后在组件表单中使用此操作：
```vue
<script setup>
import { useHabitStore } from "~/stores/habitStore";

const name = ref("");
const habitStore = useHabitStore();

const handleSubmit = async () => {
  if (name.value.trim()) {
    await habitStore.addHabit(name.value);
    name.value = "";
  }
};
</script>
```

### Fetching Documents
从 firestore 中获取所有文档，然后一旦获取了这些文档，就可以更新本地 pinia state。
```js
import { defineStore } from "pinia";
import { addDoc, collection, doc, getDocs } from "firebase/firestore";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //fetch habits from server
    async fetchHabits() {
      const { $db } = useNuxtApp();
      const snapshot = await getDocs(collection($db, "habits"));
      this.habits = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
    },
  },
});

```
应用程序首次启动时从主页（索引页）调用此操作，以便可以从数据库中获取所有初始数据。
之后将集合传递到 HabitList
```vue
<template>
  <div class="mx-auto p-6 max-w-2xl">
    <h1 class="text-4xl font-bold text-center mb-8">Habit Tracker</h1>
    <HabitForm />
    <HabitList :habits="habitStore.habits" />
  </div>
</template>

<script setup>
import { useHabitStore } from "~/stores/habitStore";
const habitStore = useHabitStore();
habitStore.fetchHabits();
</script>
```
在 HabitList 将文档显示：
```vue
<script setup>
const props = defineProps({
  habits: Array,
});
</script>
```
那么当再次添加文档，我们也会在页面上看到这个新文档，这并不是因为我们从 Firebase 重新获取了数据，而是因为当我们添加新文档时，pinia store 中的添加操作也会将该文档添加到本地 store state，然后**当 state 发生改变时，它会将变化传播到使用该 state 的任何组件并触发渲染**，因此我们可以看到添加后就显示。

### Deleting Documents
从 Firestore和 Store State 中删除。
记住每个文档都有一个由 Firestore 分配的唯一 ID，当我们想要删除它或对它进行某些操作时，我们需要识别该文档。需要导入一个名为 `doc` 的函数来自 firestore 模块，就像我们可以使用 collection 函数来获取集合引用一样，我们可以**使用 doc 函数来获取文档引用**。
```js
import { defineStore } from "pinia";
import {
  addDoc,
  collection,
  doc,
  getDocs,
  deleteDoc,
} from "firebase/firestore";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //delete habit
    async deleteHabit(id) {
      const { $db } = useNuxtApp();
      // delete in firebase
      const docRef = doc($db, "habits", id);
      await deleteDoc(docRef);
      // delete from pinia store
      this.habits = this.habits.filter((habit) => habit.id !== id);
    },
  },
});
```
之后在 delete button 上添加 deleteHabit 事件：
```vue
<template>
  <div>
    <ul class="space-y-4">
      <li
        class="bg-white px-3 py-2 rounded-sm"
        v-for="habit in habits"
        :key="habit.id"
      >
        <div class="flex items-center justify-between mb-4">
          <p class="text-purple-500 font-bold">{{ habit.name }}</p>
          <button class="text-gray-800" @click="deleteHabit(habit.id)">
            Delete
          </button>
        </div>
      </li>
    </ul>
  </div>
</template>

<script setup>
const props = defineProps({
  habits: Array,
});
const habitStore = useHabitStore();
const deleteHabit = async (id) => {
  await habitStore.deleteHabit(id);
};
</script>
```

### Updating Documents
进行**通用更新**操作来保存对 Fire Store 的任何更改或更新，然后也保存到 Store State。
对 updateHabit() 传入两个参数 id, updates 是修改的部分。
```js
import { defineStore } from "pinia";
import {
  addDoc,
  collection,
  doc,
  getDocs,
  deleteDoc,
  updateDoc,
} from "firebase/firestore";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //update habit
    async updateHabit(id, updates) {
      const { $db } = useNuxtApp();
      const docRef = doc($db, "habits", id);
      await updateDoc(docRef, updates);
      const index = this.habits.findIndex((habit) => habit.id === id);
      this.habits[index] = { ...this.habits[index], ...updates };
    },
  },
});
```

### Completing Habits
现在有一个通用的更新操作来执行 habit 的更新，现在做一个更具体的操作来切换 habit的完成。
在两种情况下处理的情况是，用户勾选完成复选框来完成 habit，然后还有一种情况是用户取消勾选完成复选框来撤消 habit 的完成。
处理这两种不同的情况，我们把这个动作称为 toggleCompletion，这一次它不需要是异步的，因为不会直接接触 firebase。
考虑一下这两种情况：**第一个是当用户勾选复选框来完成 habit 时，我们需将今天的日期添加到该特定 habit 的 `completions: []` 数组中；第二种情况，当取消选中复选框以取消完成 habit 的完成，我们需从 `completions: []` 中删除今天的日期。**
要安装第三方包 `date-fns` 来更好地格式化日期：`npm install date-fns`，`format` 函数允许我们传入一个标准日期时间值以及格式化选项作为参数。
```js
import { defineStore } from "pinia";
import {
  addDoc,
  collection,
  doc,
  getDocs,
  deleteDoc,
  updateDoc,
} from "firebase/firestore";
import { format } from "date-fns";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //update habit
    async updateHabit(id, updates) {
      const { $db } = useNuxtApp();
      const docRef = doc($db, "habits", id);
      await updateDoc(docRef, updates);
      const index = this.habits.findIndex((habit) => habit.id === id);
      this.habits[index] = { ...this.habits[index], ...updates };
    },
    // completing a daily habit
    toggleCompletion(habit) {
      const today = format(new Date(), "yyyy-mm-dd");
      if (habit.completions.includes(today)) {
        habit.completions = habit.completions.filter((date) => date !== today);
      } else {
        habit.completions.push(today);
      }
      this.updateHabit(habit.id, {
        completions: habit.completions,
      });
    },
  },
});
```
之后再复选框上添加 toggleCompletion 事件：
```vue
<template>
  <div>
    <ul class="space-y-4">
      <li
        class="bg-white px-3 py-2 rounded-sm"
        v-for="habit in habits"
        :key="habit.id"
      >
        <div class="flex items-center justify-between mb-4">
          <p class="text-purple-500 font-bold">
            <span
              :class="{ 'line-through': habit.completions.includes(today) }"
            >
              {{ habit.name }}
            </span>
          </p>
          <button class="text-gray-800" @click="deleteHabit(habit.id)">
            Delete
          </button>
        </div>

        <div class="flex items-center">
          <input
            type="checkbox"
            class="mr-2 accent-purple-500"
            @change="toggleCompletion(habit)"
            :checked="habit.completions.includes(today)"
          />
          <p class="text-sm text-gray-500">I did this today.</p>
        </div>
      </li>
    </ul>
  </div>
</template>

<script setup>
import { format } from "date-fns";
const props = defineProps({
  habits: Array,
});
const habitStore = useHabitStore();

const deleteHabit = async (id) => {
  await habitStore.deleteHabit(id);
};
const toggleCompletion = async (habit) => {
  await habitStore.toggleCompletion(habit);
};
const today = format(new Date(), "yyyy-mm-dd");
</script>
```

### Adding to the Streak
当用户通过勾选框完成当天的 habit 时，streak 会增加一，另一方面如果取消勾选，需要 streak 减少一。如果用户 habit 完成之间的时间间隔较长，我们需要中断 streak，并将其重置为零。
添加 `differenceInDays` 函数，该函数允许我们传入两个日期，然后计算出这两个日期之间的天数。
```js
import { defineStore } from "pinia";
import {
  addDoc,
  collection,
  doc,
  getDocs,
  deleteDoc,
  updateDoc,
} from "firebase/firestore";
import { format, differenceInDays } from "date-fns";
export const useHabitStore = defineStore("habitStore", {
  state: () => ({
    habits: [],
  }),
  actions: {
    //update habit
    async updateHabit(id, updates) {
      const { $db } = useNuxtApp();
      const docRef = doc($db, "habits", id);
      await updateDoc(docRef, updates);
      const index = this.habits.findIndex((habit) => habit.id === id);
      this.habits[index] = { ...this.habits[index], ...updates };
    },
    // completing a daily habit
    toggleCompletion(habit) {
      const today = format(new Date(), "yyyy-mm-dd");
      if (habit.completions.includes(today)) {
        habit.completions = habit.completions.filter((date) => date !== today);
      } else {
        habit.completions.push(today);
      }

      habit.streak = this.calculateSteak(habit.completions);

      this.updateHabit(habit.id, {
        completions: habit.completions,
        streak: habit.streak,
      });
    },
    // calculate habit streak
    calculateSteak(completions) {
      const sortedDates = completions.sort((a, b) => new Date(a) - new Date(b));
      let streak = 0;
      let today = new Date();

      for (const date of sortedDates) {
        const diff = differenceInDays(today, new Date(date));
        if (diff > 1) {
          break;
        }
        streak += 1;
        today = new Date(date);
      }
      return streak;
    },
  },
});
```

