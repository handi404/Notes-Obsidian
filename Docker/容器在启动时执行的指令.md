Docker 容器在启动时执行的指令由 **Dockerfile 中的 `CMD` 或 `ENTRYPOINT` 指令**决定。以下是详细的解释和示例：

---

### **1. `CMD` 和 `ENTRYPOINT` 的作用**
这两个指令用于定义容器启动时执行的命令，但它们的行为有所不同：

#### **`CMD`**
- **作用**：提供容器启动时的**默认命令**，可以被 `docker run` 命令行参数覆盖。
- **示例**：
  ```dockerfile
  CMD ["java", "-jar", "app.jar"]
  ```
  - 如果运行容器时指定其他命令（如 `docker run my-image bash`），会覆盖 `CMD`。

#### **`ENTRYPOINT`**
- **作用**：定义容器启动时的**主命令**，不会被 `docker run` 参数覆盖，但参数会作为补充传递给 `ENTRYPOINT`。
- **示例**：
  ```dockerfile
  ENTRYPOINT ["java", "-jar", "app.jar"]
  ```
  - 如果运行 `docker run my-image --spring.profiles.active=prod`，最终执行的命令是 `java -jar app.jar --spring.profiles.active=prod`。

---

### **2. 容器如何确定启动指令？**
Docker 会按照以下优先级确定启动命令：
1. **`docker run` 命令行参数**（仅覆盖 `CMD`）。
2. **Dockerfile 中的 `CMD`**（默认命令）。
3. **Dockerfile 中的 `ENTRYPOINT`**（主命令，不可覆盖）。

#### **规则总结**：
- 如果同时定义了 `ENTRYPOINT` 和 `CMD`：
  - `ENTRYPOINT` 是主命令。
  - `CMD` 是默认参数，可以通过 `docker run` 传递参数覆盖。

---

### **3. 示例：Spring Boot 项目的 Dockerfile**
假设你的 Spring Boot 项目打包为 `app.jar`，Dockerfile 可以这样定义：
```dockerfile
# 使用基础镜像
FROM openjdk:8-jdk-alpine

# 复制 JAR 文件到容器
COPY target/app.jar /app.jar

# 定义启动命令（CMD）
CMD ["java", "-jar", "/app.jar"]
```
- 当运行 `docker run my-springboot-image` 时，容器会执行 `java -jar /app.jar`。
- 如果运行 `docker run my-springboot-image --spring.profiles.active=prod`，会覆盖 `CMD`，最终执行 `--spring.profiles.active=prod`（这显然不正确，因为缺少主命令）。

#### **改进：使用 `ENTRYPOINT`**
```dockerfile
ENTRYPOINT ["java", "-jar", "/app.jar"]
```
- 运行 `docker run my-springboot-image --spring.profiles.active=prod` 时，实际执行 `java -jar /app.jar --spring.profiles.active=prod`。

---

### **4. 调试容器启动命令**
如果容器启动失败，可以通过以下方法检查命令是否正确：

#### **方法 1：查看容器日志**
```bash
docker logs <容器名或ID>
```

#### **方法 2：覆盖命令进入 Shell**
强制启动容器并进入交互式 Shell（用于排查问题）：
```bash
docker run -it --entrypoint /bin/sh my-springboot-image
```

---

### **5. 常见问题**
#### **问题 1：容器启动后立即退出**
- **原因**：`CMD` 或 `ENTRYPOINT` 指定的命令执行完毕（例如启动脚本未持续运行）。
- **解决**：确保命令是长时间运行的进程（如 `java -jar app.jar`）。

#### **问题 2：命令路径错误**
- **示例**：`CMD ["java", "-jar", "app.jar"]` 中 `app.jar` 不存在。
- **解决**：在 Dockerfile 中使用绝对路径（如 `/app.jar`），并通过 `COPY` 确保文件存在。

#### **问题 3：参数传递失败**
- **示例**：使用 `ENTRYPOINT` 时未正确处理参数。
- **解决**：确保 `ENTRYPOINT` 使用 `exec` 格式（如 `["java", "-jar", "app.jar"]`），而不是 Shell 格式（如 `java -jar app.jar`）。

---

### **6. 最佳实践**
4. **使用 `ENTRYPOINT` 定义主命令**：确保应用始终以预期方式启动。
5. **使用 `CMD` 提供默认参数**：允许通过 `docker run` 自定义参数。
6. **避免 Shell 格式**：优先使用 `["executable", "param1", "param2"]`（exec 格式），避免依赖 Shell 解释。

---

### **总结**
- 容器启动的指令由 Dockerfile 中的 `CMD` 或 `ENTRYPOINT` 定义。
- 通过 `docker run` 可以覆盖 `CMD` 的参数，但 `ENTRYPOINT` 是固定的主命令。
- 确保启动命令路径正确，并且是长时间运行的进程（如 Spring Boot 应用）。

如果需要更具体的场景分析，可以提供更多细节！