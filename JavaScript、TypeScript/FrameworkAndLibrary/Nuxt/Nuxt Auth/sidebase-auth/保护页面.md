## Protecting Pages 保护页面
---
NuxtAuth 提供了不同的方法来保护页面：

- **Global middleware:** Protects all pages with manual exceptions  
	**全局中间件：** 保护所有页面，但有手动例外
- **Local middleware:** Protects specific pages  
	**本地中间件：** 保护特定页面
- **Custom middleware:** Create your own middleware  
	**自定义中间件：** 创建您自己的中间件

## 全局中间件
---
要在应用程序上启用全局中间件，您可以在 `nuxt.config.ts` 中配置中间件。

```ts
export default defineNuxtConfig({
  modules: ['@sidebase/nuxt-auth'],
  auth: {
    globalAppMiddleware: true
  }
})
```

如果想进一步自定义全局中间件，可以将配置对象传递给 `globalAppMiddleware` 。

### 禁用全局中间件

如果禁用了全局中间件，则可以手动将中间件添加到各个页面。这仅在禁用全局中间件时可用，因为您将收到类似 `Error: Unknown route middleware: 'auth'`.这是因为 auth 中间件随后被全局添加，不能用作本地的、特定于页面的中间件。

```vue
<script lang="ts" setup>
definePageMeta({
  middleware: 'sidebase-auth'
})
</script>

<template>
  Only I am protected!
</template>
```

## Local Middleware 本地中间件
---
要在单个页面上本地启用或禁用中间件，您可以使用 [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) 宏为单个页面设置身份验证元数据。

```vue
<script setup lang="ts">
definePageMeta({
  auth: false
})
</script>

<template>
  I am not protected anymore!
</template>
```

### Middleware options 中间件选项

`auth` 可以是布尔值，也可以是其他中间件配置的对象。

```vue
<script setup lang="ts">
definePageMeta({
  auth: {
    unauthenticatedOnly: false,
    navigateUnauthenticatedTo: '/auth/signin'
  }
})
</script>

<template>
  I am protected with a custom redirect!
</template>
```

#### unauthenticatedOnly 仅未验证

是否仅允许未经身份验证的用户访问此页面。经过身份验证的用户将被重定向到 `/` 或 `navigateAuthenticatedTo` 中指定的路由。

如果你想让每个人都能看到该页面，请改为设置 `auth： false` （参见 [本地中间件](https://auth.sidebase.io/guide/application-side/#local-middleware) ）。

WARNING 警告

从 `0.9.4` 开始需要此选项，以防止歧义（ [相关问题](https://github.com/sidebase/nuxt-auth/issues/926) ）。请务必设置它，否则将 **默认启用** [访客模式](https://auth.sidebase.io/guide/application-side/#guest-mode) — 您的访客将能够看到该页面，但经过身份验证的用户将被重定向走。

#### navigateAuthenticatedTo

如果 `unauthenticatedOnly` 设置为 `true` ，则重定向到经过身份验证的用户的位置。

#### navigateUnauthenticatedTo

如果此页面受保护，则重定向到未经身份验证的用户的位置。

### Guest mode 访客模式

您可以使用 NuxtAuth 设置仅在用户 **未登录** 时才能访问的页面。这有时称为 *“来宾模式”。* 此类页面的行为如下：

- 已登录的用户访问页面 -> 重定向到另一个（可能受保护的）页面。
- 已注销的用户访问页面 -> 允许他们停留并查看的页面

此行为对于您不希望登录用户访问的登录页面非常有用：为什么他们应该再次执行登录流程？

```vue
<script setup lang="ts">
definePageMeta({
  auth: {
    unauthenticatedOnly: true,
    navigateAuthenticatedTo: '/profile'
  }
})
</script>

<template>
  I can only be viewed as a guest!
</template>
```

## Custom Middleware 自定义中间件
---
您可以创建自己的应用程序端中间件，以实现自定义的、更高级的身份验证逻辑。

WARNING 警告

创建自定义中间件是一个高级的实验性选项，如果您不熟悉高级 Nuxt 3 概念，可能会导致意外或意外的行为。

要实现自定义中间件，请执行以下：

- 创建一个全局应用或命名的应用端中间件（有关更多信息，请参阅 Nuxt 文档）
- 为其添加基于 [`useAuth`](https://auth.sidebase.io/guide/application-side/session-access) 的逻辑

添加 logic 时，您需要注意 `调用其他异步` 可组合函数时。这可能会导致 Nuxt 中出现 `上下文` 问题，请参阅 [此处的解释](https://github.com/nuxt/framework/issues/5740#issuecomment-1229197529) 。为了避免这些问题，您需要：

- 在等待其他可组合项时使用未记录的 `callWithNuxt` 实用程序
- 尽可能返回一个异步函数，而不是等待它以避免 `callWithNuxt`

Direct return 直接返回：
```ts
// file: ~/middleware/authentication.global.ts
export default defineNuxtRouteMiddleware((to) => {
  const { status, signIn } = useAuth()

  // Return immediately if user is already authenticated
  if (status.value === 'authenticated') {
    return
  }

  /**
   * We cannot directly call and/or return `signIn` here as `signIn` uses async composables under the hood, leading to "nuxt instance undefined errors", see https://github.com/nuxt/framework/issues/5740#issuecomment-1229197529
   *
   * So to avoid calling it, we return it immediately.
   */
  return signIn(undefined, { callbackUrl: to.path }) as ReturnType<typeof navigateTo>
})
```

Call with Nuxt 与 Nuxt 通话：
```ts
// file: ~/middleware/authentication.global.ts
import { useNuxtApp } from '#imports'
import { callWithNuxt } from '#app/nuxt'

export default defineNuxtRouteMiddleware((to) => {
  // It's important to do this as early as possible
  const nuxtApp = useNuxtApp()

  const { status, signIn } = useAuth()

  // Return immediately if user is already authenticated
  if (status.value === 'authenticated') {
    return
  }

  /**
   * We cannot directly call and/or return `signIn` here as `signIn` uses async composables under the hood, leading to "nuxt instance undefined errors", see https://github.com/nuxt/framework/issues/5740#issuecomment-1229197529
   *
   * So to avoid calling it, we call it via `callWithNuxt`.
   */
  await callWithNuxt(nuxtApp, signIn, [undefined, { callbackUrl: to.path }])
})
```