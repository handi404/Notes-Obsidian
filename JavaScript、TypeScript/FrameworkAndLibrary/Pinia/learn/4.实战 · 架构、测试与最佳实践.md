跳出 API 的具体使用，从项目全局的视角来审视 Pinia。学习如何像一名经验丰富的架构师一样，组织你的代码，保证其质量，并优化其性能。

---

### **项目结构 (Architecture) - 搭建可维护的 Store 大厦**

**目标**：学会在中大型项目中，如何优雅地组织你的 `stores` 目录，使其清晰、可扩展。

#### **【概念讲解】**

当你的应用只有一个或两个 Store 时，把它们都放在 `src/stores/` 目录下没什么问题。但当你有十几个甚至几十个 Store 时，一个扁平的目录结构会变成一场灾难。

**最佳实践：按功能或领域（Feature/Domain）组织 Store。**

就像你在电脑里会用文件夹把“工作文件”、“学习资料”、“娱乐影音”分门别类一样，我们也应该这样组织 Store。

#### **【示例：推荐的目录结构】**

**简单结构 (适用于中小型项目):**

```
src/
└── stores/
    ├── user.store.ts
    ├── cart.store.ts
    ├── products.store.ts
    └── index.ts  <-- (可选，但推荐)
```

**`stores/index.ts` (桶文件 - Barrel File):**
这个文件的作用是重新导出来自其他模块的所有内容，让外部导入更方便。

```typescript
// src/stores/index.ts
export * from './user.store'
export * from './cart.store'
export * from './products.store'
```

**使用时：**
```typescript
// 不使用 index.ts 的导入方式
import { useUserStore } from './stores/user.store'
import { useCartStore } from './stores/cart.store'

// 使用 index.ts 后的导入方式，更简洁
import { useUserStore, useCartStore } from './stores'
```

**高级结构 (适用于大型、复杂项目):**
当一个功能（如“后台管理”）自身就包含多个相关的 Store 时，可以进一步嵌套。

```
src/
└── stores/
    ├── user/
    |   ├── auth.store.ts      // 用户认证相关
    |   ├── profile.store.ts   // 用户资料相关
    |   └── index.ts           // 导出 user/ 下的所有 store
    ├── products/
    |   ├── list.store.ts      // 商品列表
    |   ├── detail.store.ts    // 商品详情
    |   └── index.ts
    └── cart.store.ts          // 购物车比较独立，可以放顶层
```

#### **【要点 / 注意事项】**

1.  **一致性是关键**：无论选择哪种结构，最重要的是在整个团队和项目中保持一致。
2.  **文件名约定**：坚持使用 `*.store.ts` 作为 Store 文件的后缀，可以让你和团队成员一眼就识别出文件的用途。

---

### **TypeScript 高级技巧 - 充分释放类型潜力**

**目标**：利用 Pinia 优秀的类型推断，编写更安全、可复用的类型代码。

#### **【概念讲解 & 代码示例】**

Pinia 的类型推断非常出色，但我们还可以更进一步，**获取一个 Store 实例的类型**，以便在别处复用。这在为组件的 `props` 添加类型时尤其有用。

**场景**：假设你有一个子组件，需要接收一个完整的 `userStore` 实例作为 prop。

```typescript
// src/stores/user.store.ts
// (假设 user.store.ts 已存在)
import { defineStore } from 'pinia'
export const useUserStore = defineStore(/*...*/)

// --- 获取 Store 类型 ---
// 使用 TypeScript 的 ReturnType 工具类型，获取 useUserStore 函数的返回类型
export type UserStore = ReturnType<typeof useUserStore>
```
现在 `UserStore` 就是 `userStore` 实例的精确类型！

**在组件中使用：**
```vue
// src/components/UserProfile.vue
<script setup lang="ts">
import type { UserStore } from '@/stores/user.store' // 导入类型

// 使用 defineProps 来定义 props 的类型
const props = defineProps<{
  // 告诉组件，我需要一个 UserStore 类型的 prop
  store: UserStore
}>()

// 现在你可以安全地使用 props.store，并获得完整的类型提示
// props.store.username
// props.store.login()
</script>

<template>
  <div>
    <!-- 使用传入的 store prop -->
    <p>用户名: {{ props.store.username }}</p>
  </div>
</template>
```

#### **【要点 / 注意事项】**

*   **类型与值分离**：注意，我们使用 `import type` 来导入类型。这告诉 TypeScript，我们只导入类型信息，在编译成 JavaScript 后，这条导入语句会被完全移除，不会产生运行时开销。

---

### **单元测试 (Unit Testing) - 保证你的逻辑坚如磐石**

**目标**：学会使用 Vitest（一个现代的测试框架）为你的 Pinia Store 编写单元测试。

#### **【概念讲解】**

Pinia Store 是测试的理想对象，因为它们是**独立的、可被导入的模块**。你可以不依赖任何 Vue 组件，直接测试 Store 的 State、Getters 和 Actions 的逻辑是否正确。

**核心步骤：**
1.  安装 `vitest`。
2.  创建一个测试环境，并为 Pinia 激活一个实例。
3.  在每个测试用例开始前，重置 Store 的状态，确保测试之间互不干扰。
4.  编写测试用例，断言（assert）State、Getters 和 Actions 的行为符合预期。

#### **【代码示例】**

假设我们要测试 `counter.store.ts`。

**Step 1: 安装 Vitest**
```bash
npm install -D vitest @vue/test-utils
```
在 `vite.config.ts` 中配置 Vitest（如果你的项目模板没有自动配置）：
```typescript
/// <reference types="vitest" />
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true,
    environment: 'jsdom', // 模拟 DOM 环境
  },
})
```

**Step 2: 编写测试文件**
在 `src/stores` 目录下，创建一个 `counter.store.spec.ts` 文件。

```typescript
// src/stores/counter.store.spec.ts

import { describe, it, expect, beforeEach } from 'vitest'
import { createPinia, setActivePinia } from 'pinia'
import { useCounterStore } from './counter.store'

// `describe` 用于组织一组相关的测试
describe('Counter Store', () => {
  // `beforeEach` 会在每个 `it` 测试用例运行前执行
  beforeEach(() => {
    // 1. 创建一个新的 Pinia 实例
    const pinia = createPinia()
    // 2. 将其设置为活动的 Pinia 实例。这是必须的！
    setActivePinia(pinia)
  })

  // `it` 定义一个具体的测试用例
  it('initializes with count 0', () => {
    const store = useCounterStore()
    // `expect` 是断言库，用来检查值是否符合预期
    expect(store.count).toBe(0)
  })

  it('increments the count', () => {
    const store = useCounterStore()
    // 调用 action
    store.increment()
    // 断言 state 发生了变化
    expect(store.count).toBe(1)
  })

  it('doubles the count with a getter', () => {
    const store = useCounterStore()
    expect(store.doubleCount).toBe(0)

    store.increment()
    expect(store.count).toBe(1)
    // 断言 getter 也随之更新
    expect(store.doubleCount).toBe(2)
  })
})
```
**Step 3: 运行测试**
在 `package.json` 中添加一个脚本：
```json
"scripts": {
  "test": "vitest"
}
```
然后在终端运行 `npm test`。

#### **【要点 / 注意事项】**

*   **`setActivePinia` 是关键**：在测试环境中，Pinia 不知道 Vue 应用的存在，所以你必须手动创建一个 Pinia 实例，并通过 `setActivePinia` 告诉 Pinia "现在请使用这个实例"。
*   **隔离测试**：`beforeEach` 确保了每个测试用例都在一个全新的、干净的 Store 实例上运行，避免了测试间的状态污染。

---

### **性能与优化 (Performance & Optimization) - 思考状态的边界**

**目标**：学会判断哪些状态应该放入 Pinia，哪些应该保留在组件本地。

#### **【概念讲解】**

Pinia 非常强大，但这不意味着你应该把应用的所有状态都塞进去。滥用全局状态会使应用状态变得难以追踪和管理。

**决策框架：什么时候应该用 Pinia？**

问自己以下几个问题，如果答案大部分是“是”，那么这个状态就适合放在 Pinia：

1.  **跨组件共享？** 这个数据是否被多个**没有直接父子关系**的组件需要？
2.  **需要持久化？** 这个数据是否需要在用户刷新页面，或在不同路由/页面之间保持不变？（例如：用户信息、主题设置）
3.  **全局性概念？** 这个数据是否代表一个应用的全局概念？（例如：登录状态、购物车内容）
4.  **与服务端状态同步？** 这个数据是否需要通过 Actions 从服务器获取，并在多处使用？

**反之，如果一个状态只被单个组件或其紧密的子组件使用，并且它的生命周期与该组件绑定（组件销毁，状态也无需保留），那么使用组件本地状态（`ref`, `reactive`）是更好的选择。**

#### **【要点 / 注意事项】**

*   **本地状态优先**：养成优先考虑组件本地状态的习惯。只有当数据确实需要“提升”到全局时，才将其移入 Pinia。
*   **按需加载 Store (超大型应用)**：在一些极大型的应用或微前端架构中，你甚至可以结合 Vue Router 的路由懒加载，实现 Store 的按需加载，但这属于非常高级的优化范畴。