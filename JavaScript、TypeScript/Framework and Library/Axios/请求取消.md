### 一、为什么需要取消请求？

想象几个常见的场景：

1.  **用户快速切换页面**：用户在 A 页面发起了一个耗时很长的请求，但他没等请求回来就切换到了 B 页面。此时 A 页面的请求其实已经没用了，但它仍在后台消耗着网络和服务器资源。更糟糕的是，如果请求回来后尝试更新 A 页面的状态（而 A 页面此时已经卸载），可能会导致内存泄漏或 React/Vue 报错。
2.  **搜索框的“边输入边搜索” (Debounce/Throttle)**：用户在搜索框里快速输入 "apple"。他可能依次触发了 `a` -> `ap` -> `app` -> `appl` -> `apple` 五次搜索请求。实际上，我们只关心最后一次 "apple" 的结果，前面的四次请求都应该被取消。
3.  **重复操作**：用户不小心连续点击了两次“提交”按钮，发起了两个完全相同的请求。我们应该可以取消掉其中一个。

在这些情况下，**主动取消不再需要的请求**，不仅能提升性能，更能增强应用的健壮性。

---

### 二、如何取消请求：`AbortController` (现代标准)

在过去，axios 使用一个自制的 `CancelToken` API。但现在，axios 已经完全拥抱了 Web 标准的 **`AbortController`**。这是所有现代浏览器和 Node.js 都支持的原生 API。

**请忘记 `CancelToken`，它已被废弃。现在唯一的正确方式就是 `AbortController`。**

#### 核心概念：一个遥控器和信号

`AbortController` 的工作方式非常直观，你可以把它想象成一个“遥控器”系统：

1.  **`new AbortController()`**: 创建一个控制器实例。这就好比你拿到了一个全新的 **遥-控-器**。
2.  **`controller.signal`**: 从遥控器上获取一个 **信-号**。这个 `signal` 是一个特殊的对象，你可以把它“交给”一个或多个 axios 请求。这相当于告诉这些请求：“你们要听这个信号的指挥”。
3.  **`controller.abort()`**: 按下遥控器上的“取消”按钮。一旦调用，所有收到了这个 `signal` 的请求都会立即被中断。

#### 代码实战：一个简单的例子

```javascript
import axios from 'axios';

// 1. 创建一个 AbortController 实例 (拿到遥控器)
const controller = new AbortController();

// 2. 发起请求，并将 controller.signal 传入配置 (把信号交给请求)
axios.get('/some/long-request', {
  signal: controller.signal 
}).then(response => {
  console.log('请求成功:', response.data);
}).catch(error => {
  // 3. 检查错误是否是由于取消操作导致的
  if (axios.isCancel(error)) {
    console.log('请求被取消了:', error.message);
  } else {
    // 处理其他错误
    console.error('请求发生错误:', error);
  }
});

// 在未来的某个时刻，比如 500 毫秒后，决定取消这个请求
setTimeout(() => {
  // 4. 调用 abort 方法 (按下取消按钮)
  controller.abort(); 
}, 500);
```
**关键点**：
*   被取消的请求会进入 `.catch` 块。
*   Axios 提供了一个非常有用的工具函数 `axios.isCancel(error)` 来判断一个错误是否是用户主动取消导致的。这比你自己去判断 `error.name === 'CanceledError'` 要更可靠。

---

### 三、扩展与应用：真实世界的取消策略

在实际项目中，取消逻辑通常和组件的生命周期或用户交互紧密相关。

#### 1. 组件卸载时自动取消请求（React & Vue 最佳实践）

这是**最最最常见**的用例。当组件即将被销毁时，应该取消所有由它发起的、但尚未完成的请求。

**React (使用 `useEffect` 清理副作用)**
```jsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // 1. 创建 AbortController
    const controller = new AbortController();

    const fetchUser = async () => {
      try {
        setLoading(true);
        const response = await axios.get('/api/user/123', {
          signal: controller.signal, // 2. 传递 signal
        });
        setUser(response.data);
      } catch (error) {
        if (axios.isCancel(error)) {
          console.log('Request canceled on component unmount');
        } else {
          // Handle other errors
        }
      } finally {
        setLoading(false);
      }
    };

    fetchUser();

    // 3. 返回一个清理函数
    return () => {
      // 在组件卸载时，调用 abort
      controller.abort();
    };
  }, []); // 空依赖数组表示只在 mount 和 unmount 时运行

  // ... render a loading state or the user profile
}
```

**Vue (使用 `onUnmounted` 生命周期钩子)**
```vue
<template>
  <div>...</div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import axios from 'axios';

const user = ref(null);
const loading = ref(true);

// 1. 在 setup 作用域顶部声明 controller
let controller = new AbortController();

onMounted(async () => {
  try {
    loading.value = true;
    const response = await axios.get('/api/user/123', {
      signal: controller.signal // 2. 传递 signal
    });
    user.value = response.data;
  } catch (error) {
    if (axios.isCancel(error)) {
      console.log('Request canceled on component unmount');
    } else {
      // Handle other errors
    }
  } finally {
    loading.value = false;
  }
});

// 3. 在组件卸载时调用 abort
onUnmounted(() => {
  controller.abort();
});
</script>
```

#### 2. 实现搜索框的防抖取消 (Debounce)

```javascript
import axios from 'axios';

let searchController; // 将 controller 提升到外部作用域

async function onSearchInput(query) {
  // 如果上一个请求还在进行中，先取消它
  if (searchController) {
    searchController.abort();
  }

  // 为新请求创建一个新的 controller
  searchController = new AbortController();

  try {
    const response = await axios.get(`/api/search?q=${query}`, {
      signal: searchController.signal
    });
    console.log('搜索结果:', response.data);
  } catch (error) {
    if (axios.isCancel(error)) {
      console.log('旧的搜索请求被取消');
    } else {
      console.error('搜索失败', error);
    }
  }
}

// 模拟用户输入
onSearchInput('a');
onSearchInput('ap'); // 'a'的请求会被取消
onSearchInput('app'); // 'ap'的请求会被取消
```

---

### 四、要点与注意事项

1.  **始终使用 `AbortController`**: 这是唯一的现代标准，不要再使用 `CancelToken`。
2.  **管理 Controller 的生命周期**: `AbortController` 实例是一次性的。一旦调用了 `.abort()`，它就永久处于“已取消”状态，不能再被复用。对于新的请求，需要创建新的 `AbortController` 实例。
3.  **一个 Controller 控制多个请求**: 你可以将同一个 `signal` 传递给多个 axios 请求。调用一次 `controller.abort()` 会同时取消所有这些关联的请求。这在需要一次性取消页面上所有请求时非常有用。
4.  **使用 `axios.isCancel()`**: 这是最可靠的判断请求是否被取消的方式。
5.  **取消是错误处理的一部分**: 被取消的请求会触发 `Promise` 的 `reject`，所以你的 `catch` 逻辑需要能正确处理这种情况。
6.  **在拦截器中使用**: 你也可以在请求拦截器中获取 `signal` 并进行某些高级操作，但这并不常见。主要的使用场景还是在业务代码中。