函数与作用域是 JavaScript 的灵魂所在。掌握了它们，你就掌握了编写灵活、健壮且可维护代码的关键。

---

### 1. Scope Chain (作用域链)

*这个概念是理解闭包和其他作用域问题的基础*

#### 核心概念
**作用域链 (Scope Chain)** 是 JavaScript 引擎查找变量的一套规则。当代码中需要访问一个变量时，引擎会：
1.  首先在**当前函数的作用域**中查找。
2.  如果找不到，就去其**父级作用域**（也就是定义该函数的那个作用域）中查找。
3.  这个过程会一直持续，一层一层地向上查找，直到找到该变量，或者到达最顶层的**全局作用域**。
4.  如果到全局作用域还找不到，就会抛出 `ReferenceError`。

这个由内向外的作用域查找路径，就形成了一个链条，即“作用域链”。

#### 语法与示例
```javascript
const globalVar = 'I am global';

function outerFunc() {
  const outerVar = 'I am in outer';

  function innerFunc() {
    const innerVar = 'I am in inner';
    // 查找过程:
    // 1. 在 innerFunc 作用域找 innerVar -> 找到了
    // 2. 在 innerFunc 作用域找 outerVar -> 没找到，去 outerFunc 作用域找 -> 找到了
    // 3. 在 innerFunc 作用域找 globalVar -> 没找到，去 outerFunc 作用域找 -> 没找到，去全局作用域找 -> 找到了
    console.log(innerVar);
    console.log(outerVar);
    console.log(globalVar);
  }

  innerFunc();
}

outerFunc();
```

#### 要点与注意事项
1.  **词法作用域 (Lexical Scoping):** 作用域链是在**代码编写时**就确定了的，而不是在函数调用时。函数的作用域取决于它被定义在哪里，而不是在哪里被调用。
2.  **块级作用域:** `let` 和 `const` 引入了块级作用域（由 `{}` 包围），这使得作用域链的查找更加精细。

---

### 2. Closures (闭包)

*闭包是 JavaScript 最强大也最容易混淆的特性之一，它直接建立在作用域链之上。*

#### 核心概念
**闭包 (Closure)** 是指一个**函数**以及其**被创建时所在的词法环境**（即作用域）的组合。

通俗地讲：**一个函数“记住”了它被创建时的作用域，即使它在那个作用域之外被执行，它仍然可以访问那个作用域里的变量。**

#### 语法与示例
经典的计数器例子：
```javascript
function createCounter() {
  let count = 0; // 这个 count 变量在 createCounter 的作用域内

  // 这个返回的函数是一个闭包
  return function() {
    count++;
    console.log(count);
  };
}

const counterA = createCounter(); // createCounter() 执行完毕，其作用域理应被销毁
const counterB = createCounter(); // 每个闭包都有自己独立的环境

// 但由于返回的函数（闭包）仍然引用着 `count`，所以那个作用域被“保留”了下来。
counterA(); // 输出: 1
counterA(); // 输出: 2

counterB(); // 输出: 1 (counterB 有自己独立的 count)
```
`counterA` 就是一个闭包。它是在 `createCounter` 内部定义的，所以它“记住”了 `createCounter` 的作用域，包括变量 `count`。

#### 扩展与应用
1.  **数据封装与私有变量:** 在 `class` 的私有字段 `#` 出现之前，闭包是模拟私有变量的主要方式。外部无法直接访问 `count`，只能通过返回的函数来操作它。
2.  **函数工厂:** 创建功能相似但配置不同的函数，如 `createAdder(5)` 返回一个 `addFive` 函数。
3.  **回调与异步:** 在回调函数中访问外部变量，例如在 `setTimeout` 的回调中使用循环变量。

#### 要点与注意事项
1.  **内存管理:** 闭包会使其引用的外部作用域持续存在于内存中。如果闭包持有对大型对象的引用，可能会导致内存泄漏。在不使用时，应将闭包函数的引用设为 `null` 以便垃圾回收。
2.  **循环中的闭包陷阱:**
    ```javascript
    for (var i = 0; i < 3; i++) { // 使用 var
      setTimeout(() => {
        console.log(i); // 输出三次 3，而不是 0, 1, 2
      }, 100);
    }
    ```
    因为 `var` 没有块级作用域，所有 `setTimeout` 的回调共享同一个 `i`，当它们执行时，循环早已结束，`i` 的值已变为 3。
    **现代解决方法：** 使用 `let`，因为它有块级作用域，每次循环都会创建一个新的 `i` 绑定。
    ```javascript
    for (let i = 0; i < 3; i++) { // 使用 let
      setTimeout(() => {
        console.log(i); // 正确输出 0, 1, 2
      }, 100);
    }
    ```

---

### 3. First-Class Functions (一等公民函数)

#### 核心概念
在 JavaScript 中，函数是“一等公民”。这意味着函数可以被当作**普通的值**来对待。你可以：
1.  将函数赋值给变量。
2.  将函数作为参数传递给另一个函数。
3.  让函数作为另一个函数的返回值。

#### 示例
```javascript
// 1. 赋值给变量
const greet = function() {
  console.log('Hello!');
};

// 2. 作为参数传递 (callback)
function execute(fn) {
  fn();
}
execute(greet); // 输出: Hello!

// 3. 作为返回值
function createGreeter() {
  return function() {
    console.log('Hi there!');
  };
}
const greeter = createGreeter();
greeter(); // 输出: Hi there!
```

#### 应用
这是实现**高阶函数**、回调模式、函数式编程等所有高级功能的基础。

---

### 4. Higher-Order Functions (高阶函数)

#### 核心概念
一个**高阶函数 (HOF)** 是一个符合以下**至少一个**条件的函数：
1.  接受一个或多个函数作为参数。
2.  返回另一个函数。

#### 示例
*   **接受函数为参数:** 数组的 `map`, `filter`, `reduce` 方法都是著名的高阶函数。
    ```javascript
    const numbers = [1, 2, 3];
    const double = n => n * 2;
    const doubledNumbers = numbers.map(double); // `map` 是 HOF, `double` 是回调
    console.log(doubledNumbers); // [2, 4, 6]
    ```
*   **返回函数:** 我们上面 `createCounter` 的例子就是返回函数的高阶函数。

#### 应用
HOF 是抽象和代码复用的强大工具，它让你能编写出更具声明性、更简洁的代码。

---

### 5. Arrow Functions (箭头函数)

#### 核心概念
ES6 引入的一种更简洁的函数表达式语法，并且它有一个关键特性：**不绑定自己的 `this`**。

#### 语法与示例
```javascript
// 传统函数表达式
const add = function(a, b) {
  return a + b;
};

// 箭头函数
const addArrow = (a, b) => a + b; // 隐式返回

// 单个参数可以省略括号
const square = x => x * x;

// 多行函数体需要花括号和显式 return
const sum = (a, b) => {
  const result = a + b;
  return result;
};
```

#### 要点与注意事项
1.  **词法 `this`:** 箭头函数没有自己的 `this`。它会捕获其**定义时所在上下文**的 `this` 值。这解决了传统函数中 `this` 指向混乱的经典问题。
    ```javascript
    function Timer() {
      this.seconds = 0;
      setInterval(() => {
        // 这里的 `this` 指向 Timer 实例, 而不是 window 或 undefined
        this.seconds++;
        console.log(this.seconds);
      }, 1000);
    }
    // const timer = new Timer();
    ```
2.  **没有 `arguments` 对象:** 箭头函数内部没有 `arguments` 对象。应使用**剩余参数 (`...args`)** 语法代替。
3.  **不能用作构造函数:** 不能使用 `new` 关键字调用箭头函数，它没有 `prototype` 属性。
4.  **不绑定 `super` 或 `new.target`**。

---

### 6. `arguments` Object vs. Rest Parameters

#### `arguments` 对象 (遗留特性)
*   **核心概念:** 一个在**普通函数**内部可用的**类数组对象**，包含了传递给该函数的所有参数。
*   **示例:**
    ```javascript
    function sumAll() {
      let total = 0;
      for (let i = 0; i < arguments.length; i++) {
        total += arguments[i];
      }
      return total;
    }
    sumAll(1, 2, 3); // 6
    ```
*   **缺点:**
    *   不是真正的数组，不能直接使用 `map`, `filter` 等方法（需要 `Array.from(arguments)` 转换）。
    *   在箭头函数中不可用。
    *   语义不清晰。

#### 剩余参数 `...args` (现代推荐)
*   **核心概念:** 将函数的多余参数收集到一个**真正的数组**中。
*   **示例:**
    ```javascript
    function sumAllModern(...numbers) { // `numbers` 是一个真数组
      return numbers.reduce((sum, current) => sum + current, 0);
    }
    sumAllModern(1, 2, 3); // 6
    ```
*   **优点:**
    *   是真数组，所有数组方法开箱即用。
    *   语法清晰，代码可读性强。
    *   可以在箭头函数中使用。

**结论：在新代码中，请始终使用剩余参数 (`...args`)，避免使用 `arguments` 对象。**

---

### 其他函数式编程概念

#### 7. IIFE (立即调用函数表达式)
*   **核心概念:** 一个在定义后立即执行的函数表达式。
*   **语法:** `(function() { /* ... */ })();`
*   **历史应用:** 在 ES 6 模块和块级作用域出现之前，IIFE 是创建独立作用域、避免污染全局命名空间的主要手段。
*   **现代应用:** 已经很少需要。其主要功能已被 `let`, `const` 和 ES 模块完美替代。

#### 8. Pure Functions (纯函数)
*   **核心概念:** 满足两个条件的函数：
    1.  **确定性:** 相同的输入，永远产生相同的输出。
    2.  **无副作用:** 不会修改任何外部状态（如全局变量、传入的参数对象），也没有可观察的外部交互（如 I/O 操作、`console.log`）。
*   **示例:**
    ```javascript
    // 纯函数
    const add = (a, b) => a + b;

    // 不纯的函数 (有副作用)
    let total = 0;
    function addToTotal(n) {
      total += n; // 修改了外部变量 total
      return total;
    }
    ```
*   **应用:** 函数式编程的核心。纯函数代码可预测、易于测试和推理，是 Redux reducers、React 组件渲染等模式的基石。

#### 9. Currying (柯里化)
*   **核心概念:** 将一个接受多个参数的函数，转换成一系列只接受一个参数的函数的过程。
*   **示例:**
    ```javascript
    // 普通函数
    const multiply = (a, b, c) => a * b * c;

    // 柯里化版本
    const curriedMultiply = a => b => c => a * b * c;
    
    curriedMultiply(2)(3)(4); // 24

    // 应用: 创建专用函数
    const double = curriedMultiply(2);
    const triple = curriedMultiply(3);
    console.log(double(5)(6)); // 60
    ```
*   **应用:** 创建可复用的、专业化的函数，便于函数组合。

#### 10. Recursion (递归)
*   **核心概念:** 一个函数直接或间接地调用自身，直到满足一个**基线条件 (base case)** 才停止。
*   **示例:** 计算阶乘
    ```javascript
    function factorial(n) {
      // 基线条件: 停止递归
      if (n === 0 || n === 1) {
        return 1;
      }
      // 递归步骤: 调用自身
      return n * factorial(n - 1);
    }
    factorial(5); // 120
    ```
*   **应用:** 处理树状结构（如 DOM 遍历）、文件系统、某些排序算法等。
*   **注意:** 必须有明确的基线条件，否则会导致无限递归和“栈溢出 (stack overflow)”错误。在处理大数据集时，递归可能比循环效率低，因为它会占用更多的调用栈空间。