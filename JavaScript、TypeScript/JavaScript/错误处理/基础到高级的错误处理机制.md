错误处理是构建健壮、可靠的 JavaScript 应用程序的绝对核心。如果处理不当，一个微小的错误就可能导致整个应用崩溃。

---

### 1. `try`, `catch`, `finally` - 错误处理的基石

#### 核心概念
这是一个同步代码块的错误处理结构，它允许你“尝试”执行可能出错的代码，并在错误发生时“捕获”它进行处理，同时还能执行一些“最终”的清理工作。

*   **`try { ... }`**: 包裹你**预测可能会抛出错误**的代码块。这是“危险区”。
*   **`catch (error) { ... }`**: 如果 `try` 块中的任何代码抛出了错误，执行将立即跳转到 `catch` 块。`error` 参数是一个**错误对象**，包含了错误的详细信息。这是“安全网”。
*   **`finally { ... }`**: 无论 `try` 块是成功执行完毕还是中途抛出错误被 `catch` 捕获，`finally` 块中的代码**永远都会执行**。这是“清理工”。

#### 语法与示例
一个经典的例子是解析可能格式不正确的 JSON 字符串。
```javascript
function parseJSON(jsonString) {
  try {
    console.log("Attempting to parse JSON...");
    const data = JSON.parse(jsonString); // 这行代码可能会抛出错误
    console.log("Parsing successful:", data);
    return data;
  } catch (error) {
    // 如果 JSON.parse 失败，代码会跳到这里
    console.error("Caught an error!");
    console.error("Error Name:", error.name);
    console.error("Error Message:", error.message);
    // 可以在这里返回一个默认值或进行其他恢复操作
    return null;
  } finally {
    // 无论成功还是失败，这里都会执行
    console.log("Parsing operation finished.");
  }
}

console.log("--- Scenario 1: Valid JSON ---");
parseJSON('{"name": "Alice"}');
// 输出:
// Attempting to parse JSON...
// Parsing successful: { name: 'Alice' }
// Parsing operation finished.

console.log("\n--- Scenario 2: Invalid JSON ---");
parseJSON('{"name": "Alice"'); // 缺少右花括号
// 输出:
// Attempting to parse JSON...
// Caught an error!
// Error Name: SyntaxError
// Error Message: Unexpected end of JSON input (或类似信息)
// Parsing operation finished.
```

---

### 2. `throw` - 手动抛出错误

#### 核心概念
`throw` 语句允许你主动地、在代码的任何地方**创建一个错误**并将其抛出。当 JavaScript 引擎遇到 `throw` 时，会立即停止当前代码的执行，并开始在调用栈中向上寻找一个能够处理该错误的 `catch` 块。

**最佳实践：** 你可以 `throw` 任何东西（比如一个字符串或数字），但**永远应该抛出一个 `Error` 对象的实例** (`throw new Error(...)`)。因为 `Error` 对象包含了如堆栈跟踪等重要的调试信息。

#### 语法与示例
```javascript
function validateAge(age) {
  if (typeof age !== 'number') {
    throw new TypeError('Age must be a number.');
  }
  if (age < 0) {
    throw new RangeError('Age cannot be negative.');
  }
  console.log('Age is valid.');
}

try {
  validateAge(-5);
} catch (error) {
  console.error(`Validation failed: ${error.message}`); // Validation failed: Age cannot be negative.
}
```

---

### 3. `Error` Object (错误对象) 与 Stack Trace (堆栈跟踪)

#### 核心概念
当错误发生时，`catch` 块接收到的那个 `error` 参数，就是一个 `Error` 对象的实例。它包含了关于错误的关键信息。

*   **标准属性:**
    *   `name`: 错误类型（如 `SyntaxError`, `TypeError`, `ReferenceError`）。
    *   `message`: 一个人类可读的、描述错误的字符串。这是你在 `new Error('your message')` 中传递的。
*   **非标准但极其有用的属性:**
    *   `stack`: **堆栈跟踪**。这是一个字符串，详细描述了错误发生时函数的调用路径，从错误点开始，一直回溯到顶层调用。**这是调试时最有价值的信息！**

#### 示例：解读 Stack Trace
```javascript
function functionA() {
  functionB();
}

function functionB() {
  // 故意创建一个错误
  const user = null;
  console.log(user.name); // TypeError: Cannot read properties of null
}

try {
  functionA();
} catch (error) {
  console.error(error.stack);
}
```
输出的 `error.stack` 看起来会像这样 (具体格式因环境而异):
```
TypeError: Cannot read properties of null (reading 'name')
    at functionB (c:\path\to\your\file.js:12:21)  <-- 错误发生的精确位置
    at functionA (c:\path\to\your\file.js:7:3)    <-- 调用 functionB 的地方
    at Object.<anonymous> (c:\path\to\your\file.js:16:3) <-- 顶层调用
```
**如何阅读：** 从上到下看。第一行是错误类型和信息。下面每一行 `at ...` 都代表调用栈的一帧，告诉你哪个函数在哪一行调用了下一个函数，直到错误的源头。

---

### 4. Custom Errors (自定义错误) - 让错误更具描述性

#### 核心概念
虽然 JavaScript 内置了多种错误类型（`TypeError`, `RangeError` 等），但在复杂的应用中，创建我们自己的错误类型会非常有帮助。这使得我们可以更精确地捕获和处理特定类型的应用级错误。

**现代方式 (ES6 Class):** 通过继承内置的 `Error` 类来创建自定义错误。

#### 语法与示例
假设我们正在开发一个 API 客户端，需要一个特定的 `APIError`。
```javascript
// 定义自定义错误类
class APIError extends Error {
  constructor(message, statusCode) {
    // 1. 调用父类的构造函数
    super(message);
    
    // 2. 设置错误名称为类名
    this.name = 'APIError';
    
    // 3. 添加自定义属性
    this.statusCode = statusCode;
  }
}

async function fetchUserData() {
  const response = await fetch('https://api.example.com/user/123');
  
  if (!response.ok) {
    // 抛出自定义错误，携带更多上下文信息
    throw new APIError(`Failed to fetch data. Server responded with ${response.status}`, response.status);
  }
  
  return response.json();
}

// 使用
(async () => {
  try {
    const userData = await fetchUserData();
    console.log(userData);
  } catch (error) {
    // 我们可以精确地检查错误的类型
    if (error instanceof APIError) {
      console.error(`API Error (Status ${error.statusCode}): ${error.message}`);
      // 可以根据 statusCode 做不同处理，比如 401 就跳转登录
    } else {
      // 处理其他类型的错误 (如网络中断)
      console.error(`An unexpected error occurred: ${error.message}`);
    }
  }
})();
```

---

### 5. 异步代码中的错误处理

这是新手常犯错的地方。**`try...catch` 只能捕获同步代码和 `await` 后面 Promise 的错误。**

#### 错误的方式 (Callbacks)
```javascript
try {
  setTimeout(() => {
    throw new Error("This error will NOT be caught!");
  }, 100);
} catch (e) {
  // 这里的 catch 永远不会执行
  console.error("Caught it!");
}
// 错误会作为一个未捕获的异常直接抛到全局。
```
**原因：** `try...catch` 块执行完毕时，`setTimeout` 里的回调函数还远未执行。当回调执行并抛出错误时，它已经在一个全新的调用栈中，脱离了原始 `try...catch` 的控制范围。

#### 正确的方式 (Promises & `async/await`)

*   **使用 Promise 的 `.catch()` 方法:**
    ```javascript
    fetch('https://invalid-url')
      .then(response => response.json())
      .catch(error => {
        // .catch() 会捕获链中任何一个 Promise 的 rejection
        console.error("Fetch failed:", error);
      });
    ```

*   **使用 `async/await` (最佳实践):** 这是最直观的方式，让异步错误处理看起来和同步一样。
    ```javascript
    async function fetchDataAsync() {
      try {
        const response = await fetch('https://invalid-url');
        const data = await response.json();
        console.log(data);
      } catch (error) {
        // await 后面 Promise 的 rejection 会被 try...catch 捕获
        console.error("Async fetch failed:", error);
      }
    }
    fetchDataAsync();
    ```

---

### 总结与要点

1.  **同步用 `try/catch/finally`:** 它是处理同步代码错误的基础。
2.  **异步用 `async/await` + `try/catch`:** 这是现代 JavaScript 中处理异步错误的最清晰、最推荐的方式。对于纯 Promise 链，使用 `.catch()` 也很有效。
3.  **总是 `throw new Error()`:** 抛出 `Error` 实例，而不是裸字符串或数字，以保留宝贵的堆栈跟踪信息。
4.  **创建自定义错误:** 对于特定领域的应用逻辑，通过 `class MyError extends Error {}` 创建自定义错误，可以让你的错误处理逻辑更清晰、更健壮。
5.  **不要“吞掉”错误:** 避免空的 `catch {}` 块。如果你捕获了一个错误，要么处理它（例如，向用户显示消息，重试操作），要么记录它，要么重新抛出一个更具体的错误。静默地忽略错误是滋生 bug 的温床。
6.  **利用 `finally`:** `finally` 非常适合执行资源清理工作，比如关闭文件句柄、关闭数据库连接或隐藏 loading 指示器，因为无论成功失败它都会运行。