TypeScript 类型体系和转换机制的知识图谱。

分两大部分：

1.  **TypeScript 类型全景图**：从基础到高级，覆盖所有重要的类型。
2.  **类型转换的艺术**：在不同类型之间进行安全、有效的转换。

---

### Part 1: TypeScript 类型全景图

我们可以将 TypeScript 的类型系统想象成一个工具箱，里面有各种各样的工具（类型）来精确描述你的数据。

#### 类别一：基础与原始类型 (The Primitives)

这些是构成所有数据的基础，与 JavaScript 的原始类型一一对应。

*   **`string`**: 文本类型。`let name: string = "TypeScript";`
*   **`number`**: 数字类型，包括整数和浮点数。`let version: number = 5.3;`
*   **`boolean`**: 布尔类型。`let isAwesome: boolean = true;`
*   **`null`**: 表示“刻意设置的空值”。`let data: null = null;`
*   **`undefined`**: 表示“未定义”或“未初始化”的值。`let notAssigned: undefined = undefined;`
*   **`symbol`**: 表示全局唯一的引用。`let id: symbol = Symbol("id");`
*   **`bigint`**: 用于表示超大整数。`let largeNumber: bigint = 9007199254740991n;`

> **注意**：在 `tsconfig.json` 中开启 `strictNullChecks` (强烈推荐) 后，`null` 和 `undefined` 是独立的类型，不能随意赋值给 `string` 等其他类型，这能避免大量潜在的 bug。

#### 类别二：对象与结构类型 (The Structures)

这些类型用于描述非原始值的数据结构。

*   **`object`**: 泛指所有非原始类型。在实践中，我们很少直接使用 `object`，而是使用更具体的类型。
*   **`Array`**: 数组类型。有两种等价的写法：
    *   `let list: number[] = [1, 2, 3];` (推荐)
    *   `let list: Array<number> = [1, 2, 3];` (泛型写法，在 JSX/TSX 中无歧义)
*   **`Tuple` (元组)**: 固定长度和固定类型的数组。
    ```typescript
    let user: [string, number] = ["Alice", 25];
    // user[0] 的类型是 string，user[1] 的类型是 number
    // user[2] = 'extra'; // ❌ 错误，元组长度固定
    ```
*   **`enum` (枚举)**: 为一组数值或字符串赋予友好的名字。
    ```typescript
    enum Direction { Up, Down, Left, Right }
    let go: Direction = Direction.Up; // 值为 0
    
    // 字符串枚举更推荐，因为它有更明确的运行时值
    enum LogLevel { Info = 'INFO', Warn = 'WARN', Error = 'ERROR' }
    let level: LogLevel = LogLevel.Info; // 值为 'INFO'
    ```
*   **`Function`**: 函数类型。我们通常会更精确地描述其参数和返回值。
    ```typescript
    type AddFunc = (a: number, b: number) => number;
    const add: AddFunc = (x, y) => x + y;
    ```

#### 类别三：特殊与高级类型 (The Power Tools)

这些是 TypeScript 类型系统的精髓，提供了强大的表达能力和安全性。

*   **`any`**: **类型系统的“逃生舱”**。它告诉 TypeScript：“别检查我，我知道我在做什么”。`any` 类型的值可以被赋予任何类型，也可以赋值给任何类型，可以调用任何方法，访问任何属性，完全放弃了类型检查。**应极力避免使用**。

*   **`unknown`**: **安全的 `any`**。它表示一个“未知类型”的值。你可以将任何值赋给 `unknown`，但你不能对 `unknown` 类型的值做任何操作，除非你先通过类型检查（类型收窄）来确定它的具体类型。

    ```typescript
    let value: unknown;
    
    value = "hello";
    // value.toUpperCase(); // ❌ 错误: 'value' is of type 'unknown'.
    
    if (typeof value === 'string') {
      value.toUpperCase(); // ✅ 正确，在 if 块内，TS 知道 value 是 string
    }
    ```

*   **`void`**: 表示函数**没有返回值**。一个返回 `void` 的函数，其返回值实际上是 `undefined`。
    ```typescript
    function logMessage(message: string): void {
      console.log(message);
      // return "something"; // ❌ 错误
    }
    ```

*   **`never`**: 表示**永不返回**的值的类型。一个函数如果抛出异常或进入无限循环，其返回值类型就是 `never`。它常用于类型编程，表示一个不可能出现的状态。
    ```typescript
    function throwError(message: string): never {
      throw new Error(message);
    }
    
    function infiniteLoop(): never {
      while (true) {}
    }
    ```

*   **字面量类型 (Literal Types)**: 精确到值的类型，是 `string`, `number`, `boolean` 的子类型。
    ```typescript
    let specificString: "hello" = "hello";
    let status: 200 | 404 | 500 = 200;
    let isAdmin: true = true;
    ```

*   **联合类型 (Union Types `|`)**: 表示一个值可以是多种类型之一。
    ```typescript
    type ID = string | number;
    let userId: ID = "user-123";
    userId = 456; // ✅ 正确
    ```

*   **交叉类型 (Intersection Types `&`)**: 将多个类型合并为一个类型，新类型拥有所有成员。
    ```typescript
    interface CanLog { log(): void; }
    interface CanFetch { fetch(): Promise<any>; }

    type DataHandler = CanLog & CanFetch; // 必须同时拥有 log 和 fetch 方法
    ```

#### 类别四：泛型 (Generics) - 类型变量

泛型是创建可重用组件的工具，它允许你在定义函数、类或接口时不预先指定具体的类型，而在使用时再指定。

```typescript
// 一个泛型函数，输入什么类型，就返回什么类型的数组
function createArray<T>(item: T, count: number): T[] {
  const result: T[] = [];
  for (let i = 0; i < count; i++) {
    result.push(item);
  }
  return result;
}

const stringArray = createArray<string>("hello", 3); // ["hello", "hello", "hello"]
const numberArray = createArray(123, 2); // TS 会自动推断 T 为 number
```

---

### Part 2: 类型转换的艺术

在 TypeScript 中，"转换" 分为两种：**编译时**的类型断言和**运行时**的类型守卫。这是一个至关重要的区别。

#### 1. 类型断言 (Type Assertion) - 告诉编译器你更懂

类型断言就像你对 TypeScript 说：“相信我，我知道这个变量的类型是什么”。它**不会改变运行时的代码**，只是一个编译时的指令。

**语法**：

*   **`as` 语法 (推荐)**: `let someValue: unknown = "this is a string"; let strLength: number = (someValue as string).length;`
*   **尖括号语法**: `let strLength: number = (<string>someValue).length;` (在 JSX/TSX 中会引起歧义，不推荐)

**核心要点**：
*   **这是一种欺骗**：如果你的断言是错误的，TypeScript 不会报错，但代码在运行时可能会崩溃。
*   **何时使用**：当你从一个更宽泛的类型（如 `any`, `unknown`，或 DOM API 返回的 `HTMLElement`）转换到一个你确定无误的更具体的类型时。

```typescript
// 错误使用的例子
const myNumber: unknown = 123;
// 你错误地断言它是一个 string
const aString = myNumber as string; 
console.log(aString.toUpperCase()); // 编译通过，但运行时会抛出 "aString.toUpperCase is not a function" 错误
```

#### 2. 类型守卫 (Type Guards) - 安全的类型收窄

类型守卫是 TypeScript 的核心特性，它允许你在代码的特定块中，通过运行时的检查来**收窄**变量的类型。这是最安全、最推荐的类型转换方式。

*   **`typeof` 守卫**:
    ```typescript
    function printId(id: string | number) {
      if (typeof id === 'string') {
        // 在这个块中，id 的类型被收窄为 string
        console.log(id.toUpperCase());
      } else {
        // 在这个块中，id 的类型被收窄为 number
        console.log(id.toFixed(2));
      }
    }
    ```

*   **`instanceof` 守卫**: 用于检查一个实例是否属于某个类。
    ```typescript
    class User { name = "Alice"; }
    class Admin { role = "admin"; }

    function logPerson(person: User | Admin) {
      if (person instanceof User) {
        console.log(person.name);
      } else {
        console.log(person.role);
      }
    }
    ```
*   **`in` 守卫**: 用于检查一个对象上是否存在某个属性。
    ```typescript
    interface Fish { swim(): void; }
    interface Bird { fly(): void; }

    function move(animal: Fish | Bird) {
      if ('swim' in animal) {
        // animal 被收窄为 Fish
        animal.swim();
      } else {
        // animal 被收窄为 Bird
        animal.fly();
      }
    }
    ```

*   **自定义类型守卫 (is)**: 创建一个返回 `parameterName is Type` 的函数。
    ```typescript
    interface Cat { meow(): void; }

    // 这就是一个自定义类型守卫
    function isCat(pet: any): pet is Cat {
      return typeof pet.meow === 'function';
    }

    let pet: any = { meow: () => console.log('Meow!') };
    if (isCat(pet)) {
      pet.meow(); // ✅ 正确，pet 的类型被收窄为 Cat
    }
    ```

#### 3. `satisfies` 操作符 (TS 4.9+) - 验证而不改变类型

`satisfies` 是一个强大的新工具，它允许你**验证**一个值的结构符合某个类型，但**保留**这个值本身最精确的推断类型。

```typescript
type Config = {
  theme: "light" | "dark";
  version: number;
}

// 使用 satisfies，我们既保证了 config 符合 Config 的结构
// 又保留了 theme: "dark" 这个更具体的字面量类型
const config = {
  theme: "dark",
  version: 1,
} satisfies Config;

// 所以这里 TS 知道 config.theme 就是 "dark"，而不是 "light" | "dark"
if (config.theme === "dark") { // 这个判断在 TS 眼里是有意义的
    // ...
}
```

---

### 扩展与应用：一个真实场景

假设我们从后端 API 获取数据：

```typescript
// 1. 定义我们期望的数据类型
interface User {
  id: number;
  name: string;
  email: string;
}

// 2. 发起请求，响应体是未知的
async function fetchUser(id: number): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  const data: unknown = await response.json(); // 安全地将 API 响应标记为 unknown

  // 3. 创建一个类型守卫来验证数据结构
  function isUser(value: unknown): value is User {
    if (typeof value !== 'object' || value === null) return false;
    const user = value as Record<string, unknown>; // 断言为通用对象以便检查属性
    return (
      typeof user.id === 'number' &&
      typeof user.name === 'string' &&
      typeof user.email === 'string'
    );
  }

  // 4. 使用类型守卫进行安全的类型转换
  if (isUser(data)) {
    return data; // 在这里，data 的类型是 User，可以安全返回
  } else {
    // 如果数据结构不匹配，抛出错误，保证函数签名的承诺
    throw new Error("Invalid user data received from API.");
  }
}
```

### 核心要点与注意事项

1.  **编译时 vs 运行时**: TypeScript 的类型系统主要工作在**编译时**。类型断言 (`as`) 不会改变运行时行为。要处理运行时可能变化的类型，必须使用**类型守卫**。
2.  **`unknown` 是首选**: 当处理外部数据（API 响应、用户输入、`localStorage`）时，**总是优先使用 `unknown`**，然后通过类型守卫来验证和收窄，而不是直接使用 `any` 或 `as`。
3.  **避免过度断言**: 滥用 `as` 是代码坏味道的信号。如果你发现自己频繁使用 `as`，停下来想一想，是否能用类型守卫或更好的类型定义来代替。
4.  **一致性是关键**: 在团队中，统一对 `any` 的使用策略、类型定义的风格 (`interface` vs `type`) 以及类型转换的方法，能极大地提升代码质量和可维护性。