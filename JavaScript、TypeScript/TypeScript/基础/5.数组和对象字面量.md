TypeScript 中的**数组 (Arrays)** 和**对象字面量 (Object Literals)**。这两种是 JavaScript 中最常用的数据结构，TypeScript 在它们的基础上添加了强大的类型检查。

**核心概念：**

*   **字面量 (Literal):** 就是在代码中直接写出来的值，比如 `[1, 2]` 是一个数组字面量，`{ name: "Alice" }` 是一个对象字面量。
*   **TypeScript 的增强：** TS 主要通过**类型注解**或**类型推断**来明确数组中可以包含什么类型的元素，以及对象应该具有哪些属性及其类型。

---

### **1. 数组字面量 (Array Literals)**

数组是**有序**的值的集合。

*   **基本语法与类型推断:**
    ```typescript
    // TS 会推断 'numbers' 的类型为 number[] (数字数组)
    let numbers = [1, 2, 3];

    // TS 会推断 'names' 的类型为 string[] (字符串数组)
    let names = ["Alice", "Bob", "Charlie"];

    // TS 会推断 'mixed' 的类型为 (string | number | boolean)[] (包含字符串、数字或布尔值的数组)
    let mixed = [1, "hello", true];
    ```
    TypeScript 会查看数组字面量中的所有元素，并推断出一个最合适的类型（如果是单一类型）或联合类型（如果是多种类型）。

*   **显式类型注解:**
    你可以（也经常推荐）显式地指定数组应该包含的元素类型，这有两种等价的语法：
    1.  `Type[]` (推荐，更简洁)
    2.  `Array<Type>` (泛型语法)

    ```typescript
    let scores: number[];       // 声明一个数字数组
    scores = [100, 95, 88];
    // scores.push("A+");     // 错误！不能将 string 类型添加到 number[]

    let colors: Array<string>;  // 声明一个字符串数组 (效果同 string[])
    colors = ["red", "green", "blue"];
    // colors[0] = 123;       // 错误！不能将 number 类型赋值给 string 元素

    // 如果数组可以包含多种类型，使用联合类型
    let ids: (string | number)[];
    ids = [101, "user-abc", 205];
    ```
    显式注解的好处是意图更清晰，并且可以在声明空数组时指定类型：
    ```typescript
    let results: number[] = []; // 明确这是一个数字数组，即使它现在是空的
    results.push(10);
    // results.push("ok"); // 错误！
    ```

*   **元组类型 (Tuple Types):**
    元组是一种**特殊的数组**，它**固定长度**并且**每个位置上的元素类型也是固定的**。它使用数组字面量的语法进行赋值。

    ```typescript
    // 定义一个元组类型：第一个元素是 string，第二个是 number
    let userProfile: [string, number];

    userProfile = ["Alice", 30]; // OK
    // userProfile = [30, "Alice"]; // 错误！顺序不匹配
    // userProfile = ["Bob"];        // 错误！长度不匹配，缺少第二个元素
    // userProfile = ["Charlie", 40, true]; // 错误！长度不匹配，多了一个元素

    console.log(userProfile[0].toUpperCase()); // OK, TS 知道第一个是 string
    // console.log(userProfile[1].toUpperCase()); // 错误！TS 知道第二个是 number，没有 toUpperCase 方法
    ```
    元组非常适合用来表示那些结构固定、元素数量少且类型明确的集合，比如函数的多个返回值、坐标点等。

*   **只读数组 (Readonly Arrays):**
    你可以创建不允许修改的数组。
    ```typescript
    const readOnlyNumbers: readonly number[] = [1, 2, 3];
    // readOnlyNumbers.push(4);    // 错误！push 不存在于 readonly number[] 类型上
    // readOnlyNumbers[0] = 0;     // 错误！索引签名仅允许读取

    // 另一种语法：ReadonlyArray<Type>
    const readOnlyNames: ReadonlyArray<string> = ["Dave", "Eve"];
    ```
    这在函数参数或常量定义中很有用，可以防止意外修改。

---

### **2. 对象字面量 (Object Literals)**

对象是**无序**的键值对（key-value pairs）集合。

*   **基本语法与类型推断:**
    ```typescript
    // TS 会推断 'person' 的类型为 { name: string; age: number }
    const person = {
      name: "Alice",
      age: 30
    };

    console.log(person.name); // OK
    // person.age = "thirty"; // 错误！不能将 string 赋值给 number 类型的 age
    // person.email = "...";  // 错误！类型 { name: string; age: number } 上不存在属性 'email'
    ```
    TypeScript 会根据对象字面量中的属性和它们的初始值来推断对象的“形状”（Shape）。

*   **显式类型注解 (接口 Interface / 类型别名 Type Alias):**
    对于对象，我们通常不直接在变量旁边写冗长的内联类型，而是使用 `interface` 或 `type` 来定义可复用的形状。

    ```typescript
    let person: { name: string; age: number; id: number } = {
      name: "Alice",
      age: 25,
      id: 1,
    };
    
    // 使用 interface
    interface User {
      readonly id: number; // 只读属性
      name: string;
      email?: string; // 可选属性 (用 ? 表示)
      isActive: boolean;
    }

    // 使用 type alias
    type Product = {
      sku: string;
      price: number;
      description?: string; // 可选属性
    };

    let user1: User = {
      id: 1,
      name: "Bob",
      isActive: true
      // email 可以省略
    };

    // user1.id = 2; // 错误！id 是只读的

    let product1: Product = {
      sku: "XYZ-123",
      price: 99.99,
      description: "A great product"
    };

    let product2: Product = {
      sku: "ABC-456",
      price: 49.50
      // description 可以省略
    };
    ```
    *   **`readonly` 修饰符:** 属性只能在对象创建时赋值，之后不能修改。
    *   **`?` 可选修饰符:** 属性可以存在，也可以不存在。如果访问可选属性，它的类型会被看作是 `Type | undefined`。

*   **索引签名 (Index Signatures):**
    当你不知道对象会有哪些属性名，但知道这些属性名和值的类型时，可以使用索引签名。

    ```typescript
    interface StringMap {
      [key: string]: string; // 键是 string 类型，值也是 string 类型
    }

    let dictionary: StringMap = {
      "hello": "world",
      "typescript": "is awesome"
    };
    dictionary["newKey"] = "newValue"; // OK
    // dictionary["count"] = 123; // 错误！值必须是 string 类型

    interface NumberMap {
      [key: number]: boolean; // 键是 number 类型，值是 boolean 类型
    }
    let flags: NumberMap = {
      0: true,
      1: false
    };
    ```
    **注意:** 索引签名的键类型只能是 `string` 或 `number` (或 `symbol`，以及由它们组成的模板字面量类型)。如果同时定义了具体的属性和索引签名，具体属性的类型必须兼容索引签名的值类型。

*   **`as const` (Const Assertions):**
    这是一个非常有用的技巧，可以告诉 TypeScript 将字面量推断为**最窄**、**最具体**的类型，并且所有属性都变成 `readonly`。

    ```typescript
    // 没有 as const
    let config1 = { timeout: 5000, method: "GET" };
    // 推断类型: { timeout: number; method: string; }

    // 使用 as const
    let config2 = { timeout: 5000, method: "GET" } as const;
    // 推断类型: { readonly timeout: 5000; readonly method: "GET"; }
    // 注意：timeout 的类型是字面量类型 5000，而不是 number
    // method 的类型是字面量类型 "GET"，而不是 string
    // 整个对象及其属性都是 readonly 的

    // config2.timeout = 3000; // 错误！readonly
    // config2.method = "POST"; // 错误！readonly 且类型不匹配 ("POST" !== "GET")

    // 对数组也有效
    const colors = ["red", "green", "blue"] as const;
    // 推断类型: readonly ["red", "green", "blue"] (只读元组)
    // colors.push("yellow"); // 错误！
    ```
    `as const` 对于定义不可变的配置、常量集合、或者需要精确字面量类型（如用于联合类型判断）的场景非常有用。

---

**总结:**

*   TypeScript 为 JavaScript 的数组和对象字面量提供了**类型约束**。
*   对于**数组**：
    *   使用 `Type[]` 或 `Array<Type>` 定义元素类型。
    *   **元组 (`[Type1, Type2]`)** 用于固定长度和类型的数组。
    *   `readonly Type[]` 或 `ReadonlyArray<Type>` 创建只读数组。
*   对于**对象**：
    *   使用 `interface` 或 `type` 定义形状（属性及其类型）。
    *   `?` 表示**可选属性**。
    *   `readonly` 表示**只读属性**。
    *   **索引签名 (`[key: string]: ValueType`)** 用于属性名不确定的对象。
*   **`as const`** 用于将字面量推断为最窄的只读类型，非常实用。

理解如何在 TypeScript 中正确地为数组和对象字面量定义和使用类型，是编写健壮、可维护代码的基础。