TypeScript 中的 **装饰器 (Decorators)**。

装饰器是一种特殊类型的声明，它可以附加到类声明、方法、访问器 (getter/setter)、属性或参数上。装饰器使用 `@expression` 的形式，`expression` 求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入。

**通俗解释：**

想象一下，装饰器就像是给你的代码元素（类、方法等）贴上一个“标签”或“插件”。这个标签/插件可以：

1.  **观察** 这个元素（比如记录它被调用了）。
2.  **修改** 这个元素的行为（比如给方法添加额外的逻辑，或者改变属性的默认值）。
3.  **替换** 这个元素（比如用一个全新的实现替换掉原来的方法）。
4.  **添加元数据 (Metadata)**：记录一些关于这个元素的信息，供其他工具或代码在运行时使用。

**重要前提：启用装饰器**

由于装饰器是一项实验性特性（在 ECMAScript 标准中仍处于提案阶段，但 TypeScript 较早地实现了基于早期提案的版本），你需要在 `tsconfig.json` 文件中启用它：

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true // 通常与 Reflect.metadata 一起使用，可选但推荐
  }
}
```

*   `experimentalDecorators`: 启用装饰器语法。
*   `emitDecoratorMetadata`: 当与 `reflect-metadata` 库配合使用时，它会在编译时为装饰了的声明生成一些设计阶段的类型信息 (元数据)。这对于依赖注入、ORM 等场景非常有用。

---

### 装饰器的类型与应用

TypeScript 支持以下几种类型的装饰器：

1.  **类装饰器 (Class Decorators)**
    *   **应用对象**：类声明之前。
    *   **作用**：用于观察、修改或替换类定义。
    *   **参数**：接收一个参数，即被装饰的类的构造函数。
    *   **返回值**：如果类装饰器返回一个值，它会使用提供的构造函数来替换原始类的声明。
    *   **示例**：
        ```typescript
        // 简单的类装饰器 - 记录类被定义
        function LogClass(target: Function) {
          console.log(`Class defined: ${target.name}`);
        }

        // 类装饰器 - 修改类（添加属性）
        function AddVersion<T extends { new (...args: any[]): {} }>(constructor: T) {
          return class extends constructor {
            version = "1.0.0";
          };
        }

        @LogClass
        @AddVersion
        class MyService {
          name: string;
          constructor(name: string) {
            this.name = name;
          }
        }

        const serviceInstance = new MyService("DataService");
        console.log((serviceInstance as any).version); // "1.0.0"
        ```

2.  **方法装饰器 (Method Decorators)**
    *   **应用对象**：方法声明之前。
    *   **作用**：用于观察、修改或替换方法定义。
    *   **参数**：接收三个参数：
        1.  `target`:
            *   对于静态成员，它是类的构造函数。
            *   对于实例成员，它是类的原型对象 (`prototype`)。
        2.  `propertyKey`: 成员的名称 (字符串或 Symbol)。
        3.  `descriptor`: 成员的属性描述符 (`PropertyDescriptor`)。
    *   **返回值**：如果方法装饰器返回一个值，它会被用作方法的属性描述符。
    *   **示例**：
        ```typescript
        function LogMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
          console.log(`Method called: ${propertyKey}`);
          const originalMethod = descriptor.value; // 保存原始方法

          // 修改方法行为：在原始方法前后添加日志
          descriptor.value = function (...args: any[]) {
            console.log(`Calling ${propertyKey} with args: ${JSON.stringify(args)}`);
            const result = originalMethod.apply(this, args);
            console.log(`${propertyKey} returned: ${JSON.stringify(result)}`);
            return result;
          };
          // return descriptor; // 可以不返回，直接修改 descriptor
        }

        class Calculator {
          @LogMethod
          add(a: number, b: number): number {
            return a + b;
          }
        }

        const calc = new Calculator();
        calc.add(5, 3);
        // 输出:
        // Method called: add
        // Calling add with args: [5,3]
        // add returned: 8
        ```

3.  **访问器装饰器 (Accessor Decorators)**
    *   **应用对象**：访问器 (getter/setter) 声明之前。
    *   **作用**：用于观察、修改或替换访问器的定义。
    *   **参数**：与方法装饰器相同 (`target`, `propertyKey`, `descriptor`)。
    *   **返回值**：如果访问器装饰器返回一个值，它会被用作访问器的属性描述符。
    *   **注意**：TypeScript 不允许同时装饰一个成员的 `get` 和 `set` 访问器。如果都装饰，只有第一个生效。通常只装饰一个即可。
    *   **示例**：
        ```typescript
        function Enumerable(value: boolean) {
          return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
            descriptor.enumerable = value;
          };
        }

        class Point {
          private _x: number;
          private _y: number;

          constructor(x: number, y: number) {
            this._x = x;
            this._y = y;
          }

          @Enumerable(false) // 使 x 访问器不可枚举
          get x() { return this._x; }
          set x(val: number) { this._x = val; }

          get y() { return this._y; }
          set y(val: number) { this._y = val; }
        }

        const p = new Point(1, 2);
        for (const key in p) {
          console.log(key); // 只会打印 'y' (如果 x 可枚举，则会打印 'x' 和 'y')
        }
        ```

4.  **属性装饰器 (Property Decorators)**
    *   **应用对象**：属性声明之前。
    *   **作用**：用于观察属性，通常用来记录元数据，或者在类实例化时修改属性。
    *   **参数**：接收两个参数：
        1.  `target`:
            *   对于静态成员，它是类的构造函数。
            *   对于实例成员，它是类的原型对象 (`prototype`)。
        2.  `propertyKey`: 成员的名称 (字符串或 Symbol)。
    *   **返回值**：属性装饰器的返回值会被忽略。因此，它不能直接修改属性的定义或值（除非通过修改 `target` 或使用 `Object.defineProperty` 在构造函数中进行初始化）。
    *   **示例** (通常与 `Reflect.metadata` 结合使用)：
        ```typescript
        import 'reflect-metadata'; // 需要安装 npm install reflect-metadata

        const formatMetadataKey = Symbol("format");

        function Format(formatString: string) {
          return Reflect.metadata(formatMetadataKey, formatString);
        }

        function getFormat(target: any, propertyKey: string) {
          return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
        }

        class Greeter {
          @Format("Hello, %s")
          greeting: string;

          constructor(message: string) {
            this.greeting = message;
          }

          greet() {
            const formatString = getFormat(this, "greeting");
            return formatString.replace("%s", this.greeting);
          }
        }

        const greeter = new Greeter("World");
        console.log(greeter.greet()); // "Hello, World"
        ```

5.  **参数装饰器 (Parameter Decorators)**
    *   **应用对象**：构造函数参数或方法参数声明之前。
    *   **作用**：用于观察参数，通常用来记录元数据。
    *   **参数**：接收三个参数：
        1.  `target`:
            *   对于静态成员（构造函数参数或静态方法参数），它是类的构造函数。
            *   对于实例成员（实例方法参数），它是类的原型对象 (`prototype`)。
        2.  `propertyKey`: 参数所在的方法名 (字符串或 Symbol)，如果是构造函数参数则为 `undefined`。
        3.  `parameterIndex`: 参数在函数参数列表中的索引 (数字)。
    *   **返回值**：参数装饰器的返回值会被忽略。
    *   **示例** (通常与 `Reflect.metadata` 结合使用，用于依赖注入等)：
        ```typescript
        import 'reflect-metadata';

        const requiredMetadataKey = Symbol("required");

        function Required(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
          const existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey!) || [];
          existingRequiredParameters.push(parameterIndex);
          Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey!);
        }

        function Validate(target: any, propertyName: string | undefined, descriptor: TypedPropertyDescriptor<Function>) {
          const method = descriptor.value!;
          descriptor.value = function (...args: any[]) {
            const requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName!) || [];
            for (const parameterIndex of requiredParameters) {
              if (parameterIndex >= args.length || args[parameterIndex] === undefined || args[parameterIndex] === null) {
                throw new Error(`Missing required argument at index ${parameterIndex} for method ${propertyName || 'constructor'}.`);
              }
            }
            return method.apply(this, args);
          };
        }

        class UserService {
          @Validate
          findUserById(@Required id: number, name?: string) {
            console.log(`Finding user with ID: ${id}` + (name ? ` and name: ${name}` : ''));
            return { id, name: name || "Default Name" };
          }

          constructor(@Required _config: object) {
            console.log("UserService initialized with config.");
          }
        }

        const userService = new UserService({}); // OK
        userService.findUserById(123); // OK
        userService.findUserById(123, "Alice"); // OK
        try {
          userService.findUserById(undefined as any); // Error: Missing required argument...
        } catch (e: any) {
          console.error(e.message);
        }
        // try {
        //   new UserService(undefined as any); // Error
        // } catch (e: any) {
        //   console.error(e.message);
        // }
        ```

---

### 装饰器工厂 (Decorator Factories)

如果你想向装饰器传递参数，你需要使用**装饰器工厂**。它就是一个简单的函数，返回一个装饰器函数。

```typescript
function LogExecutionTime(label: string) { // 这是装饰器工厂
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { // 这是实际的装饰器
    const originalMethod = descriptor.value;
    descriptor.value = async function (...args: any[]) {
      console.time(label);
      const result = await originalMethod.apply(this, args);
      console.timeEnd(label);
      return result;
    };
  };
}

class DataFetcher {
  @LogExecutionTime("Data Fetching")
  async fetchData(): Promise<string> {
    return new Promise(resolve => setTimeout(() => resolve("Data fetched!"), 1000));
  }
}

const fetcher = new DataFetcher();
fetcher.fetchData().then(console.log);
// 输出:
// Data Fetching: 1000.123ms (示例时间)
// Data fetched!
```

---

### 装饰器组合 (Decorator Composition)

多个装饰器可以应用于一个声明：

*   **书写顺序**：从上到下（或从左到右，如果写在一行）。
*   **求值顺序（工厂）**：与书写顺序一致。装饰器工厂会按顺序执行。
*   **执行顺序（装饰器函数）**：与书写顺序相反（由下往上，或由右往左）。后应用的装饰器函数先执行。

```typescript
function First() {
  console.log("First(): factory evaluated");
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log("First(): called");
  };
}

function Second() {
  console.log("Second(): factory evaluated");
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log("Second(): called");
  };
}

class ExampleClass {
  @First()
  @Second()
  method() {}
}

// 输出:
// First(): factory evaluated
// Second(): factory evaluated
// Second(): called  (Second 的装饰器函数先执行)
// First(): called   (First 的装饰器函数后执行)
```

---

### `Reflect.metadata` API

`reflect-metadata` 是一个独立的库，它实现了一个提案中的 API，用于在装饰器中添加和读取元数据。

*   `Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey?)`: 定义元数据。
*   `Reflect.getMetadata(metadataKey, target, propertyKey?)`: 获取元数据。
*   `Reflect.hasMetadata(metadataKey, target, propertyKey?)`: 检查元数据是否存在。
*   还有 `getOwnMetadata`, `deleteMetadata` 等。

当你启用 `emitDecoratorMetadata` 时，TypeScript 会自动为装饰器注入一些类型信息作为元数据，例如：

*   `design:type`: 属性的类型。
*   `design:paramtypes`: 方法参数的类型。
*   `design:returntype`: 方法的返回类型。

这些对于实现依赖注入容器 (如 NestJS, TypeDI) 或 ORM (如 TypeORM) 非常关键。

---

### 装饰器的应用场景

*   **日志记录 (Logging)**：记录方法调用、执行时间、参数等。
*   **访问控制/权限校验 (Authorization)**：检查用户是否有权限执行某个方法。
*   **数据校验 (Validation)**：校验方法参数或属性值是否符合规则。
*   **依赖注入 (Dependency Injection)**：标记构造函数参数或属性，以便 DI 容器注入依赖。
*   **ORM/ODM (Object-Relational/Document Mapper)**：标记类和属性，将其映射到数据库表和列 (如 TypeORM 中的 `@Entity()`, `@Column()`)。
*   **路由定义 (Routing)**：在 Web 框架中定义 API 路由 (如 NestJS 中的 `@Controller()`, `@Get()`)。
*   **序列化/反序列化**：控制对象如何被转换为 JSON 或从 JSON 转换回来。
*   **缓存 (Caching)**：自动缓存方法的结果。

---

### 当前状态与未来 (TC 39 Decorators)

*   **TypeScript 的 `experimentalDecorators`**：基于 ECMAScript 提案的早期版本。它们非常强大，并在许多流行的 TypeScript 框架（如 Angular, NestJS, TypeORM）中广泛使用。
*   **ECMAScript Decorators Proposal (Stage 3)**：ECMAScript 标准的装饰器提案已经发展到了 Stage 3 阶段，这意味着其设计已经相当稳定，并预计会成为 JavaScript 的一部分。**重要的是，这个 Stage 3 提案与 TypeScript 目前实现的 `experimentalDecorators` 在语法和行为上有显著差异。**
    *   例如，Stage 3 装饰器的函数签名、返回值以及它们能做的事情都与 TypeScript 的旧版装饰器有所不同。
    *   TypeScript 团队计划在未来支持这个新的标准装饰器。目前，可以通过 `tsconfig.json` 中的 `experimentalDecorators` (旧版) 和未来的新配置项来选择使用哪种。
    *   许多库（如 MobX 6+）已经开始支持或迁移到更接近 Stage 3 提案的装饰器。

**建议：**

*   对于新项目，如果可以，关注并了解 Stage 3 装饰器提案。
*   对于现有项目或依赖旧版装饰器的框架，继续使用 `experimentalDecorators` 是可以的，但要意识到未来可能需要迁移。
*   如果你不使用依赖旧版装饰器的框架，可以谨慎考虑是否现在就引入装饰器，或者等待 Stage 3 装饰器在 TypeScript 中得到更完善的支持。

---

总而言之，装饰器是 TypeScript (及未来 JavaScript) 中一种强大的元编程工具，它允许以声明式、可重用的方式向类及其成员添加行为和元数据。它们极大地增强了代码的表达能力和框架的开发体验，但也需要谨慎使用并了解其当前的实验性质和未来的发展方向。