**具有接口的类 (Classes with Interfaces)**，也就是类如何**实现 (implement)** 接口。

这是一个非常核心且强大的 TypeScript 特性，用于确保你的类**遵循特定的结构或契约 (contract)**。

**核心思想：**

*   **接口 (Interface):** 定义了一个 “契约” 或 “蓝图”，规定了应该有哪些 **公共 (public)** 属性和方法，以及它们的类型签名。接口本身不包含实现。
*   **类 (Class):** 是创建对象的模板，包含属性和方法的具体实现。
*   **实现 (`implements`):** 当一个类声明 `implements` 一个接口时，它是在**承诺**：“我保证，我的实例将拥有该接口所要求的所有公共成员，并且类型兼容。”

**为什么要把类和接口结合起来？**

1.  **强制执行契约 (Enforcing Contracts):** 确保类提供了所必需的功能。如果类未能正确实现接口的所有成员，TypeScript 编译器会报错。这大大减少了运行时错误。
2.  **提高一致性 (Consistency):** 如果多个类需要扮演类似的角色（例如，都能被“序列化”，都能“打印”），让它们实现同一个接口可以保证它们都提供了统一的方法名和签名。
3.  **解耦 (Decoupling):** 代码的其他部分可以依赖于**接口**而不是具体的**类**。这意味着你可以轻松地替换掉实现该接口的具体类，只要新类也遵循相同的接口契约，依赖该接口的代码就无需修改。这对于测试（使用模拟对象 Mocking）和大型系统的灵活性至关重要。
4.  **API 设计:** 在设计库或模块时，先定义接口来明确公共 API，然后再编写类来实现这些接口。

**如何实现？**

使用 `implements` 关键字，后跟一个或多个接口名（用逗号分隔）。

```typescript
// 1. 定义接口 (契约)
interface Printable {
  // 要求必须有一个返回 void 的 print 方法
  print(): void;
}

interface Serializable {
  // 要求必须有一个 data 属性 (任何类型) 和一个返回 string 的 serialize 方法
  data: any;
  serialize(): string;
}

// 2. 创建一个类，声明它 'implements' Printable 和 Serializable
class Document implements Printable, Serializable {
  title: string; // 类可以有自己的额外属性
  data: any;     // 必须实现 Serializable 要求的 data 属性

  constructor(title: string, content: any) {
    this.title = title;
    this.data = content; // 初始化 data
  }

  // 必须实现 Printable 要求的 print 方法
  print(): void {
    console.log(`--- Document: ${this.title} ---`);
    console.log(this.data);
    console.log(`-------------------------`);
  }

  // 必须实现 Serializable 要求的 serialize 方法
  serialize(): string {
    return JSON.stringify({ title: this.title, content: this.data });
  }

  // 类可以有自己的额外方法
  getSummary(): string {
      return `Document titled "${this.title}"`;
  }
}

// 3. 创建类的实例
const report = new Document("Q1 Report", { sales: 10000, expenses: 5000 });

// 4. 使用实例 (可以调用所有公共方法，包括接口要求的和类自己的)
report.print();
const serializedReport = report.serialize();
console.log("Serialized:", serializedReport);
console.log(report.getSummary());

// 5. 类型检查和解耦
// 这个函数只关心对象是否 'Printable'，不关心它是不是 'Document'
function printAny(item: Printable): void {
  console.log("Using the printAny function:");
  item.print(); // 安全调用，因为 item 保证有 print 方法
}

printAny(report); // OK, 因为 Document implements Printable

// --- 如果类没有完全实现接口，会报错 ---
/*
class IncompleteDocument implements Printable {
    title: string;
    constructor(title: string) { this.title = title; }
    // Missing 'print' method! TypeScript Error:
    // Class 'IncompleteDocument' incorrectly implements interface 'Printable'.
    // Property 'print' is missing in type 'IncompleteDocument' but required in type 'Printable'.
}
*/
```

**关键点:**

1.  **`implements` 关键字:** 用于声明类遵循一个或多个接口的契约。
2.  **强制实现:** 类**必须**提供接口中定义的所有属性和方法的具体实现。名称、参数类型和返回类型都需要匹配（或兼容）。
3.  **只关心公共成员:** 接口只描述类的**公共 (public)** 部分。类可以拥有接口未定义的其他公共、私有或受保护成员。接口不能强制类实现私有或受保护成员。
4.  **可以实现多个接口:** 使用逗号分隔接口名 (`class C implements I1, I2, I3 { ... }`)。类必须实现所有这些接口要求的所有成员。
5.  **类型检查:** `implements` 主要用于**编译时**的类型检查，确保类的结构正确。它不改变类的运行时行为（不像 `extends` 会继承实现）。
6.  **与继承 (`extends`) 的区别:**
    *   `extends`: 类从另一个**类**继承**实现**（属性和方法）。一个类只能 `extends` 一个父类（单继承）。
    *   `implements`: 类承诺遵循一个或多个**接口**的**契约**（结构）。一个类可以 `implements` 多个接口。

**总结:**

让类 `implements` 接口是 TypeScript 中一种强大的设计模式，它强制类遵守预定义的结构契约。这带来了更好的代码组织、一致性、可维护性和解耦能力。当你需要定义一组类必须具备的公共能力时，或者想让代码依赖于抽象的“能力”而非具体的实现时，接口和 `implements` 是你的首选工具。