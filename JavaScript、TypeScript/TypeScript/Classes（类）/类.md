**创建类 (Making a Class)**。

在 TypeScript (以及现代 JavaScript) 中，**类 (Class)** 是创建对象的 **蓝图 (blueprint)** 或 **模板 (template)**。它是一种组织代码的方式，将相关的 **数据 (属性/properties)** 和 **行为 (方法/methods)** 封装在一起，是 **面向对象编程 (OOP)** 的核心概念。

使用类可以帮助你：

*   **组织代码:** 将相关的逻辑和数据放在一起。
*   **创建可重用的组件:** 定义一次蓝图，创建多个具有相同结构和行为的对象实例。
*   **实现继承:** 创建基于现有类的新类，复用和扩展功能。
*   **封装:** 控制外部代码对类内部数据和方法的访问。

下面是创建一个 TypeScript 类的基本步骤和关键要素：

#### **1. 基本语法 (`class` 关键字)**

使用 `class` 关键字，后跟类名（通常使用 **PascalCase** 命名法，如 `MyClass`）。

```typescript
class Greeter {
    // Class members (properties and methods) go here
}
```

#### **2. 属性 (Properties / Fields)**

属性用来存储对象的数据。你需要在类体中声明属性及其类型。

```typescript
class Product {
  // 声明属性及其类型
  name: string;
  price: number;
  isInStock: boolean;

  // 可以在声明时直接初始化
  readonly id: string = crypto.randomUUID(); // readonly 表示创建后不能修改

  // 构造函数 (稍后详解)
  constructor(name: string, price: number) {
    // 在构造函数中初始化属性
    this.name = name; // 'this' 指向当前创建的实例
    this.price = price;
    this.isInStock = true; // 默认值
  }
}
```

#### **3. 构造函数 (`constructor`)**

*   `constructor` 是一个特殊的方法，在通过 `new` 关键字创建类的新实例时自动调用。
*   它的主要作用是 **初始化** 对象的属性。
*   一个类只能有一个 `constructor`。
*   它可以接收参数，用于设置初始状态。

```typescript
class User {
  username: string;
  email: string;
  isActive: boolean = false; // 直接初始化默认值

  // 构造函数接收参数来初始化属性
  constructor(uname: string, mail: string) {
    this.username = uname;
    this.email = mail;
    // isActive 使用了默认值，无需在构造函数中显式设置 (除非需要根据参数决定)
    console.log(`User ${this.username} created.`);
  }
}
```

#### **4. 方法 (Methods)**

方法是定义在类上的函数，用来表示对象的行为。方法可以访问和修改对象的属性（通过 `this`）。

```typescript
class Counter {
  count: number = 0;

  increment(): void { // void 表示方法没有返回值
    this.count++;
    console.log(`Count is now: ${this.count}`);
  }

  reset(startValue: number = 0): void { // 可以有参数和默认值
    this.count = startValue;
    console.log(`Counter reset to: ${this.count}`);
  }

  getCurrentCount(): number { // 可以有返回值
      return this.count;
  }
}
```

#### **5. 创建实例 (`new` 关键字)**

使用 `new` 关键字调用类的构造函数来创建类的实例（对象）。

```typescript
// 使用上面定义的 User 类
const user1 = new User("Alice", "alice@example.com");
const user2 = new User("Bob", "bob@example.com");

console.log(user1.username); // 输出: Alice
user1.isActive = true; // 可以访问和修改 public 属性 (默认)

// 使用上面定义的 Counter 类
const myCounter = new Counter();
myCounter.increment(); // 输出: Count is now: 1
myCounter.increment(); // 输出: Count is now: 2
console.log(myCounter.getCurrentCount()); // 输出: 2
myCounter.reset(10);   // 输出: Counter reset to: 10
```

#### **6. 访问修饰符 (Access Modifiers) - TypeScript 特有**

TypeScript 提供了控制属性和方法可见性的修饰符：

*   **`public` (默认):** 成员可以在任何地方被访问（类的内部、类的实例、子类）。如果你不写修饰符，它默认就是 `public`。
*   **`private`:** 成员只能在 **声明它的类** 的内部被访问。实例和子类都不能访问。
*   **`protected`:** 成员可以在 **声明它的类** 及其 **子类** 的内部被访问。实例不能直接访问。

```typescript
class BankAccount {
  public ownerName: string;
  private balance: number; // 余额设为私有，外部不能直接访问
  protected accountType: string = 'checking'; // 账户类型可以在子类中访问

  constructor(owner: string, initialBalance: number) {
    this.ownerName = owner;
    this.balance = initialBalance;
  }

  public deposit(amount: number): void {
    if (amount <= 0) {
      console.error("Deposit amount must be positive.");
      return;
    }
    this.balance += amount;
    this.logTransaction(`Deposited ${amount}`);
  }

  public getBalance(): number { // 提供一个公共方法来获取余额
    this.logTransaction("Checked balance");
    return this.balance;
  }

  private logTransaction(message: string): void { // 私有方法，用于内部记录
    console.log(`[${new Date().toISOString()}] Account ${this.ownerName}: ${message}. Balance: ${this.balance}`);
  }
}

const myAccount = new BankAccount("Charlie", 1000);
myAccount.deposit(500);       // OK (public method)
// console.log(myAccount.balance); // Error: Property 'balance' is private.
console.log(myAccount.getBalance()); // OK, 通过公共方法访问
// myAccount.logTransaction("Manual log"); // Error: Property 'logTransaction' is private.
```

#### **7. 参数属性简写 (Parameter Properties Shorthand) - TypeScript 特有**

这是 TypeScript 提供的一个非常方便的语法糖：直接在构造函数的参数前添加访问修饰符（或 `readonly`），TypeScript 会自动帮你完成：

*   声明同名的类属性。
*   将构造函数参数的值赋给这个属性。

```typescript
class Employee {
  // 无需在这里单独声明 name 和 department
  // readonly id: string; // 如果有非参数属性，仍然需要声明

  // 使用参数属性简写
  constructor(
    public readonly id: string, // 自动创建 public readonly id 属性
    public name: string,       // 自动创建 public name 属性
    private department: string // 自动创建 private department 属性
  ) {
    // 构造函数体可以为空，或者只包含额外的逻辑
    console.log(`Employee ${this.name} created in ${this.department}`);
    // 注意：department 是 private，但在类内部可以访问
  }

  public getDepartment(): string {
      return this.department; // 可以在 public 方法中暴露 private 数据
  }
}

const emp1 = new Employee("EMP001", "Diana", "Sales");
console.log(emp1.id);   // 输出: EMP001
console.log(emp1.name); // 输出: Diana
// console.log(emp1.department); // Error: Property 'department' is private.
console.log(emp1.getDepartment()); // 输出: Sales
```

**8. `readonly` 修饰符**

用于属性，表示该属性只能在声明时或构造函数中被赋值。之后不能再修改。

**9. `static` 成员**

`static` 成员属于类本身，而不是类的实例。通过类名直接访问。常用于工具方法或常量。

```typescript
class MathHelper {
  static PI: number = 3.14159; // 静态属性

  static calculateCircumference(radius: number): number { // 静态方法
    return 2 * MathHelper.PI * radius;
  }
}

console.log(MathHelper.PI); // 通过类名访问静态属性
console.log(MathHelper.calculateCircumference(5)); // 通过类名调用静态方法
```

**10. 实现接口 (`implements`)**

类可以声明它遵循一个或多个接口的契约，强制类必须实现接口定义的所有属性和方法。

```typescript
interface Printable {
  print(): void;
}

class Report implements Printable { // 声明实现 Printable 接口
  title: string;

  constructor(title: string) {
    this.title = title;
  }

  // 必须实现接口要求的 print 方法
  print(): void {
    console.log(`Printing report: ${this.title}`);
  }
}

const salesReport = new Report("Q3 Sales");
salesReport.print();
```

**总结:**

TypeScript 的类提供了比 JavaScript 类更丰富的功能（主要是类型检查和访问修饰符），让你能够构建结构清晰、类型安全、易于维护和扩展的面向对象代码。掌握属性、构造函数、方法、访问修饰符、参数属性简写和 `static` 成员是使用 TypeScript 进行类开发的基础。