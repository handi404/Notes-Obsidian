探讨 Vue 中处理衍生状态和副作用的两大支柱：`computed` 和 `watch` / `watchEffect`。

理解它们的区别和适用场景，是写出优雅、高效、可维护的 Vue 应用的关键。

---

### `computed`：智能的衍生状态计算器

**核心思想**：当你需要一个值，它**依赖于**一个或多个其他的响应式状态时，你应该使用 `computed`。它不是用来做“事情”的，而是用来“计算”新数据的。

可以把它想象成电子表格里的一个单元格，它的值是通过公式（例如 `=A1+B1`）计算出来的。只有当 `A1` 或 `B1` 变化时，这个单元格的值才会重新计算。

#### 知识点：

```vue
<script setup lang="ts">
import { ref, computed } from 'vue';

const firstName = ref('John');
const lastName = ref('Doe');

// 这是一个计算属性 ref。它的 .value 是只读的。
// Vue 会自动追踪其回调函数中使用的响应式依赖 (firstName 和 lastName)。
const fullName = computed<string>(() => {
  // 这个函数只在 firstName 或 lastName 变化时才会重新执行
  console.log('Computing fullName...'); 
  return `${firstName.value} ${lastName.value}`;
});

// 一个不相关的状态
const counter = ref(0);
</script>

<template>
  <div>
    <p>First Name: <input v-model="firstName" /></p>
    <p>Last Name: <input v-model="lastName" /></p>
    
    <!-- 在模板中直接使用，无需 .value -->
    <h2>Hello, {{ fullName }}</h2>

    <hr />
    <button @click="counter++">Click me: {{ counter }}</button>
    <p>
      (打开控制台，你会发现，只有当你修改姓或名时，"Computing fullName..." 才会被打印。
      点击 counter 按钮不会触发 fullName 的重新计算。)
    </p>
  </div>
</template>
```

#### 要点/注意事项：`computed` vs. `methods` 的区别

这是 Vue 面试中的经典问题，也是一个核心概念。

| 特性 | `computed` (计算属性) | `methods` (方法) |
| :--- | :--- | :--- |
| **核心差异** | **基于依赖缓存** | **无缓存，每次调用都执行** |
| **调用方式** | 在模板中像属性一样访问：`{{ fullName }}` | 必须像函数一样调用：`{{ getFullName() }}` |
| **本质** | 一个响应式的、**只读的 `ref`** | 一个普通的**函数** |
| **语义** | "是什么" (声明式) - 它描述了一个值 | "做什么" (命令式) - 它执行一个动作 |
| **适用场景** | 依赖其他数据计算出的**新数据**，且计算开销较大或需要缓存时。 | 响应事件（如 `@click`），或者每次都需要重新执行的逻辑。 |

**简单总结**：如果你需要根据现有数据“算出”一个新数据并展示它，用 `computed`。如果你需要在用户点击按钮时“做”一件事，用 `methods` (在 `<script setup>` 中就是普通函数)。

---

### 侦听器 (`watch` & `watchEffect`)：副作用的执行者

**核心思想**：当一个响应式状态变化时，如果你需要**执行一个操作**（即“副作用”），而不是计算一个新值，那么就应该使用侦听器。

**什么是“副作用”？** 任何改变外部世界或不直接返回值的操作，例如：
*   发起网络请求 (API call)
*   手动操作 DOM
*   将数据存储到 `localStorage`
*   设置一个定时器 (`setTimeout`)
*   与第三方库集成

Vue 提供了两种侦听器：`watch` 和 `watchEffect`。

### `watch`：精确而强大的侦听器

`watch` 是一个更**明确**、更可控的侦听器。你需要显式地告诉它：**“请侦听『这个源』，当它变化时，执行『这个回调』。”**

#### 知识点与应用场景：

**场景 1：当数据变化时，执行异步或开销大的操作（最常见）**

```vue
<script setup lang="ts">
import { ref, watch } from 'vue';

const questionId = ref<number>(1);
const questionData = ref(null);

// 侦听 questionId 的变化
watch(questionId, async (newId, oldId) => {
  // 1. 可以访问新值和旧值
  console.log(`ID changed from ${oldId} to ${newId}`);

  // 2. 执行副作用：获取数据
  const response = await fetch(`https://api.example.com/questions/${newId}`);
  questionData.value = await response.json();
}, { 
  // 3. 选项对象
  immediate: true, // 立即执行一次回调，用于组件初始化时加载数据
  // deep: true,  // 如果侦听的是对象，需要深度侦听其内部属性变化时使用
});
</script>
```

**场景 2：侦听一个 `reactive` 对象中的属性**
你需要使用一个 getter 函数作为源来确保只在特定属性变化时才触发。

```ts
import { reactive, watch } from 'vue';

const state = reactive({ count: 0, user: { name: 'admin' } });

// 侦听 state.count
watch(
  () => state.count, 
  (newCount) => { console.log('Count changed:', newCount); }
);
```

**场景 3：侦听多个源**

```ts
import { ref, watch } from 'vue';

const sourceA = ref(0);
const sourceB = ref('hello');

watch([sourceA, sourceB], ([newA, newB], [oldA, oldB]) => {
  console.log(`A or B changed! New values: ${newA}, ${newB}`);
});
```

### `watchEffect`：简洁而自动的侦听器

`watchEffect` 更“魔幻”一些。你不需要指定侦听哪个源，它会**自动追踪**在其回调函数中用到的所有响应式依赖。

**核心思想**：“立即执行这个函数，然后，只要它内部用到的任何响应式数据发生变化，就重新执行它。”

#### 知识点与应用场景：

**场景 1：副作用和依赖高度耦合，逻辑简单**

最经典的例子就是将数据同步到 `localStorage`。

```vue
<script setup lang="ts">
import { ref, watchEffect } from 'vue';

const cart = ref([
  { id: 1, name: 'Product A', quantity: 2 },
]);

// 1. 无需指定源，它会自动发现 cart.value 是依赖
// 2. 默认立即执行一次
watchEffect(() => {
  console.log('Cart updated, syncing to localStorage...');
  localStorage.setItem('shoppingCart', JSON.stringify(cart.value));
});

function addProduct() {
  // 当 cart.value 变化时，上面的 watchEffect 会自动重新运行
  cart.value.push({ id: 2, name: 'Product B', quantity: 1 });
}
</script>
```

### 要点/注意事项：`watch` vs. `watchEffect` 的应用场景对决

| 特性 | `watch` | `watchEffect` |
| :--- | :--- | :--- |
| **依赖追踪** | **手动**、**显式**指定。更精确。 | **自动**追踪。更简洁。 |
| **执行时机** | 默认是**懒执行**的（依赖变化后才执行）。可通过 `immediate: true` 改变。 | **立即执行**一次，然后依赖变化时再执行。 |
| **访问旧值** | ✅ 可以访问到变化前后的值 (`newValue`, `oldValue`)。 | ❌ **不可以**。回调函数不接收任何参数。 |
| **性能** | 更精确，只有指定的源变化才触发。可能更高效。 | 任何一个内部依赖变化都会触发。可能导致不必要的重复执行。 |
| **代码意图** | **更清晰**。一眼就能看出“什么触发了什么”。 | 意图可能不那么明显，需要阅读整个回调函数才能知道依赖项。 |

#### 最佳实践与抉择：

*   **优先使用 `watch`**：在大多数情况下，`watch` 是更优的选择。它的**明确性**使得代码在几个月后或由其他同事接手时，更容易理解和维护。你能清晰地看到因果关系。

*   **什么时候使用 `watchEffect`？**
    1.  当你的副作用逻辑非常简单，并且依赖项和副作用代码紧密地写在一起时，`watchEffect` 可以让代码更简洁。
    2.  当你不在乎旧值，并且希望副作用立即执行时。
    3.  当你有多个依赖项，而使用 `watch` 的数组语法 `watch([a, b, c], ...)` 显得很繁琐时。

**一个简单的决策流程：**
1.  我需要旧值吗？
    *   是 -> 用 `watch`。
2.  我需要精确控制侦听的源，避免不必要的触发吗？
    *   是 -> 用 `watch`。
3.  我需要在组件初始化时不执行，只在后续变化时执行吗？
    *   是 -> 用 `watch` (不加 `immediate: true`)。
4.  如果以上都不是，并且我的逻辑很简单（比如只有一个依赖），`watchEffect` 可以让代码更少。

---

### 总结

*   **`computed`**: 用于**计算衍生数据**。它有缓存，是声明式的。回答“这个值**是什么**”。
*   **`watch`**: 用于**执行副作用**。它精确、可控，能访问新旧值。回答“当 A 变化时，**做什么**”。
*   **`watchEffect`**: 用于**执行副作用**。它自动、简洁，但控制力较弱。回答“只要这些东西变了，就**重新做这件事**”。