### Vue 指令分类概览

Vue 的指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。指令的职责是，当其表达式的值改变时，相应地将行为应用到 DOM 上。我们可以将它们分为以下几类：

1.  **条件渲染 (Conditional Rendering)**：控制 DOM 元素的显示与隐藏或存在与否。
    *   `v-if`, `v-else-if`, `v-else`
    *   `v-show`
2.  **列表渲染 (List Rendering)**：根据数据源渲染一个列表。
    *   `v-for`
3.  **属性绑定 (Attribute Binding)**：动态地绑定一个或多个 attribute。
    *   `v-bind` (常用缩写 `:`)
4.  **事件监听 (Event Handling)**：监听 DOM 事件并执行代码。
    *   `v-on` (常用缩写 `@`)
5.  **双向绑定 (Two-Way Binding)**：在表单控件和组件上创建双向数据绑定。
    *   `v-model`
6.  **内容渲染 (Content Rendering)**：控制元素内部的内容。
    *   `v-text`
    *   `v-html`
7.  **结构与插槽 (Structure & Slots)**：用于定义组件内容分发 API。
    *   `v-slot` (常用缩写 `#`)
8.  **性能与特殊场景 (Performance & Special Cases)**：用于优化和处理特殊情况。
    *   `v-once`
    *   `v-memo`
    *   `v-pre`
    *   `v-cloak`
9.  **自定义指令 (Custom Directives)**：创建你自己的指令。

---

### 1. 条件渲染 (Conditional Rendering)

#### `v-if`, `v-else-if`, `v-else`

*   **核心功能**：根据表达式的真假值，**真正地**创建或销毁 DOM 元素及其组件实例。
*   **语法**：
    ```html
    <div v-if="type === 'A'">A</div>
    <div v-else-if="type === 'B'">B</div>
    <div v-else>Not A/B</div>
    ```
*   **示例**：
    ```vue
    <script setup lang="ts">
    import { ref } from 'vue';
    const score = ref(85);
    </script>
    <template>
      <p v-if="score >= 90">优秀</p>
      <p v-else-if="score >= 60">及格</p>
      <p v-else>不及格</p>
    </template>
    ```
*   **要点与应用**：
    *   `v-if` 是“懒惰的”：如果初始条件为假，则什么也不会渲染。只有当条件第一次变为真时，才会开始渲染。
    *   它们必须是相邻的兄弟元素才能正常工作。
    *   可以使用 `<template>` 标签作为不可见的包裹元素，来切换一组元素。

#### `v-show`

*   **核心功能**：根据表达式的真假值，通过切换元素的 CSS `display` 属性来控制其显示与隐藏。元素始终被渲染在 DOM 中。
*   **语法**：`v-show="condition"`
*   **示例**：
    ```vue
    <script setup lang="ts">
    import { ref } from 'vue';
    const isLoading = ref(true);
    </script>
    <template>
      <div v-show="isLoading" class="loading-spinner"></div>
    </template>
    ```
*   **`v-if` vs `v-show` 如何选择？（重要）**
    *   **`v-if`**：有更高的**切换开销**（销毁/重建），但有更低的**初始渲染开销**。适用于运行时条件不经常改变的场景。
    *   **`v-show`**：有更低的**切换开销**（仅 CSS），但有更高的**初始渲染开销**（无论如何都会渲染）。适用于需要非常频繁地切换的场景。

---

### 2. 列表渲染 (List Rendering)

#### `v-for`

*   **核心功能**：基于一个数组或对象来渲染一个列表。
*   **语法**：
    *   数组：`v-for="(item, index) in items"`
    *   对象：`v-for="(value, key, index) in myObject"`
    *   范围：`v-for="n in 10"`
*   **示例**：
    ```vue
    <script setup lang="ts">
    import { ref } from 'vue';
    interface User { id: number; name: string; }
    const users = ref<User[]>([
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' },
    ]);
    </script>
    <template>
      <ul>
        <li v-for="user in users" :key="user.id">
          {{ user.name }}
        </li>
      </ul>
    </template>
    ```
*   **要点与应用**：
    *   **`:key` 是必须的且至关重要**：`key` 必须是唯一的、稳定的值（如 `item.id`）。它帮助 Vue 的 diff 算法识别每个节点的身份，从而高效地重用和重新排序元素。**永远不要使用 `index` 作为 `key`**，除非列表是纯静态且永不改变的，否则会导致性能问题和状态混乱。
    *   **`v-if` 与 `v-for` 的优先级**：在 Vue 3 中，`v-if` 的优先级高于 `v-for`。这意味着**永远不要将它们放在同一个元素上**，因为 `v-if` 会先执行，此时它还访问不到 `v-for` 循环中的变量。
    *   **正确做法**：
        1.  **过滤数据源**：使用 `computed` 属性预先过滤出需要显示的列表。**（最佳实践）**
        2.  **包裹 `<template>`**：将 `v-for` 移到 `<template>` 标签上，然后在内部元素上使用 `v-if`。

---

### 3. 属性绑定 (Attribute Binding)

#### `v-bind` (缩写 `:`)

*   **核心功能**：动态地绑定一个或多个 HTML attribute、组件 prop 或 class/style。
*   **语法**：`v-bind:attribute="expression"` 或 `:attribute="expression"`
*   **示例**：
    ```vue
    <script setup lang="ts">
    import { ref, reactive } from 'vue';
    const imageUrl = ref('/logo.png');
    const isDisabled = ref(true);
    const linkAttrs = reactive({
      href: 'https://vuejs.org',
      target: '_blank'
    });
    </script>
    <template>
      <!-- 绑定单个 attribute -->
      <img :src="imageUrl" alt="Vue Logo">
      <button :disabled="isDisabled">Button</button>
      
      <!-- 绑定一个包含多个 attribute 的对象 -->
      <a v-bind="linkAttrs">Vue Official</a>
    </template>
    ```
*   **要点与应用**：
    *   **Class 和 Style 绑定**：`v-bind` 对 `class` 和 `style` 提供了增强支持，可以传入对象或数组，实现强大的动态样式控制。
        ```html
        <div :class="{ active: isActive, 'text-danger': hasError }"></div>
        <div :style="[{ color: activeColor }, { fontSize: size + 'px' }]"></div>
        ```

---

### 4. 事件监听 (Event Handling)

#### `v-on` (缩写 `@`)

*   **核心功能**：监听 DOM 事件，并在事件触发时执行 JavaScript 代码。
*   **语法**：`v-on:event="handler"` 或 `@event="handler"`
*   **示例**：
    ```vue
    <script setup lang="ts">
    import { ref } from 'vue';
    const count = ref(0);
    const greet = (name: string, event: MouseEvent) => {
      alert(`Hello, ${name}!`);
      // event 对象是可选的，会被自动传入
      if (event) event.preventDefault();
    };
    </script>
    <template>
      <!-- 内联处理器 -->
      <button @click="count++">Add 1</button>
      
      <!-- 方法处理器 -->
      <button @click="greet('Vue', $event)">Greet</button>
    </template>
    ```
*   **要点与应用**：
    *   **事件修饰符**：非常实用的功能，无需在方法中写 `event.preventDefault()` 等代码。
        *   `.stop`：阻止事件冒泡。
        *   `.prevent`：阻止默认行为。
        *   `.capture`：使用事件捕获模式。
        *   `.self`：只有当事件是从该元素自身触发时才触发。
        *   `.once`：只触发一次。
        *   `.passive`：提升滚动性能，告诉浏览器该事件监听器不会调用 `preventDefault`。
    *   **按键修饰符**：`@keyup.enter`, `@keydown.tab` 等。

---

### 5. 双向绑定 (Two-Way Binding)

#### `v-model`

*   **核心功能**：在表单元素 (`<input>`, `<textarea>`, `<select>`) 或组件上创建双向数据绑定。
*   **语法**：`v-model="stateVariable"`
*   **讲解**：`v-model` 是一个语法糖。
    *   在原生表单元素上，它会被编译为 `:value` 和 `@input` (或根据元素类型是 `:checked` 和 `@change` 等)。
    *   在组件上，它默认会被编译为 `:modelValue` prop 和 `@update:modelValue` 事件。（正如我们之前讨论的）
*   **示例**：
    ```vue
    <script setup lang="ts">
    import { ref } from 'vue';
    const message = ref('');
    const isChecked = ref(false);
    </script>
    <template>
      <input v-model="message" placeholder="edit me">
      <p>Message is: {{ message }}</p>

      <input type="checkbox" v-model="isChecked">
      <span>Checked: {{ isChecked }}</span>
    </template>
    ```
*   **要点与应用**：
    *   **`v-model` 修饰符**:
        *   `.lazy`：默认 `v-model` 在 `input` 事件中同步，此修饰符会改为在 `change` 事件中同步。
        *   `.number`：自动将用户的输入值转为数值类型。
        *   `.trim`：自动过滤用户输入的首尾空白字符。

---

### 6. 内容渲染 (Content Rendering)

#### `v-text`

*   **核心功能**：更新元素的 `textContent`。
*   **语法**：`v-text="expression"`
*   **讲解**：`<div>{{ message }}</div>` 等同于 `<div v-text="message"></div>`。它会覆盖元素内的所有内容。通常我们直接使用 Mustache 语法 (`{{ }}`) 更为灵活。

#### `v-html`

*   **核心功能**：更新元素的 `innerHTML`。
*   **语法**：`v-html="rawHtml"`
*   **⚠️ 安全警告**：
    *   **永远不要**在网站上动态渲染任意的、用户提供的 HTML，这极易导致 **XSS (跨站脚本) 攻击**。
    *   请只在内容安全可信时（例如由你自己在后端生成）或对第三方内容进行**严格净化 (sanitize)** 后再使用 `v-html`。

---

### 7. 结构与插槽 (Structure & Slots)

#### `v-slot` (缩写 `#`)

*   **核心功能**：用于定义具名插槽或接收作用域插槽的 props。
*   **语法**：
    *   默认插槽：`v-slot:default` 或直接在组件标签内。
    *   具名插槽：`v-slot:name` 或 `#name`
    *   作用域插槽：`#name="slotProps"`
*   **讲解**：这是组件化的核心之一，允许父组件向子组件的指定位置插入内容。
*   **示例 (父组件)**：
    ```html
    <BaseLayout>
      <template #header>
        <h1>Here might be a page title</h1>
      </template>

      <p>A paragraph for the main content.</p>

      <template #footer="{ year }">
        <p>Copyright {{ year }}</p>
      </template>
    </BaseLayout>
    ```

---

### 8. 性能与特殊场景 (Performance & Special Cases)

#### `v-once`

*   **核心功能**：仅渲染元素和组件一次。随后的重新渲染，该元素/组件及其所有子节点将被视为静态内容并跳过。
*   **应用**：用于优化那些你确定永远不会改变的静态内容。

#### `v-memo`

*   **核心功能**：一个更细粒度的性能优化指令。它接收一个依赖数组，只有当数组中的某个值发生变化时，它才会重新渲染该子树。
*   **示例**：
    ```html
    <div v-memo="[subscriber.id, subscriber.lastUpdated]">
      <!-- 只有当 id 或 lastUpdated 变化时才更新 -->
    </div>
    ```

#### `v-pre`

*   **核心功能**：跳过此元素及其所有子元素的编译过程。
*   **应用**：用于显示原始的 Mustache 标签。

#### `v-cloak`

*   **核心功能**：保持在元素上直到关联的组件实例完成编译。
*   **应用**：与 CSS 规则如 `[v-cloak] { display: none }` 配合使用，可以隐藏尚未编译的 Mustache 标签，直到 Vue 准备就绪，防止页面加载时出现“闪烁”。在现代的、基于构建工具（如 Vite）的项目中，这个问题基本不存在，所以 `v-cloak` 的使用场景很少了。

---

### 9. 自定义指令 (Custom Directives)

*   **核心功能**：当内置指令不满足需求时，可以注册自己的指令，用于直接操作 DOM。
*   **应用场景**：集成第三方库、自动聚焦、点击外部区域等。
*   **示例 (自动聚焦指令)**：
    ```vue
    <script setup lang="ts">
    import type { Directive } from 'vue';

    // 1. 定义指令 (本地注册)
    // 类型 `Directive<HTMLElement, string>` 表示元素是 HTMLElement，指令的值是 string
    const vFocus: Directive<HTMLInputElement> = {
      // 在绑定元素的父组件及他自己的所有子节点都挂载完成后调用
      mounted: (el) => {
        el.focus();
      }
    };
    </script>
    <template>
      <!-- 2. 使用指令 -->
      <input v-focus />
    </template>
    ```
*   **指令钩子**：自定义指令提供了一系列生命周期钩子，如 `created`, `beforeMount`, `mounted`, `beforeUpdate`, `updated` 等，让你可以在指令生命周期的不同阶段执行逻辑。