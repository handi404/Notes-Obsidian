从 Git 的四大金刚开始：`git commit`、`git branch`、`git merge` 和 `git rebase`。我会用最贴近你日常开发的方式来讲解。

想象你在写一本书（你的项目代码）：

---

### 1. `git commit`：为你的工作“存档”并写下“备忘录”

*   **核心概念：**
    `commit` 就是给你的项目在当前状态下拍一张“快照”。这张快照包含了你**已暂存 (staged)** 的所有修改。同时，你还需要为这张快照写一个“备忘录”（commit message），说明这次存档你都做了些什么。
*   **通俗理解：**
    就像你在玩一个闯关游戏，每过一小关，你都会存个档，并备注一下“打败了小怪兽，获得了宝剑”。这样以后想回到这个进度，或者想知道当时发生了什么，就一目了然。
*   **什么时候用？**
    *   完成了一个小功能点。
    *   修复了一个 Bug。
    *   对代码做了一次有意义的重构。
    *   总之，当你觉得当前的工作告一段落，可以形成一个独立的、有意义的变更单元时。
*   **基本流程：**
    1.  **修改文件：** 你在你的工作目录里编辑代码、添加新文件、删除旧文件等。
    2.  **暂存更改 (Staging)：** `git add <文件名>` 或 `git add .` (暂存所有更改)。
        *   这一步非常重要，它像是把你要“拍照”的内容先放到一个“待拍摄区”。只有在“待拍摄区”的内容才会被 `commit` 记录。
        *   最新的 Git 推荐使用 `git add -p` (patch mode) 进行交互式暂存，可以更精细地选择要暂存的代码块。
    3.  **提交更改：** `git commit -m "你的提交信息"`
        *   `-m` 后面跟的是本次提交的简短描述，例如："feat: 实现用户登录功能" 或 "fix: 修复无法找回密码的 bug"。
        *   **强烈建议**遵循良好的提交信息规范（如 Conventional Commits），这对于后续的代码追溯、版本发布非常有帮助。
        *   如果想写更详细的提交信息，可以不带 `-m`，Git 会打开你配置的文本编辑器让你输入。
*   **重要技巧：**
    *   **`git commit --amend`**：修改最后一次提交。
        *   场景 1: 提交信息写错了。
        *   场景2: 刚提交完，发现漏了几个文件，或者有个小笔误。你可以 `git add <补充的文件>`，然后 `git commit --amend --no-edit` (不修改提交信息，只把新暂存的内容加进去)，或者 `git commit --amend` (同时修改提交信息和内容)。
        *   **注意：** 如果你的提交已经被推送 (push) 到远程仓库，并且别人可能已经基于它工作了，**绝对不要**用 `--amend` 修改它，这会造成历史不一致。只在本地未推送的提交上使用。
*   **一句话总结：** `git add` 挑选要记录的更改，`git commit` 保存这些更改并写下说明。

---

### 2. `git branch`：开辟“平行宇宙”进行独立工作

*   **核心概念：**
    `branch`（分支）允许你从主开发线（通常是 `main` 或 `master`）分离出来，在一个独立的环境中进行工作，而不会影响到主线或其他人的工作。它本质上只是一个指向某个 `commit` 的轻量级可移动指针。
*   **通俗理解：**
    还是写书的例子。你的书（`main` 分支）正在顺利编写。现在你想尝试一个新的故事情节，但不确定好不好，也不想打乱主线。于是你复制一份当前手稿（创建新分支，比如叫 `experimental-plot`），在这个副本上尝试新情节。如果成功了，再把它合并回主线；如果失败了，直接丢弃这个副本，主线故事不受任何影响。
*   **什么时候用？**
    *   开发新功能 (feature branch)。
    *   修复 Bug (bugfix branch)。
    *   进行实验性的尝试。
    *   为不同版本发布做准备 (release branch)。
*   **常用操作：**
    *   **列出分支：**
        *   `git branch`：列出所有本地分支，当前分支会用 `*` 标记。
        *   `git branch -r`：列出所有远程跟踪分支。
        *   `git branch -a`：列出所有本地和远程跟踪分支。
    *   **创建新分支：**
        *   `git branch <新分支名>`：创建一个新分支，但你仍然停留在当前分支。
    *   **切换分支：**
        *   `git switch <已存在的分支名>` (推荐，更新的命令)
        *   `git checkout <已存在的分支名>` (旧命令，但仍广泛使用)
    *   **创建并立即切换到新分支：**
        *   `git switch -c <新分支名>` (推荐)
        *   `git checkout -b <新分支名>` (旧命令)
    *   **删除分支：**
        *   `git branch -d <分支名>`：删除一个**已经合并**到其他分支的分支。如果分支未合并，Git 会提示并阻止删除。
        *   `git branch -D <分支名>`：强制删除一个分支，无论它是否已合并（**慎用！**）。
    *   **重命名分支：**
        *   如果你在当前分支上：`git branch -m <新分支名>`
        *   如果你在其他分支上：`git branch -m <旧分支名> <新分支名>`
*   **关键点：**
    *   分支的创建和切换非常快速，因为 Git 只是移动指针，而不是复制整个项目。
    *   **黄金法则：** 永远不要在 `main` (或 `master`) 分支上直接进行日常开发。为每个新任务（功能、修复）创建一个新分支。这使得代码审查、测试和集成更加容易。
    *   分支命名要有意义，例如 `feature/user-login`、`fix/issue-123`。
*   **一句话总结：** `git branch` 让你拥有独立的工作空间，`git switch` (或 `checkout`) 让你在这些空间之间穿梭。

---

### 3. `git merge`：将不同“平行宇宙”的工作“汇合”

*   **核心概念：**
    `merge` 用于将一个分支的更改（一系列 commit）合并到另一个分支中。Git 会尝试自动合并这些更改。
*   **通俗理解：**
    你实验性的故事情节 (`experimental-plot` 分支) 写得非常成功，现在你决定把它正式加入到你的书的主线 (`main` 分支) 中。`merge` 就是把 `experimental-plot` 上的所有新内容“抄写”并整合到 `main` 手稿里的过程。
*   **什么时候用？**
    *   一个功能开发完成（在 `feature/user-login` 分支上），需要将其合并回主开发分支（如 `develop` 或 `main`）。
    *   主开发分支有了新的更新，你需要将这些更新同步到你当前正在开发的特性分支上，以保持与主线一致。
*   **基本流程：**
    1.  **切换到接收更改的分支：** 假设你想把 `feature-branch` 合并到 `main`。
        `git switch main`
    2.  **确保接收分支是最新的：** （如果是协作环境）
        `git pull origin main` (或者 `git fetch` 后再 `git merge origin/main`)
    3.  **执行合并：**
        `git merge feature-branch`
*   **合并的两种主要方式：**
    1.  **Fast-forward (快进式合并)：**
        *   如果 `main` 分支在你创建 `feature-branch` 后没有任何新的提交，那么 `feature-branch` 就是 `main` 的直接下游。
        *   此时，`git merge feature-branch` 会直接把 `main` 分支的指针移动到 `feature-branch` 的最新提交上。没有新的“合并提交”产生。历史记录是一条直线。
    2.  **Three-way merge (三方合并 / 非快进式合并)：**
        *   如果 `main` 分支在你创建 `feature-branch` 后也有了新的提交，那么两个分支就出现了分叉。
        *   此时，Git 会找到这两个分支的共同祖先，然后将两个分支的更改与共同祖先进行比较，生成一个新的“合并提交 (merge commit)”。这个合并提交会有两个父提交。历史记录会显示出分支合并的轨迹。
        *   这是更常见的情况。
*   **合并冲突 (Merge Conflicts)：**
    *   如果两个分支修改了同一个文件的同一部分，Git 无法自动决定应该保留哪个版本，这时就会发生“合并冲突”。
    *   Git 会在冲突的文件中用特殊标记（如 `<<<<<<< HEAD`, `=======`, `>>>>>>> feature-branch`）标出冲突区域。
    *   你需要**手动编辑**这些文件，解决冲突（决定保留哪些内容，或者如何组合它们）。
    *   解决后，使用 `git add <冲突文件名>` 标记为已解决。
    *   当所有冲突都解决并暂存后，执行 `git commit` (通常 Git 会为你准备好一个默认的合并提交信息) 来完成合并。或者如果是在 rebase 过程中，则是 `git rebase --continue`。
*   **重要选项：**
    *   `git merge --no-ff <分支名>`：即使可以快进式合并，也强制创建一个合并提交。这样做的好处是，可以从历史记录中清晰地看出某个特性是从哪个分支合并过来的，保留了分支的完整脉络。很多团队推荐这种做法。
    *   `git merge --squash <分支名>`：将指定分支上的所有提交“压扁”成一个变更集，然后将其应用到当前分支的暂存区，但**不会自动创建提交**。你需要自己 `git commit` 来创建一个新的提交。这样做可以让主分支历史更简洁，但会丢失特性分支的详细提交历史。
    *   `git merge --abort`：如果合并过程中遇到问题（比如冲突解决得很糟糕），可以用这个命令放弃本次合并，回到合并之前的状态。
*   **一句话总结：** `git merge` 将一个分支的成果整合到另一个分支，可能会创建新的合并记录点。

---

### 4. `git rebase`：给你的提交历史“重新打基础”或“嫁接”

*   **核心概念：**
    `rebase` (变基) 是另一种合并分支更改的方法。它会把你当前分支上的一系列提交“拎起来”，然后逐个重新应用 (replay) 到目标分支的最新提交之后。**这个过程会改写你当前分支的提交历史。**
*   **通俗理解：**
    回到写书的例子。你在你的 `experimental-plot` 分支上写了几个章节（几个 commit）。与此同时，你的合作者在 `main` 分支上也更新了一些内容（比如修正了一些背景设定）。
    *   **用 Merge 的话：** 你会把 `main` 的更新合并到你的 `experimental-plot`，或者直接把 `experimental-plot` 合并到 `main`，这会产生一个“合并点”，表示“我在这里整合了主线的背景设定更新”。
    *   **用 Rebase 的话：** 你会先把 `experimental-plot` 分支“回退”到与 `main` 分叉前的状态，然后把 `main` 分支上最新的背景设定“同步”过来，然后把你之前在 `experimental-plot` 上写的几个章节，**基于这个最新的背景设定**，一章一章地“重新写”上去。最终效果是，你的 `experimental-plot` 分支看起来就像是直接从最新的 `main` 分支上生长出来的一样，历史线非常干净、线性。
*   **什么时候用？**
    1.  **保持特性分支与主分支同步，并获得干净的历史：**
        *   你在 `feature-branch` 上开发，`main` 分支也在不断前进。为了避免将来合并时产生巨大的合并冲突或复杂的合并历史，你可以定期将 `main` 分支的更改 `rebase` 到你的 `feature-branch` 上。
        *   流程：
            1.  `git switch feature-branch`
            2.  `git fetch origin` (获取远程 `main` 的最新状态，假设远程主分支是 `origin/main`)
            3.  `git rebase origin/main`
        *   这会把 `feature-branch` 上独有的提交，一个个应用到 `origin/main` 的最新提交之后。
    2.  **整理本地提交历史（交互式 Rebase）：** 在将本地分支推送到远程或发起 Pull Request 之前，可以用 `git rebase -i` (interactive) 来清理你的提交历史，比如：
        *   合并多个零散的提交 (squash, fixup)。
        *   修改提交信息 (reword)。
        *   调整提交顺序。
        *   删除不需要的提交 (drop)。
*   **基本流程 (将当前分支 rebase 到目标分支)：**
    1.  **确保当前在你想要 rebase 的分支上：**
        `git switch my-feature-branch`
    2.  **执行 rebase：**
        `git rebase main` (假设 `main` 是本地最新的目标基底)
        或者，更常见的是 rebase 到远程主分支的最新状态：
        `git fetch origin`
        `git rebase origin/main`
*   **Rebase 过程中的冲突：**
    *   由于 rebase 是逐个应用提交，所以冲突也会逐个出现。
    *   当遇到冲突时，Git 会停下来，让你解决冲突。
    *   解决冲突后，`git add <冲突文件名>`。
    *   然后执行 `git rebase --continue` 继续应用下一个提交。
    *   如果想跳过某个有问题的提交，可以用 `git rebase --skip` (慎用，可能会丢失更改)。
    *   如果想完全放弃本次 rebase，回到 rebase 前的状态，用 `git rebase --abort`。
*   **黄金法则 (The Golden Rule of Rebasing)：**
    **永远不要对已经被推送到共享仓库（即其他人可能已经拉取并基于其工作的分支）的提交进行 rebase！**
    *   因为 rebase 会创建**新的**提交（即使内容和信息一样，它们的 SHA-1 ID 也不同），旧的提交会被抛弃。如果你 rebase 了一个已经共享的提交，那么你的历史和别人的历史就会产生分歧，这会导致团队协作的巨大混乱。
    *   **安全区：** 只对你本地私有的、尚未分享的提交进行 rebase。
    *   **例外：** 如果团队约定了某种 rebase 流程（例如，特性分支在合并前回顾性 rebase 到 `main`），并且你知道如何处理强制推送 (`git push --force-with-lease`) 的后果，那么可以。但对于初学者，请严格遵守黄金法则。
*   **Merge vs. Rebase 的选择：**
    *   **Merge：**
        *   **优点：** 保留了分支的真实历史，包括合并点，易于追溯。不会改写历史，对共享分支更安全。
        *   **缺点：** 如果分支活动频繁，可能会产生很多合并提交，使得主干历史看起来杂乱。
    *   **Rebase：**
        *   **优点：** 产生一个更干净、线性的提交历史，易于阅读和理解。
        *   **缺点：** 改写历史，如果用于共享分支会非常危险。冲突可能需要多次解决（每个被 rebase 的提交都可能遇到）。
    *   **常见策略：**
        *   在特性分支本地开发时，使用 `rebase` 来同步主分支 (`main` 或 `develop`) 的更新，保持特性分支的整洁。
        *   当特性分支准备好合并回主分支时，通常使用 `merge` (可能是 `merge --no-ff`)，以保留特性分支作为一个整体单元的记录。
*   **一句话总结：** `git rebase` 让你的提交历史更线性整洁，但因为它会改写历史，所以请牢记“黄金法则”。