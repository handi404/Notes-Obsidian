在 Git 中如何“撤销变更”，这绝对是每个开发者都会遇到的场景。区分**本地撤销**（变更尚未推送到共享仓库）和**远程撤销**（变更已推送到共享仓库，可能已被他人拉取）两种情况，因为它们的处理方式和影响有很大不同。

---

### 撤销本地变更 (尚未 `git push`)

这些操作通常只影响你自己的本地仓库，相对安全，可以大胆尝试（当然，理解清楚再操作总是好的）。

#### 1. 撤销工作目录中的修改 (文件未 `git add`)

*   **场景：** 你修改了一个文件，但还没执行 `git add`，现在想放弃这些修改，恢复到上次提交（或上次 `git add` 之后）的状态。
*   **命令：**
    *   **`git restore <文件名>`** (推荐，Git 2.23+ 引入的新命令，更清晰)
        `git restore my_file.txt`
    *   **`git checkout -- <文件名>`** (旧命令，但仍广泛使用)
        `git checkout -- my_file.txt`
        **注意：** `checkout` 后面必须有 `--`，否则如果 `<文件名>` 恰好和某个分支名相同，Git 会以为你要切换分支。
*   **撤销所有未暂存的修改：**
    *   `git restore .`
    *   `git checkout -- .`
*   **效果：** 文件内容会恢复到 `HEAD`（即上次提交时）的状态。**这些修改会直接丢失，无法找回（除非你的编辑器有本地历史记录功能）。**
*   **通俗理解：** 你在草稿纸上写了点东西，觉得不好，直接擦掉。

#### 2. 撤销已暂存的修改 (文件已 `git add`，但未 `git commit`)

*   **场景：** 你用 `git add` 把一些修改添加到了暂存区，但还没提交，现在想把它们从暂存区撤销出来（放回到工作目录，变成未暂存状态），或者完全放弃这些修改。
*   **命令 (仅从暂存区撤销，保留工作目录的修改)：**
    *   **`git restore --staged <文件名>`** (推荐，Git 2.23+ 新命令)
        `git restore --staged my_file.txt`
    *   **`git reset HEAD <文件名>`** (旧命令，仍广泛使用)
        `git reset HEAD my_file.txt` (这里的 `HEAD` 是可选的，默认就是 `HEAD`)
*   **撤销所有已暂存的修改 (放回工作目录)：**
    *   `git restore --staged .`
    *   `git reset HEAD .` 或 `git reset`
*   **效果：** 指定文件或所有暂存区的修改会回到工作目录，状态从未暂存。此时，如果你想彻底丢弃这些修改，可以再执行上一节的 `git restore <文件名>` 或 `git checkout -- <文件名>`。
*   **通俗理解：** 你把一些写好的草稿放到了“待提交”文件夹，现在又拿了出来，可以继续修改，也可以直接扔掉。

*   **命令 (从暂存区撤销，并且同时放弃工作目录的修改 - 一步到位)：**
    *   先执行 `git restore --staged <文件名>` （或 `git reset HEAD <文件名>`）
    *   再执行 `git restore <文件名>` （或 `git checkout -- <文件名>`）
    *   **或者，如果你确定要彻底丢弃这些已暂存的修改：**
        `git checkout HEAD -- <文件名>` (直接用上次提交的状态覆盖暂存区和工作区)
        这个命令有点像 `git restore <文件名>` 但作用于暂存区内容所对应的版本。

#### 3. 撤销最近的提交 (已 `git commit`，但未 `git push`)

*   **场景：** 你刚刚提交了一个 commit，但发现有些问题（比如提交信息写错了，或者漏了文件，或者提交了不该提交的内容），并且这个 commit 还没有推送到远程仓库。
*   **方式一：修改最后一次提交 (`git commit --amend`)**
    *   **用途：**
        *   修改提交信息。
        *   添加忘记暂存的文件。
        *   对最后一次提交的内容做小幅调整。
    *   **流程：**
        1.  (可选) 如果需要添加或修改文件：
            `git add <新文件或修改后的文件>`
        2.  执行修改：
            `git commit --amend`
            这会打开编辑器让你修改提交信息。如果不想修改提交信息，只想把新暂存的内容加进去，可以用：
            `git commit --amend --no-edit`
    *   **效果：** **它不会创建一个新的提交，而是用一个新的提交替换掉你当前的最后一次提交。** 原来的错误提交就“消失”了（实际上还在 reflog 里，但不在当前分支历史里）。
    *   **警告：** 因为它改写了历史，所以**只应在你尚未将此提交推送到共享仓库时使用。**
    *   **通俗理解：** 你刚给书稿存了个档并写了备注，发现备注写错了或漏了一页，赶紧重新存档并修改备注，覆盖掉刚才那个不满意的存档。

*   **方式二：重置到上一个提交 (`git reset`)**
    *   **用途：** 完全撤销一个或多个本地提交，就像它们从未发生过一样。
    *   **命令及模式：**
        *   **`git reset --soft HEAD^`** (或 `HEAD~1`)
            *   **效果：** 撤销了最后一次提交，但**保留**了那次提交所做的所有更改在**暂存区 (Staging Area)**。你可以重新组织这些更改，然后进行一次新的、正确的提交。
            *   **通俗理解：** 你把存档回退了一步，但所有内容都还在“待提交”文件夹里。
        *   **`git reset --mixed HEAD^`** (或 `HEAD~1`) (这是 `git reset` 的默认模式)
            *   **效果：** 撤销了最后一次提交，并且把那次提交所做的所有更改放回到了**工作目录 (Working Directory)**，状态变为未暂存。你可以修改这些文件，然后重新 `git add` 和 `git commit`。
            *   **通俗理解：** 你把存档回退了一步，并且所有内容都拿回到了你的草稿纸上，可以重新编辑。
        *   **`git reset --hard HEAD^`** (或 `HEAD~1`)
            *   **效果：** **彻底彻底地**撤销了最后一次提交，并且**丢弃**了那次提交所做的所有更改（包括工作目录和暂存区的）。你的代码库会完全恢复到倒数第二个提交的状态。
            *   **警告：这是一个破坏性操作，一旦执行，那些更改就很难找回了（除非通过 reflog，但也很麻烦）。请务必谨慎使用！**
            *   **通俗理解：** 你把存档回退了一步，并且把那一存档版本之后的所有草稿都撕掉了。
    *   **撤销多个提交：**
        你可以用 `HEAD~n` 来撤销最近的 `n` 个提交，例如 `git reset --hard HEAD~3` 会撤销最近的 3 个提交。
    *   **同样警告：** `git reset` (尤其是 `--hard`) 会改写历史，**只应在你尚未将这些提交推送到共享仓库时使用。**

---

### 撤销远程变更 (已 `git push`)

当你的提交已经被推送到共享仓库（如 GitHub、GitLab），情况就变得复杂了，因为其他团队成员可能已经拉取了这些提交并基于它们进行工作。**直接改写已共享的历史 (如使用 `git reset` 后强制推送 `git push --force`) 是非常危险的，通常应该避免，因为它会给团队协作带来灾难。**

以下是更安全的处理已推送变更的方法：

#### 1. 使用 `git revert`：创建一个“反向”提交

*   **核心思想：** 不删除或修改过去的提交，而是创建一个**新的提交**，这个新提交的内容是用来**抵消 (undo)** 某个历史提交所引入的更改。
*   **命令：**
    `git revert <commit-SHA-to-revert>`
    例如，如果你想撤销哈希值为 `a1e8fb5` 的提交所做的更改：
    `git revert a1e8fb5`
*   **流程：**
    1.  Git 会计算出要撤销的提交 (`a1e8fb5`) 和它的父提交之间的差异。
    2.  然后，它会应用这个差异的“反向操作”到当前工作目录和暂存区。
    3.  Git 会自动打开编辑器，让你为这个新的 "revert" 提交编写提交信息（通常会有一个默认信息，如 "Revert 'original commit message'"）。
    4.  保存并关闭编辑器，一个新的提交就创建好了。
*   **效果：**
    *   历史记录中会增加一个 revert 提交。
    *   原始的“错误”提交仍然存在于历史中，但其影响被新的 revert 提交抵消了。
    *   这是一个**安全的操作**，因为它没有改写历史，而是追加历史。其他团队成员可以正常地 `git pull` 这个新的 revert 提交。
*   **处理 revert 时的冲突：**
    如果后续的提交修改了与你要 revert 的提交相同的文件区域，`git revert` 可能会产生冲突。你需要像解决合并冲突一样手动解决它们，然后 `git add` 解决后的文件，最后 `git revert --continue` (或者 `git commit`，根据 Git 版本和提示)。如果想放弃 revert，使用 `git revert --abort`。
*   **Revert 一个合并提交：**
    Revert 一个合并提交稍微复杂一点，因为合并提交有两个父提交。你需要告诉 Git 你想保留哪条父分支的线索（即，你想撤销掉哪个分支合并进来的更改）。
    `git revert -m <parent-number> <merge-commit-SHA>`
    *   `-m 1`：表示保留第一个父提交（通常是合并时所在的主分支），撤销掉第二个父提交（被合并进来的分支）带来的更改。
    *   `-m 2`：表示保留第二个父提交，撤销掉第一个父提交带来的更改。
    通常，如果你想撤销一个错误的合并，你会用 `-m 1`。
*   **通俗理解：** 你在书里写错了一段话，并且已经出版了。你不能把已经出版的书收回来修改那一页，但你可以出一个“勘误表”（revert commit），告诉大家那一页的错误内容应该被替换成什么。

#### 2. （极不推荐，除非万不得已且与团队充分沟通）强制推送 (`git push --force` 或 `git push --force-with-lease`)

*   **场景：** 你推送了一个错误的提交（比如包含敏感信息），并且**你确定还没有其他人拉取这个提交**，或者你已经和所有团队成员协调好，可以覆盖远程历史。
*   **流程：**
    1.  在本地使用 `git reset --hard <正确的提交>` 回滚到错误提交之前的状态，或者使用 `git rebase -i` 删除/修改那个错误的提交。
    2.  然后，使用强制推送来覆盖远程仓库的历史：
        *   **`git push --force <远程仓库名> <分支名>`** (例如 `git push --force origin main`)
            *   **极度危险！** 它会无条件地用你的本地分支覆盖远程分支。如果其他人已经推送了新的提交到远程分支，那些提交会被你的强制推送覆盖掉而丢失！
        *   **`git push --force-with-lease <远程仓库名> <分支名>`** (更安全一些的强制推送)
            *   **推荐替代 `--force`。** 它在推送前会检查远程分支的 `HEAD` 是否与你本地记录的远程分支 `HEAD` 一致。如果不一致（意味着在你上次 `fetch` 之后，有人向远程分支推送了新的提交），推送就会失败，防止你无意中覆盖别人的工作。
            *   即使如此，它仍然是在改写共享历史，需要非常小心。
*   **严重警告：**
    *   **强制推送会彻底改写远程仓库的历史。**
    *   如果其他团队成员已经基于被你改写的历史进行了工作，他们的本地仓库将会与远程仓库产生严重分歧，解决起来会非常麻烦，通常需要他们进行复杂的 rebase 或 reset 操作。
    *   **只有在你百分之百确定后果，并且已经与所有相关人员沟通好的情况下，才考虑使用强制推送。**
    *   对于敏感信息泄露，除了强制推送，还应该考虑其他补救措施，比如修改密码、吊销密钥，并可能需要清理 Git 仓库历史中的大对象（使用 `git filter-branch` 或 `bfg-repo-cleaner`，这本身也是复杂且改写历史的操作）。
*   **通俗理解：** 你出版了一本书，发现里面有重大错误。你偷偷潜入所有书店和读者家里，把所有书都换成了修改后的版本。如果有人在你替换之前买了旧书并做了笔记，他们的笔记就对不上新书了。

---

**总结一下撤销变更的黄金法则：**

*   **未推送 (本地)：** 优先使用 `git commit --amend` (修改最后一次提交) 或 `git reset` (回滚提交)。这些操作改写本地历史，但因为未共享，所以是安全的。
*   **已推送 (远程)：** **首选 `git revert`**。它通过创建新提交来撤销更改，保持历史的完整性和团队协作的顺畅。
*   **强制推送 (`--force` / `--force-with-lease`)：** **如非万不得已，绝对避免。** 如果必须使用，优先选择 `--force-with-lease`，并且必须与团队充分沟通协调，确保每个人都了解并能处理后续可能出现的问题。

理解这些撤销策略以及它们适用的场景，能让你在日常开发中更有信心地处理各种“意外情况”。