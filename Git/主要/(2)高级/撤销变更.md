在 Git 中如何“撤销变更”，这绝对是每个开发者都会遇到的场景。区分**本地撤销**（变更尚未推送到共享仓库）和**远程撤销**（变更已推送到共享仓库，可能已被他人拉取）两种情况，因为它们的处理方式和影响有很大不同。

---

### 撤销本地变更 (尚未 `git push`)

这些操作通常只影响你自己的本地仓库，相对安全，可以大胆尝试（当然，理解清楚再操作总是好的）。

#### 1. 撤销工作目录中的修改 (文件未 `git add`)

*   **场景：** 你修改了一个文件，但还没执行 `git add`，现在想放弃这些修改，恢复到上次提交（或上次 `git add` 之后）的状态。
*   **命令：**
    *   **`git restore <文件名>`** (推荐，Git 2.23+ 引入的新命令，更清晰)
        `git restore my_file.txt`
    *   **`git checkout -- <文件名>`** (旧命令，但仍广泛使用)
        `git checkout -- my_file.txt`
        **注意：** `checkout` 后面必须有 `--`，否则如果 `<文件名>` 恰好和某个分支名相同，Git 会以为你要切换分支。
*   **撤销所有未暂存的修改：**
    *   `git restore .`
    *   `git checkout -- .`
*   **效果：** 文件内容会恢复到 `HEAD`（即上次提交时）的状态。**这些修改会直接丢失，无法找回（除非你的编辑器有本地历史记录功能）。**
*   **通俗理解：** 你在草稿纸上写了点东西，觉得不好，直接擦掉。

#### 2. 撤销已暂存的修改 (文件已 `git add`，但未 `git commit`)

*   **场景：** 你用 `git add` 把一些修改添加到了暂存区，但还没提交，现在想把它们从暂存区撤销出来（放回到工作目录，变成未暂存状态），或者完全放弃这些修改。
*   **命令 (仅从暂存区撤销，保留工作目录的修改)：**
    *   **`git restore --staged <文件名>`** (推荐，Git 2.23+ 新命令)
        `git restore --staged my_file.txt`
    *   **`git reset HEAD <文件名>`** (旧命令，仍广泛使用)
        `git reset HEAD my_file.txt` (这里的 `HEAD` 是可选的，默认就是 `HEAD`)
*   **撤销所有已暂存的修改 (放回工作目录)：**
    *   `git restore --staged .`
    *   `git reset HEAD .` 或 `git reset`
*   **效果：** 指定文件或所有暂存区的修改会回到工作目录，状态从未暂存。此时，如果你想彻底丢弃这些修改，可以再执行上一节的 `git restore <文件名>` 或 `git checkout -- <文件名>`。
*   **通俗理解：** 你把一些写好的草稿放到了“待提交”文件夹，现在又拿了出来，可以继续修改，也可以直接扔掉。

*   **命令 (从暂存区撤销，并且同时放弃工作目录的修改 - 一步到位)：**
    *   先执行 `git restore --staged <文件名>` （或 `git reset HEAD <文件名>`）
    *   再执行 `git restore <文件名>` （或 `git checkout -- <文件名>`）
    *   **或者，如果你确定要彻底丢弃这些已暂存的修改：**
        `git checkout HEAD -- <文件名>` (直接用上次提交的状态覆盖暂存区和工作区)
        这个命令有点像 `git restore <文件名>` 但作用于暂存区内容所对应的版本。

#### 3. 撤销最近的提交 (已 `git commit`，但未 `git push`)

*   **场景：** 你刚刚提交了一个 commit，但发现有些问题（比如提交信息写错了，或者漏了文件，或者提交了不该提交的内容），并且这个 commit 还没有推送到远程仓库。
*   **方式一：修改最后一次提交 (`git commit --amend`)**
    *   **用途：**
        *   修改提交信息。
        *   添加忘记暂存的文件。
        *   对最后一次提交的内容做小幅调整。
    *   **流程：**
        1.  (可选) 如果需要添加或修改文件：
            `git add <新文件或修改后的文件>`
        2.  执行修改：
            `git commit --amend`
            这会打开编辑器让你修改提交信息。如果不想修改提交信息，只想把新暂存的内容加进去，可以用：
            `git commit --amend --no-edit`
    *   **效果：** **它不会创建一个新的提交，而是用一个新的提交替换掉你当前的最后一次提交。** 原来的错误提交就“消失”了（实际上还在 reflog 里，但不在当前分支历史里）。
    *   **警告：** 因为它改写了历史，所以**只应在你尚未将此提交推送到共享仓库时使用。**
    *   **通俗理解：** 你刚给书稿存了个档并写了备注，发现备注写错了或漏了一页，赶紧重新存档并修改备注，覆盖掉刚才那个不满意的存档。

*   **方式二：重置到上一个提交 (`git reset`)**
    *   **用途：** 完全撤销一个或多个本地提交，就像它们从未发生过一样。
    *   **命令及模式：**
        *   **`git reset --soft HEAD^`** (或 `HEAD~1`)
            *   **效果：** 撤销了最后一次提交，但**保留**了那次提交所做的所有更改在**暂存区 (Staging Area)**。你可以重新组织这些更改，然后进行一次新的、正确的提交。
            *   **通俗理解：** 你把存档回退了一步，但所有内容都还在“待提交”文件夹里。
        *   **`git reset --mixed HEAD^`** (或 `HEAD~1`) (这是 `git reset` 的默认模式)
            *   **效果：** 撤销了最后一次提交，并且把那次提交所做的所有更改放回到了**工作目录 (Working Directory)**，状态变为未暂存。你可以修改这些文件，然后重新 `git add` 和 `git commit`。
            *   **通俗理解：** 你把存档回退了一步，并且所有内容都拿回到了你的草稿纸上，可以重新编辑。
        *   **`git reset --hard HEAD^`** (或 `HEAD~1`)
            *   **效果：** **彻底彻底地**撤销了最后一次提交，并且**丢弃**了那次提交所做的所有更改（包括工作目录和暂存区的）。你的代码库会完全恢复到倒数第二个提交的状态。
            *   **警告：这是一个破坏性操作，一旦执行，那些更改就很难找回了（除非通过 reflog，但也很麻烦）。请务必谨慎使用！**
            *   **通俗理解：** 你把存档回退了一步，并且把那一存档版本之后的所有草稿都撕掉了。
    *   **撤销多个提交：**
        你可以用 `HEAD~n` 来撤销最近的 `n` 个提交，例如 `git reset --hard HEAD~3` 会撤销最近的 3 个提交。
    *   **同样警告：** `git reset` (尤其是 `--hard`) 会改写历史，**只应在你尚未将这些提交推送到共享仓库时使用。**

---

### 撤销远程变更 (已 `git push`)

当你的提交已经被推送到共享仓库（如 GitHub、GitLab），情况就变得复杂了，因为其他团队成员可能已经拉取了这些提交并基于它们进行工作。**直接改写已共享的历史 (如使用 `git reset` 后强制推送 `git push --force`) 是非常危险的，通常应该避免，因为它会给团队协作带来灾难。**
#### 摘要：如何选择？

*   **如果这是公共分支（如 `main`, `develop`），并且已经有其他人拉取了你的变更**：**请务必使用方法一 (`git revert`)**。这是最安全、最推荐的做法。
*   **如果这是你自己的个人分支，并且你确定没有其他人拉取过这个分支**：你可以使用方法二 (`git reset` + 强推)，这能让你的提交历史更“干净”。

---

#### 方法一：使用 `git revert` (推荐，最安全的方式)

这种方法**不会修改历史记录**，而是会**创建一个新的提交**，这个新提交的内容刚好与你想撤销的那个提交内容相反。

**原理**：你犯了个错误（提交A），`git revert` 会创建一个新的“撤销提交”（提交B），把提交A所做的更改全部反向操作一遍，然后你把这个“撤销提交”B再 `push` 上去，就达到了撤销的效果。

**优点**：
*   **安全**：不会破坏 Git 的历史记录，对团队协作非常友好。
*   **清晰**：所有操作都有记录，别人能看到你撤销了一次提交。

**操作步骤**：

1.  **找到你想撤销的提交 ID (commit hash)**
    打开终端，进入你的项目目录，运行 `git log` 或 `git reflog` 来查看提交历史。

    ```bash
    git log --oneline
    # a879d9f (HEAD -> main, origin/main) Add feature Y
    # f7d4a3e Bad commit I want to revert <-- 假设要撤销这个
    # c5d2e1a Add feature X
    # ...
    ```
    复制你想要撤销的那个提交的哈希值，比如 `f7d4a3e`。

2.  **执行 `git revert`**
    运行以下命令。Git 会创建一个新的提交来撤销 `f7d4a3e` 的所有更改。

    ```bash
    git revert f7d4a3e
    ```
    *   执行后，Git 可能会弹出一个编辑器，让你为这个“撤销提交”编写提交信息。默认信息通常就足够了，可以直接保存并关闭编辑器。
    *   如果你不想编辑提交信息，可以使用 `--no-edit` 参数：`git revert f7d4a3e --no-edit`。

3.  **推送到远程仓库**
    现在你的本地仓库已经有了一个新的“撤销提交”，把它推送到远程仓库即可。

    ```bash
    git push origin main  # 将 "main" 替换为你的分支名
    ```
    完成！现在远程仓库也已经撤销了那个错误的变更。

---

#### 方法二：使用 `git reset` + 强制推送 (有风险，仅限个人分支)

**⚠️ 警告：此方法会重写远程分支的历史记录。如果其他团队成员已经拉取了这个分支，这会给他们带来巨大的麻烦。请只在确定你是唯一使用这个分支的人时才使用此方法！**

**原理**：这种方法会直接将你的分支指针（HEAD）移动回某个历史节点，丢弃掉那之后的所有提交，让历史看起来就像那些错误的提交从未发生过一样。

**优点**：
*   **历史干净**：提交记录中不会有“错误提交”和“撤销提交”。

**缺点**：
*   **危险**：会强制覆盖远程历史，严重干扰团队协作。

**操作步骤**：

1.  **找到你想回退到的那个正确的提交 ID**
    同样，使用 `git log`。这次你要找的是**错误提交之前**的那个提交。

    ```bash
    git log --oneline
    # a879d9f (HEAD -> main, origin/main) The very bad commit <-- 我们想丢弃这个
    # f7d4a3e The commit before the bad one <-- 我们想回到这里
    # c5d2e1a Some older commit
    # ...
    ```
    复制你想要回退到的那个提交的哈希值，比如 `f7d4a3e`。

2.  **执行 `git reset`**
    运行以下命令，将你的本地分支重置到指定的提交。

    ```bash
    # 使用 --hard 会彻底丢弃 "f7d4a3e" 之后的所有提交和本地文件改动
    git reset --hard f7d4a3e
    ```

3.  **强制推送到远程仓库**
    因为你的本地历史已经和远程历史不一致了（你的本地历史“落后”于远程），常规的 `git push` 会被拒绝。你需要使用强制推送来覆盖远程仓库的历史。

    ```bash
    # 使用 --force-with-lease 更安全一些，它能确保你不会覆盖掉在你上次拉取后别人推送的新提交
    git push origin main --force-with-lease

    # 或者使用更直接但更危险的 --force
    # git push origin main --force
    ```
    **强烈推荐使用 `--force-with-lease` 而不是 `-f` 或 `--force`**，因为它提供了一层安全检查。

---

#### 总结对比

| 特性       | `git revert` (推荐)                             | `git reset` + `force push` (危险) |
| :------- | :-------------------------------------------- | :------------------------------ |
| **原理**   | 创建一个“反向”的新提交                                  | 移动分支指针，删除历史提交                   |
| **历史记录** | 不会改变，是线性的、可追溯的                                | 会被重写，历史被“抹除”                    |
| **适用场景** | **所有场景**，特别是**公共/协作分支** (`main`, `develop` 等) | **仅限个人分支**，且确定无人拉取              |
| **安全性**  | **高**，对团队协作无害                                 | **低**，会严重干扰他人工作                 |

**一句话建议：如果不确定，请永远选择 `git revert`。**

---

**总结一下撤销变更的黄金法则：**

*   **未推送 (本地)：** 优先使用 `git commit --amend` (修改最后一次提交) 或 `git reset` (回滚提交)。这些操作改写本地历史，但因为未共享，所以是安全的。
*   **已推送 (远程)：** **首选 `git revert`**。它通过创建新提交来撤销更改，保持历史的完整性和团队协作的顺畅。
*   **强制推送 (`--force` / `--force-with-lease`)：** **如非万不得已，绝对避免。** 如果必须使用，优先选择 `--force-with-lease`，并且必须与团队充分沟通协调，确保每个人都了解并能处理后续可能出现的问题。

理解这些撤销策略以及它们适用的场景，能让你在日常开发中更有信心地处理各种“意外情况”。