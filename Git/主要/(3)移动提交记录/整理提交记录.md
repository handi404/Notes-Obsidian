整理提交记录是 Git 中非常重要的一个环节，它能让你的提交历史更清晰、更易于理解和维护。我们主要聊聊 `git squash` (通常通过 `git rebase -i` 实现) 和 `git cherry-pick` 这两个利器。

### 1. `git squash` (压缩合并提交)

`squash` 的核心思想是：**将多个相关的、零碎的提交合并成一个更有意义的、独立的提交。** 想象一下你写文章，可能会有很多草稿版本（"修复错字"、"调整段落"、"补充细节"），最后你会把这些修改整合进一个最终版本。`squash` 就是做这个整合工作。

**为什么需要 `squash`？**

*   **保持主干历史清晰：** 当你的功能分支有很多小的 "WIP" (Work In Progress) 提交或者修复小问题的提交时，直接合并到主分支 (`main` 或 `develop`) 会让主分支历史显得非常凌乱。`squash` 后，一个功能特性就对应一个清晰的提交。
*   **易于代码审查 (Code Review)：** 一个完整的、有意义的提交比一堆零碎的提交更容易审查。
*   **方便问题定位 (Bisect)：** 如果以后出现 bug，一个清晰的提交历史能帮助你更快地通过 `git bisect` 定位到引入问题的提交。
*   **撤销更改更简单：** 如果需要撤销某个功能，只需要 `revert` 一个合并后的提交，而不是一堆小提交。

**怎么做 `squash`？**

`squash` 通常是通过**交互式变基 (interactive rebase)** `git rebase -i` 来完成的。

假设你的提交历史如下 (最新的在上面)：

```
c7f32c9 (HEAD -> feature/my-cool-feature) feat: add awesome button animation
a4e2d1f fix: typo in button text
b3d876a WIP: button styling
1f2e3d4 feat: add awesome button
```

你希望将这4个提交合并成一个。假设这4个提交都是在 `main` 分支之后创建的，或者你想基于 `main` 分支的最新状态来整理这 4 个提交。

1.  **启动交互式变基：**
    *   如果你想合并最近的 N 个提交：`git rebase -i HEAD~4` (这里的 4 就是你要追溯的提交数量)
    *   如果你想合并当前分支从某个特定提交（比如 `main` 分支的最新点）开始的所有提交：`git rebase -i main` (假设 `main` 是你的目标基底分支)

2.  **编辑变基任务列表：**
    执行上述命令后，Git 会打开一个编辑器，显示一个任务列表，类似这样：

    ```
    pick 1f2e3d4 feat: add awesome button
    pick b3d876a WIP: button styling
    pick a4e2d1f fix: typo in button text
    pick c7f32c9 feat: add awesome button animation

    # Rebase <commit-hash-start>..<commit-hash-end> onto <commit-hash-base> (4 commands)
    #
    # Commands:
    # p, pick <commit> = use commit
    # r, reword <commit> = use commit, but edit the commit message
    # e, edit <commit> = use commit, but stop for amending
    # s, squash <commit> = use commit, but meld into previous commit
    # f, fixup <commit> = like "squash", but discard this commit's log message
    # x, exec <command> = run command (the rest of the line) using shell
    # b, break = stop here (continue rebase later with 'git rebase --continue')
    # d, drop <commit> = remove commit
    # l, label <label> = label current HEAD with a name
    # t, reset <label> = reset HEAD to a label
    # m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
    # .       create a merge commit using the original merge commit's
    # .       message (or the oneline, if no original merge commit was
    # .       specified). Use -c <commit> to reword the commit message.
    #
    # These lines can be re-ordered; they are executed from top to bottom.
    # If you remove a line here THAT COMMIT WILL BE LOST.
    # However, if you remove everything, the rebase will be aborted.
    #
    ```

    你需要修改第一列的命令。将第一个提交保留为 `pick` (或者 `p`)，后续想合并到第一个提交的，都改成 `squash` (或者 `s`)，或者 `fixup` (或者 `f`)。

    *   `squash` (或 `s`): 会将该提交的内容合并到前一个提交，并且 Git 会提示你合并编辑这些提交的 commit message。
    *   `fixup` (或 `f`): 类似 `squash`，但会直接丢弃该提交的 commit message，只保留前一个提交的 message。这对于那些 "fix typo" 或 "WIP" 类型的提交非常有用。

    修改后可能如下：

    ```
    pick 1f2e3d4 feat: add awesome button
    squash b3d876a WIP: button styling
    squash a4e2d1f fix: typo in button text
    squash c7f32c9 feat: add awesome button animation
    ```
    或者，如果你不关心中间的提交信息：
    ```
    pick 1f2e3d4 feat: add awesome button
    fixup b3d876a WIP: button styling
    fixup a4e2d1f fix: typo in button text
    fixup c7f32c9 feat: add awesome button animation
    ```

3.  **保存并关闭编辑器。**

4.  **编辑合并后的提交信息：**
    如果使用了 `squash`，Git 会再次打开编辑器，让你编辑一个新的 commit message，这个 message 将作为合并后那个唯一提交的 message。它会包含所有被 `squash` 的提交的 message，你可以按需修改、整理成一个清晰的描述。如果使用 `fixup`，则会跳过这一步。

5.  **完成！**
    你的多个提交现在变成了一个。

**最新特性/技巧：`--autosquash`**

如果你在创建修复性提交时，使用特定的 commit message 格式，如 `fixup! <commit-hash-of-commit-to-fix>` 或 `squash! <commit-hash-of-commit-to-squash>`，那么在执行 `git rebase -i --autosquash <base>` 时，Git 会自动帮你把这些 `fixup!` 和 `squash!` 提交移动到对应提交的下方，并预设好 `fixup` 或 `squash` 指令。这能省去不少手动编辑任务列表的时间。

**⚠️ 重要警告：**
*   **永远不要 `rebase` (包括 `squash`) 已经被推送到共享远程仓库并可能被他人拉取的分支上的提交！** 这样做会改写历史，导致其他协作者的本地仓库与远程仓库产生严重的分歧和冲突。
*   `squash` 最安全的场景是在你自己的私有分支或者还未推送的本地分支上进行。
*   如果你需要更新一个已经推送到远程的、但只有你个人使用的特性分支（比如用于 PR），并且你确定没有其他人基于它工作，那么在 `squash` 之后，你需要使用 `git push --force-with-lease <remote> <branch>` (比 `git push --force` 更安全) 来强制更新远程分支。在团队协作中，务必先沟通。

---

### 2. `git cherry-pick` (挑选提交)

`cherry-pick` 的核心思想是：**从一个分支中“挑选”一个或多个特定的提交，并将这些提交的变更应用到当前所在的分支上。** 就像从一堆樱桃里挑出你想要的那几颗。

**为什么需要 `cherry-pick`？**

*   **热修复 (Hotfix)：** 假设你在 `release` 分支上修复了一个紧急 bug，这个 bug 的修复也需要应用到当前的 `develop` 或 `main` 分支，但你不想合并整个 `release` 分支。这时就可以 `cherry-pick` 那个修复 bug 的提交。
*   **意外提交到错误分支：** 你不小心在 `develop` 分支上做了一个本应属于 `feature/X` 分支的提交。你可以切换到 `feature/X` 分支，然后 `cherry-pick` 那个提交过来。之后再回到 `develop` 分支将那个错误提交 `revert` 或 `reset` 掉。
*   **小功能提前/选择性合并：** 某个特性分支 (`feature/A`) 包含多个提交，但其中只有一个小改动是你当前分支 (`feature/B`) 急需的，而整个 `feature/A` 还未准备好合并。
*   **回补 (Backporting)：** 将较新版本分支中的某些功能或修复，“挑选”到较旧的、仍在维护的版本分支中。

**怎么做 `cherry-pick`？**

1.  **找到你要挑选的提交的哈希值 (commit hash)：**
    在源分支上使用 `git log` 或 `git log --oneline` 找到目标提交的完整或简短哈希值。
    例如，你在 `release` 分支发现一个修复提交 `a1b2c3d Fix critical bug`。

2.  **切换到目标分支：**
    假设你想把这个修复应用到 `main` 分支。
    `git checkout main`

3.  **执行 `cherry-pick`：**
    `git cherry-pick a1b2c3d`

    Git 会尝试将 `a1b2c3d` 这个提交所引入的变更应用到 `main` 分支，并创建一个**新的提交**。这个新提交的作者、提交信息等元数据会和原始提交保持一致，但**提交哈希值会不同**，因为它是在新的基底上、新的时间点创建的。

**处理冲突：**

如果在 `cherry-pick` 过程中发生冲突 (因为目标分支的当前状态与原始提交应用时的状态不同)，Git 会暂停，并提示你解决冲突。

1.  手动编辑冲突文件，解决冲突。
2.  `git add <resolved-file>` 将解决后的文件标记为已解决。
3.  `git cherry-pick --continue` 继续 `cherry-pick` 过程。

如果你想放弃当前的 `cherry-pick` 操作：
`git cherry-pick --abort`

**挑选多个提交：**

*   **挑选连续的多个提交：**
    `git cherry-pick <commit-hash-A>^..<commit-hash-B>`
    这会挑选从 `A` 的父提交之后开始，直到 `B` (包含 `B`) 的所有提交。注意 `A^` 表示 `A` 的前一个提交。
    更直观地，如果你想挑选 `A`, `B`, `C` (按时间顺序)，可以这样：
    `git cherry-pick A^..C` (如果 `A` 是这个系列中最早的)
    或者，如果你知道提交 `X, Y, Z`，可以：
    `git cherry-pick X Y Z` (按顺序提供哈希)

**重要注意事项：**

*   `cherry-pick` 会在当前分支创建**新的提交**，即使它们应用的是相同的变更。这意味着原始提交和被 `cherry-pick` 产生的提交有不同的哈希值。
*   过度使用 `cherry-pick` 可能表明你的分支策略或工作流程存在问题。如果频繁地在分支间 `cherry-pick` 大量提交，可能考虑使用 `merge` 或 `rebase` 会更合适。
*   与 `rebase` 不同，`cherry-pick` 本身不会改写历史（它只是在当前分支创建新提交），所以相对来说，在共享分支上操作的风险较小，但仍需谨慎，确保你理解其影响。

---

### 总结与选择

| 特性       | `git squash` (通过 `git rebase -i`) | `git cherry-pick`           |
| :------- | :-------------------------------- | :-------------------------- |
| **核心目的** | 合并整理**同一分支内**的多个提交，使其更简洁。         | 从**其他分支**挑选特定提交应用到**当前分支**。 |
| **影响范围** | 改写当前分支的历史 (哈希值会变)。                | 在当前分支创建新的提交 (哈希值不同于原始提交)。   |
| **常见场景** | 清理特性分支的提交历史，准备合并到主干。              | 热修复、小功能提前、错误提交的修正、回补。       |
| **操作对象** | 一系列连续的提交。                         | 一个或多个分散的特定提交。               |
| **对历史**  | **改写历史**，不应用于已共享的提交。              | **不改写原始分支历史**，在目标分支创建新历史。   |

理解这两者的核心目的和影响，就能在合适的场景下选择合适的工具来整理你的提交记录，让你的 Git 仓库既强大又优雅！


**`git cherry-pick` 的作用**  
`cherry-pick` 用于将一个（或多个）已有分支上的**指定提交**的改动，精确地“拷贝”到当前检出的分支上。它不会拉入整个分支的历史，只提取你关注的改动。

---

## 一、基本语法

```bash
# 将提交 abc1234 的改动应用到当前分支，自动生成一条新提交
git cherry-pick <commit-hash>
```

- `<commit-hash>` 可用全量 40 位哈希，也可用前 7～10 位唯一前缀。
    

---

## 二、常用选项

|选项|含义|
|---|---|
|`-n` 或 `--no-commit`|应用改动到工作区和暂存区，但不立即提交，方便你合并多次 cherry‑pick 后一次性提交|
|`-x`|在新提交信息末尾添加一行 `cherry picked from commit <原哈希>`，便于追溯来源|
|`-m <parent-number>`|对于 **merge 提交**，指定将哪一路父分支的改动算作主干（一般用 `1`）|
|`--abort`|若发生冲突，放弃本次 cherry‑pick，恢复到 cherry‑pick 前的状态|
|`--continue`|在解决完冲突并 `git add` 后，继续完成 cherry‑pick 提交|
|`--quit`|解决冲突后不想继续 cherry‑pick，结束序列但保留冲突状态|

---

## 三、批量 cherry‑pick

1. **连续区间**
    
    ```bash
    git cherry-pick A..B
    ```
    
    等价于依次 cherry‑pick 从 `A`（不含）到 `B`（含）之间的所有提交。
    
2. **指定多个非连续提交**
    
    ```bash
    git cherry-pick hash1 hash2 hash3
    ```
    
    按给定顺序一条条执行。
    
3. **交互式重放**  
    有时你想按某种排序或筛选后再挑拣，可先在临时分支上 `git rebase -i` 编辑成理想顺序，再 cherry‑pick 到目标分支。
    

---

## 四、冲突处理流程

1. 执行 `git cherry-pick`，遇冲突时 Git 会停止并提示冲突文件。
    
2. 编辑并解决冲突（手动或借助工具）。
    
3. `git add <conflicted-files>` 标记已解决。
    
4. `git cherry-pick --continue` 完成提交；若想中止，`git cherry-pick --abort`。
    

---

## 五、最佳实践与注意事项

- **只拣改动，不带杂历史**：适合把某个 bug 修复或小功能从旧分支补丁到新分支。
    
- **保留来源信息**：加 `-x` 便于后续审计和追溯。
    
- **避免滥用**：频繁 cherry‑pick 会让多个分支上出现相似但哈希不同的提交，增加合并时的冲突概率。
    
- **冲突多时考虑合并或 rebase**：如果一整段开发都需要同步，合并（`merge`）或变基（`rebase`）更高效。
    
- **公共分支慎改写**：生成的新提交会改变分支结构，若对方也 cherry‑pick 或合并过原提交，可能导致重复或冲突。
    

---

## 六、示例演练

```bash
# 1. 在 feature 分支上发现了一个 bug 修复提交 abc1234
git switch feature

# 2. 切回 main 分支，准备把这个修复“摘樱桃”
git switch main

# 3. 精确拷贝并保留来源
git cherry-pick -x abc1234

# 4. 若遇冲突，解决后：
#    git add <文件>
#    git cherry-pick --continue

# 5. 最后推送到远端
git push origin main
```

通过以上介绍，相信你已掌握 `git cherry-pick` 的核心概念、用法和注意事项。