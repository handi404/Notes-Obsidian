“本地栈式提交”（Local Stacked Commits）是一个非常好的实践，尤其在进行较大功能开发或者希望代码审查更清晰时。它指的是在本地创建一个由多个小型、原子性、逻辑清晰的提交组成的“栈”，这些提交通常基于一个共同的基础（比如 `main` 分支或 `develop` 分支），并且是线性发展的。

这与交互式 Rebase (`git rebase -i`) 密切相关，因为交互式 Rebase 是管理和维护这种提交栈的重要工具。

---

### 什么是本地栈式提交？

*   **核心概念：**
    栈式提交是指你在本地开发一个特性时，不把所有的改动都塞进一个或几个巨大的提交里，而是将特性分解为一系列逻辑上独立的、小而专注的步骤，每个步骤都对应一个独立的提交。这些提交像叠盘子一样一个接一个地堆叠起来，形成一个“提交栈”。
*   **通俗理解：**
    想象你在搭乐高积木来建造一个复杂的模型（你的新功能）。
    *   **非栈式提交 (大坨提交)：** 你把所有积木一股脑儿地拼好，最后形成一个完整的模型，然后说“完成了！”（一个巨大的 commit）。如果中间某一步错了，或者别人想理解你是怎么搭的，会很困难。
    *   **栈式提交：** 你先搭好底座（第一个 commit），然后搭好墙体（第二个 commit），再搭好屋顶（第三个 commit），以此类推。每一步都是一个独立的、可验证的、有明确目的的小成果。别人看你的搭建过程（提交历史）会非常清晰，如果发现屋顶搭错了，也更容易定位和修改屋顶那一步，而不影响底座和墙体。
*   **栈的结构：**
    通常，这个“栈”会从一个稳定的基础分支（如 `main` 或 `develop`）的最新状态开始。
    ```
              o --- o --- o  (feature-branch / HEAD) <- Commit C (e.g., Add tests)
             /
            o --- o --- o  (feature-branch^ / HEAD^) <- Commit B (e.g., Implement core logic)
           /
          o --- o --- o  (feature-branch^^ / HEAD~2) <- Commit A (e.g., Setup initial files)
         /
    ...-o --- o --- o (main / base branch)
    ```
    这里，Commit A, B, C 组成了一个提交栈。

---

### 为什么要使用本地栈式提交？

1.  **更清晰的提交历史：**
    *   每个提交都有一个明确的目的和小的范围，使得代码历史非常容易阅读和理解。
    *   别人（或者未来的你）可以快速了解每个变更的意图。

2.  **更容易的代码审查 (Code Review)：**
    *   将一个大的功能拆分成多个小的、逻辑独立的提交，可以让审查者逐个审查。
    *   审查者更容易理解每个小块的改动，提供更精确的反馈。
    *   如果某个小提交有问题，也更容易定位和修改，而不需要重新审查整个大功能。
    *   许多代码审查工具（如 GitHub Pull Requests）能很好地展示这种栈式提交，并允许对单个提交进行评论。

3.. **更方便的调试和回滚 (`git bisect`, `git revert`)：**
    *   如果引入了 Bug，原子性的提交使得使用 `git bisect` 快速定位引入 Bug 的提交变得非常容易。
    *   如果需要撤销某个特定的改动，`git revert` 一个小提交比 revert 一个包含很多不相关改动的大提交要简单和安全得多。

4.  **逐步构建和测试：**
    *   你可以确保每个提交都是一个可工作的、通过测试的单元（理想情况下）。
    *   这鼓励了持续集成的心态，即使是在本地。

5.  **灵活的重组和修改：**
    *   在推送之前，你可以使用交互式 Rebase (`git rebase -i`) 轻松地：
        *   **重新排序 (reorder)** 提交的顺序，如果逻辑上更合理。
        *   **合并 (squash/fixup)** 一些过于零碎的 "WIP" 或修复性提交。
        *   **修改 (reword)** 提交信息使其更清晰。
        *   **编辑 (edit)** 某个提交的内容。
        *   **拆分 (split)** 某个过大的提交。

6.  **减少合并冲突的复杂性：**
    *   当需要从基础分支（如 `main`）拉取更新到你的特性分支时，如果你的特性分支是栈式提交，`git rebase main` 会逐个应用你的小提交到新的 `main` 之上。如果发生冲突，冲突通常会局限在某个小提交内，更容易解决。

---

### 如何实践本地栈式提交？

1.  **计划你的工作：**
    *   在开始编码之前，花点时间思考如何将大的功能或任务分解成一系列逻辑上独立的、可管理的步骤。每个步骤都可以成为一个提交。

2.  **小步提交，频繁提交：**
    *   当你完成了一个小的、逻辑完整的改动单元后，就创建一个提交。
    *   编写清晰、简洁且有意义的提交信息，遵循团队的提交规范（如 Conventional Commits）。

3.  **保持分支与基础分支同步 (使用 Rebase)：**
    *   定期从你的基础分支（如 `main` 或 `develop`）获取更新，并使用 `git rebase <base_branch>` 将你的提交栈变基到最新的基础上。
        ```bash
        # 假设你在 feature-branch 上
        git fetch origin
        git rebase origin/main # 或者你使用的基础分支
        ```
    *   这有助于尽早发现和解决冲突，并保持你的提交栈是基于最新代码的。

4.  **使用交互式 Rebase 进行整理 (`git rebase -i`)：**
    *   在准备将你的提交栈推送到远程或发起 Pull Request 之前，使用 `git rebase -i <base>` (例如 `git rebase -i origin/main`) 来审查和整理你的提交。
    *   **常见整理操作：**
        *   `fixup`: 合并小的修复提交到它们对应的主要提交，并丢弃修复提交的信息。
        *   `squash`: 合并多个相关提交，并编辑一个新的合并后的提交信息。
        *   `reword`: 修改提交信息。
        *   `reorder`: 调整提交顺序。
        *   `drop`: 删除不必要的提交。
    *   目标是让你的提交栈在逻辑上清晰、每个提交都有价值且易于理解。

5.  **推送你的提交栈 (如果适用)：**
    *   如果你的团队工作流允许或鼓励推送特性分支的完整提交历史（例如，用于 Pull Request 中的逐个提交审查），那么你可以直接推送你的分支。
    *   **注意：** 如果你在推送后又对已推送的提交栈进行了 rebase (改写历史)，你需要使用 `git push --force-with-lease`。**这必须非常小心，并确保你的团队成员了解这种工作流。** 有些团队更倾向于在合并到主分支前将特性分支 squash 成一个提交。

---

### 示例工作流

假设你在开发一个用户注册功能 (`feature/user-registration`)，基础分支是 `main`。

1.  `git switch -c feature/user-registration main` (创建并切换到新分支)
2.  **Commit 1:** `feat: Add basic User model and database migration`
    *   创建用户模型类。
    *   创建数据库表结构迁移脚本。
3.  **Commit 2:** `feat: Implement user registration form UI`
    *   添加 HTML 表单。
    *   添加基本样式。
4.  **Commit 3 (临时):** `fix: Correct typo in form label` (一个小修复)
5.  **Commit 4:** `feat: Implement backend logic for user registration`
    *   添加处理表单提交的后端路由和控制器。
    *   实现数据验证和用户创建逻辑。
6.  **Commit 5:** `test: Add unit tests for user registration service`
    *   为用户注册服务编写单元测试。

**在准备推送或发起 PR 前，进行整理：**

`git rebase -i origin/main` (假设 `origin/main` 是最新的基础)

在打开的 "todo" 列表里，你可能会这样做：

```
pick <hash_commit_1> feat: Add basic User model and database migration
pick <hash_commit_2> feat: Implement user registration form UI
fixup <hash_commit_3> fix: Correct typo in form label  # 将这个小修复合并到 UI 提交中
pick <hash_commit_4> feat: Implement backend logic for user registration
pick <hash_commit_5> test: Add unit tests for user registration service
```

保存并关闭，Git 会将 `Commit 3` 合并到 `Commit 2` 中，并丢弃 `Commit 3` 的信息。最终你的提交栈会更整洁。

---

### 工具和技巧

*   **`git rebase -i --autosquash` 和 `git commit --fixup/--squash`：**
    *   当你创建一个提交，只是为了修复前一个提交（比如 `HEAD~1`）的小问题时，你可以：
        `git commit --fixup HEAD~1`
    *   或者你想合并到前一个提交并修改提交信息：
        `git commit --squash HEAD~1`
    *   然后，当你执行 `git rebase -i --autosquash <base>` 时，Git 会自动在 "todo" 列表里把这些 `fixup!` 和 `squash!` 提交移动到它们目标提交的下方，并自动设置好 `fixup` 或 `squash` 命令。这能节省很多手动编辑 "todo" 列表的时间。
*   **清晰的提交信息：** 这是栈式提交成功的关键。每个提交信息都应该清楚地说明该提交做了什么。
*   **专注：** 每个提交应该只做一件事。

---

栈式提交是一种优秀的开发习惯，它能显著提高代码质量、协作效率和项目可维护性。虽然初期可能需要一些练习来适应这种思维方式和 `git rebase -i` 的使用，但长远来看，收益巨大。