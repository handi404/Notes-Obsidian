Git 提交 (`git commit`) 相关的多个技巧，这些技巧能帮助你更高效、更规范地管理你的提交历史，提升代码质量和团队协作效率。

---

### 1. 编写优秀的提交信息 (Commit Messages)

这是最重要但也常常被忽视的技巧。好的提交信息是项目可维护性的基石。

*   **遵循规范 (如 Conventional Commits)：**
    *   **格式：** `<type>(<scope>): <subject>`
        *   `type`: 提交的类型，如 `feat` (新功能), `fix` (bug修复), `docs` (文档), `style` (代码格式), `refactor` (重构), `test` (测试), `chore` (构建、辅助工具等)。
        *   `scope` (可选): 指明本次提交影响的范围，如模块名、文件名等。
        *   `subject`: 简短描述本次提交的目的，动词开头，祈使句，首字母小写，末尾不加句号。
    *   **示例：**
        `feat(auth): implement user login endpoint`
        `fix(parser): handle empty input gracefully`
        `docs(readme): update installation instructions`
    *   **好处：**
        *   清晰易懂，快速了解提交内容。
        *   便于自动化工具生成 CHANGELOG。
        *   方便按类型或范围筛选和搜索提交。

*   **结构化提交信息 (Header, Body, Footer)：**
    *   **Header (Subject Line):** 如上所述，简洁明了，不超过 50-72 个字符。
    *   **Body (可选):** 空一行后，详细描述“为什么”做这个修改，以及修改的“上下文”和“思路”，而不是“怎么做”的（代码本身会说明怎么做）。每行建议不超过 72 个字符，便于阅读。
    *   **Footer (可选):** 空一行后，可以包含一些元数据，如：
        *   `BREAKING CHANGE: <description>` (如果是不兼容的变更)
        *   `Closes #123`, `Fixes #456` (关联 Issue Tracker 中的问题)
        *   `Reviewed-by: Name <email>` (代码审查者信息)
    *   **示例：**
        ```
        feat: Add rate limiting to public API

        To prevent abuse and ensure fair usage of our public API,
        this commit introduces a rate limiting mechanism based on IP address.

        The default limit is set to 100 requests per minute per IP.
        This can be configured via the `API_RATE_LIMIT` environment variable.

        Closes #789
        BREAKING CHANGE: Requests exceeding the rate limit will now receive a 429 status code instead of being processed.
        ```

*   **使用编辑器编写提交信息：**
    *   直接运行 `git commit` (不带 `-m`) 会打开你配置的文本编辑器。这为你提供了足够的空间来编写结构化的提交信息。
    *   配置 Git 使用你喜欢的编辑器：`git config --global core.editor "code --wait"` (VS Code 示例)

### 2. 精细化暂存 (`git add -p` 或 `git add -i`)

不要一次性 `git add .` 所有修改，特别是当一个文件里有多个不相关的改动时。

*   **`git add -p` (patch mode)：**
    *   Git 会逐块 (hunk) 显示你的修改，并询问你是否要暂存该块。
    *   常用选项：
        *   `y`: 暂存此块 (yes)
        *   `n`: 不暂存此块 (no)
        *   `s`: 拆分此块为更小的块 (split, 如果 Git 能做到)
        *   `e`: 手动编辑此块 (edit, 强大的功能，可以精确选择要暂存的行)
        *   `q`: 退出暂存 (quit)
        *   `?`: 显示帮助
    *   **好处：** 确保每个提交只包含相关的、原子性的更改，有助于形成栈式提交。

*   **`git add -i` (interactive mode)：**
    *   提供一个交互式菜单，可以选择文件、块进行暂存、撤销暂存等操作。功能比 `-p` 更全面一些，但 `-p` 通常更直接。

### 3. 修改最后一次提交 (`git commit --amend`)

前面已经详细讲过，这里再强调其重要性。

*   **用途：**
    *   修改最后一次提交的提交信息。
    *   向最后一次提交中添加忘记暂存的文件或修改。
    *   对最后一次提交的内容做细微调整。
*   **命令：**
    *   `git commit --amend` (修改信息和内容)
    *   `git commit --amend --no-edit` (只添加新暂存的内容，不修改信息)
*   **注意：** 只用于尚未推送的本地提交。

### 4. 创建“修复型”提交并自动合并 (`--fixup`, `--squash` 配合 `rebase -i --autosquash`)

这是实现干净栈式提交的利器。

*   **场景：** 你刚提交了一个 `feat: Implement feature X`，然后发现一个小笔误或需要一个小调整。
*   **传统做法：** 创建一个 `fix: Correct typo in feature X` 的提交，然后用 `rebase -i` 手动 `fixup` 或 `squash`。
*   **更优做法：**
    1.  修改代码。
    2.  `git add <fixed_file>`
    3.  `git commit --fixup <hash_of_feature_X_commit>` (或者 `--fixup HEAD` 如果是修复上一个提交)
        *   Git 会自动创建一个提交，提交信息是 `fixup! feat: Implement feature X`。
    4.  当你准备好整理提交栈时，运行：
        `git rebase -i --autosquash <base_commit_before_feature_X>`
        Git 会自动在 "todo" 列表里将这个 `fixup!` 提交移动到它目标提交的下方，并将其命令设置为 `fixup`。你只需要保存退出即可。
*   **`--squash <commit>`：** 类似 `--fixup`，但提交信息会是 `squash! <original_message>`，并且在 rebase 时会提示你合并提交信息。

### 5. 提交空提交 (`git commit --allow-empty`)

有时你可能需要创建一个没有代码更改的提交。

*   **用途：**
    *   触发 CI/CD 流水线（如果流水线是基于新提交触发的）。
    *   在 rebase 过程中作为标记点或分割点。
    *   记录一个重要的项目里程碑或决定，即使没有代码变更。
*   **命令：**
    `git commit --allow-empty -m "chore: Trigger CI build for release candidate"`

### 6. 利用提交模板 (`commit.template`)

可以为项目或全局配置一个提交模板，帮助团队成员编写符合规范的提交信息。

1.  **创建模板文件** (例如 `~/.gitmessage.txt` 或项目下的 `.gitmessage`):
    ```
    # <type>(<scope>): <Subject (max 50 chars)>
    #
    # <Body: Why this change is made, context, etc.>
    #
    # <Footer: BREAKING CHANGE, Closes #, etc.>
    ```
2.  **配置 Git 使用此模板：**
    *   全局：`git config --global commit.template ~/.gitmessage.txt`
    *   项目级：`git config commit.template .gitmessage` (需要将 `.gitmessage` 文件提交到仓库)
3.  **效果：** 当你运行 `git commit` (不带 `-m`) 时，编辑器会预先填入模板内容，引导你填写。

### 7. 签署提交 (`git commit -S`)

为了增加提交的信任度和可验证性，可以使用 GPG (GNU Privacy Guard) 密钥签署你的提交。

*   **配置：**
    1.  生成或导入 GPG 密钥。
    2.  告诉 Git 使用哪个密钥：`git config --global user.signingkey <YOUR_GPG_KEY_ID>`
    3.  (可选) 总是签署提交：`git config --global commit.gpgsign true`
*   **提交时签署：**
    *   如果配置了 `commit.gpgsign true`，所有提交会自动签署。
    *   手动签署：`git commit -S -m "feat: Implement secure feature"`
*   **验证：**
    *   `git log --show-signature`
    *   GitHub/GitLab 等平台会显示 "Verified" 标记。

### 8. 理解 `git commit -a` (不推荐作为常规操作)

*   `git commit -a -m "message"` 等同于：
    1.  `git add <所有已跟踪且已修改的文件>` (它不会添加新创建的未跟踪文件)
    2.  `git commit -m "message"`
*   **为什么不推荐？**
    *   它绕过了 `git add -p` 或仔细 `git add` 的步骤，容易将不相关的修改混入一个提交。
    *   不利于培养原子性提交的习惯。
*   **何时可能用？**
    *   对于非常小、确定无疑的修改，且你确信所有已跟踪文件的修改都属于这个提交。但依然建议先 `git status` 和 `git diff` 确认。

### 9. 利用 `HEAD` 和相对引用进行提交

*   `git commit --fixup HEAD`：快速为上一个提交创建一个 fixup 提交。
*   `git commit --squash HEAD~2`：为倒数第二个提交创建一个 squash 提交。

### 10. 提交时附带日期 (`git commit --date`)

有时，你可能想指定提交的日期，而不是使用当前时间（例如，导入旧项目历史）。

*   `git commit --date="2023-01-15T10:00:00+0800" -m "Historic commit"`
*   **注意：** 这会影响提交的 AuthorDate，但 CommitterDate 通常还是当前时间，除非配合修改环境变量 `GIT_COMMITTER_DATE`。在 rebase 或 filter-branch 等操作中，AuthorDate 通常会被保留，CommitterDate 会更新。

---

这些提交技巧可以帮助你更精细、更有效地控制你的提交历史。核心思想是**保持提交的原子性、清晰性和可追溯性**。选择适合你和团队工作流的技巧，并养成良好的提交习惯，将使你的 Git 使用体验和项目管理水平更上一层楼。