Checkout commit    Revert commit    Reset commit

在 Git 中，`checkout`、`revert` 和 `reset` 是三个不同的命令，用于在不同场景下操作提交（Commit）。理解它们的用途和区别非常重要。以下是它们的详细解释：

### 1. **`git checkout`：检出 Commit**

`git checkout` 命令用于切换到某个特定的提交、分支或文件状态。
**回到过去查看某个特定提交的代码状态**
#### 场景 1：检出到某个提交（“分离的 HEAD”状态）
```bash
git checkout <commit_hash>
git checkout master
```
- **作用**：将当前工作区切换到指定的提交上，这会导致你进入“分离的 HEAD”状态（Detached HEAD）。在这个状态下，你可以查看和编辑这个特定的提交，但如果你在此基础上进行新的提交，它们不会附加到任何分支上，除非你创建一个新分支。

- **用途**：通常用于查看或调试历史提交，或者从某个历史状态开始创建一个新分支。

#### 场景 2：检出到某个分支
```bash
git checkout <branch_name>
```
- **作用**：将工作区切换到指定的分支。这个操作会使 HEAD 指向目标分支的最新提交，同时更新工作区的文件。

- **用途**：在不同分支之间切换，进行开发或测试。

### 2. **`git revert`：还原 Commit**

`git revert` 命令用于创建一个新的提交，该提交会**撤销指定的历史提交的更改**。它不会修改历史记录，而是通过创建一个新的提交来反向应用指定提交的更改。

```bash
git revert <commit_hash>
```

- **作用**：生成一个新的提交，该提交的内容是指定提交的反操作。与 `git reset` 不同，它不会删除历史记录，而是显式地将撤销操作记录在历史中。

- **用途**：用于在需要撤销某个提交的更改，但希望保留历史记录时。特别是在已经将代码推送到共享仓库后，这种方式是更安全的做法。

- **示例**：假设你有一个提交添加了一个文件，现在你想撤销这个提交(不想要这个文件了)，而保留 log 记录，那么你可以使用 `git revert`，这会创建一个新的提交删除该文件。

### 3. **`git reset`：重置 Commit**

`git reset` 命令用于重置当前分支的 HEAD 到指定的提交位置，可以影响暂存区和工作区的状态。`git reset` 有三种常用的模式：

#### 场景 1：`--soft` 重置
```bash
git reset --soft <commit_hash>
```
- **作用**：将 HEAD 重置到指定的提交，但保留暂存区和工作区的修改。这意味着你可以重新提交或调整之前的更改。

- **用途**：当你想要合并多个提交或改变提交历史时很有用。

#### 场景 2：`--mixed` 重置（默认）
```bash
git reset --mixed <commit_hash>
```
- **作用**：将 HEAD 重置到指定的提交，并将更改从暂存区移除，但保留在工作区中。这样你可以在未暂存的状态下查看和修改这些文件。

- **用途**：当你需要撤销一些已经暂存的更改，但希望保留这些更改在工作区中以便修改时使用。

#### 场景 3：`--hard` 重置
```bash
git reset --hard <commit_hash>
```
- **作用**：将 HEAD 重置到指定的提交，且同时重置暂存区和工作区。所有的更改（无论是否暂存）都会被丢弃，工作区将恢复到指定提交时的状态。

- **用途**：当你想要彻底回滚到某个提交，并放弃之后的所有更改时使用。

- **注意**：`git reset --hard` 是一个危险的操作，因为它会删除所有未保存的工作区更改和提交后的更改，这些内容将不可恢复。

### 4. **总结**

- **`git checkout`**：用于切换分支或检出特定的提交，用于查看或操作历史状态。
  
- **`git revert`**：通过创建新的提交来撤销某个提交的更改，适用于已经推送到远程仓库的场景，确保不破坏历史记录。

- **`git reset`**：重置当前分支到特定的提交，可以选择保留或删除暂存区和工作区的更改。适用于需要修改提交历史或撤销本地更改的场景。