在 **Kotlin Exposed** 中，`transaction {}` 是操作数据库的核心块，它提供了一个 **事务性上下文**，确保你的操作在同一个事务中完成并且可以回滚。Exposed 的 DSL 提供了许多常用方法用于查询和操作数据库表。下面是一些在 `transaction {}` 块中常用的方法及其详解：

---

### **1. 插入数据**

#### **`insert {}`**

- 用于向表中插入一行数据。
- 返回一个 `InsertStatement<Number>` 对象，可以获取插入的主键或其他信息。

**示例：**

```kotlin
val id = transaction {
    Users.insert {
        it[name] = "Alice"
        it[email] = "alice@example.com"
    }[Users.id] // 获取插入的主键 ID
}
println("插入的主键 ID 是: $id")
```

---

#### **`insertAndGetId {}`**

- 简化版的 `insert`，直接返回插入行的主键。

**示例：**

```kotlin
val id = transaction {
    Users.insertAndGetId {
        it[name] = "Bob"
        it[email] = "bob@example.com"
    }
}
println("插入行的主键 ID 是: $id")
```

---

### **2. 更新数据**

#### **`update`**

- 用于更新表中的记录。
- 返回值是被修改的行数。

**示例：**

```kotlin
val updatedRows = transaction {
    Users.update({ Users.name eq "Alice" }) {
        it[email] = "alice.new@example.com"
    }
}
println("更新的行数: $updatedRows")
```

---

### **3. 删除数据**

#### **`deleteWhere`**

- 删除符合条件的记录。
- 返回值是被删除的行数。

**示例：**

```kotlin
val deletedRows = transaction {
    Users.deleteWhere { Users.name eq "Alice" }
}
println("删除的行数: $deletedRows")
```

---

### **4. 查询数据**

#### **`select`**

- 用于从表中查询符合条件的记录。
- 返回一个 `Query` 对象，可以通过迭代来处理结果。

**示例：**

```kotlin
val users = transaction {
    Users.select { Users.id greaterEq 1 }
        .map { it[Users.name] }
}
println("查询结果: $users")
```

---

#### **`selectAll`**

- 查询表中所有记录。
- 返回一个 `Query` 对象。

**示例：**

```kotlin
val allUsers = transaction {
    Users.selectAll().map { it[Users.name] }
}
println("所有用户: $allUsers")
```

---

#### **`single`**

- 查询结果的单行值，如果结果有多行会抛出异常。

**示例：**

```kotlin
val user = transaction {
    Users.select { Users.id eq 1 }.single()
}
println("用户: ${user[Users.name]}")
```

---

#### **`firstOrNull`**

- 获取查询的第一条记录，如果没有结果返回 `null`。

**示例：**

```kotlin
val firstUser = transaction {
    Users.selectAll().firstOrNull()
}
println("第一个用户: ${firstUser?.get(Users.name)}")
```

---

### **5. 聚合操作**

#### **`count`**

- 统计符合条件的行数。

**示例：**

```kotlin
val userCount = transaction {
    Users.selectAll().count()
}
println("用户总数: $userCount")
```

---

#### **`sum`, `avg`, `min`, `max`**

- 对某列进行求和、平均值、最小值、最大值。

**示例：**

```kotlin
val totalAge = transaction {
    Users.slice(Users.age.sum()).selectAll().first()[Users.age.sum()]
}
println("年龄总和: $totalAge")
```

---

### **6. 批量操作**

#### **`batchInsert`**

- 用于批量插入多行数据。

**示例：**

```kotlin
val data = listOf(
    "Alice" to "alice@example.com",
    "Bob" to "bob@example.com"
)

transaction {
    Users.batchInsert(data) { (name, email) ->
        this[Users.name] = name
        this[Users.email] = email
    }
}
```

---

### **7. 表结构操作**

#### **`SchemaUtils.create`**

- 创建表。如果表已经存在，不会重复创建。

**示例：**

```kotlin
transaction {
    SchemaUtils.create(Users)
}
```

---

#### **`SchemaUtils.drop`**

- 删除表。

**示例：**

```kotlin
transaction {
    SchemaUtils.drop(Users)
}
```

---

### **8. 事务控制**

#### **`transaction`**

- 开启一个事务，并在事务结束后提交。
- 如果事务中发生异常，会自动回滚。

**示例：**

```kotlin
transaction {
    Users.insert {
        it[name] = "Charlie"
        it[email] = "charlie@example.com"
    }
    // 如果抛出异常，所有操作将被回滚
}
```

---

#### **`exec`**

- 直接执行原始 SQL 语句。

**示例：**

```kotlin
transaction {
    exec("ALTER TABLE Users ADD COLUMN phone_number VARCHAR(15)")
}
```

---

#### **嵌套事务**

- 事务可以嵌套，内层事务的回滚不会影响外层事务。

**示例：**

```kotlin
transaction {
    Users.insert {
        it[name] = "Outer Transaction"
    }
    transaction {
        Users.insert {
            it[name] = "Inner Transaction"
        }
        rollback() // 内层回滚
    }
    // 外层事务的插入依然有效
}
```

---

### **总结**

在 `transaction {}` 中，常用的方法可以分为以下几类：

1. **表操作**：`SchemaUtils.create`, `SchemaUtils.drop`
2. **数据操作**：`insert`, `update`, `deleteWhere`, `select`, `selectAll`
3. **批量操作**：`batchInsert`
4. **聚合操作**：`count`, `sum`, `avg`, `min`, `max`
5. **事务控制**：`transaction`, `rollback`, 嵌套事务
6. **直接执行 SQL**：`exec`

你可以根据实际需求选择合适的方法，并灵活运用 `transaction` 提供的一致性和回滚机制。