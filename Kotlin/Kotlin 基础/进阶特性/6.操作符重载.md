### **Kotlin 中的操作符重载详解**
[[操作符重载的适用]]
Kotlin 支持操作符重载，使开发者可以为自定义的类定义操作符的行为。这一特性通过函数来实现，即通过定义特定名称的函数并使用 `operator` 修饰符，让操作符的行为与这些函数关联。

---

## **1. 什么是操作符重载？**

操作符重载是指在 Kotlin 中，可以通过实现特定的函数来自定义标准操作符（如 `+`, `-`, `*`, `/`, `[]` 等）的行为。

例如：

- `+` 操作符对应函数 `plus`。
- `-` 操作符对应函数 `minus`。
- `[]` 操作符对应函数 `get` 和 `set`。

### 示例：

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}

fun main() {
    val p1 = Point(2, 3)
    val p2 = Point(4, 5)
    val p3 = p1 + p2 // 调用了 p1.plus(p2)
    println(p3) // 输出：Point(x=6, y=8)
}
```

---

## **2. 支持重载的操作符**

以下是 Kotlin 中支持重载的操作符及其对应的函数：

| **操作符**  | **函数名称**      | **用途** |
| -------- | ------------- | ------ |
| `+`      | `plus`        | 加法     |
| `-`      | `minus`       | 减法     |
| `*`      | `times`       | 乘法     |
| `/`      | `div`         | 除法     |
| `%`      | `rem` 或 `mod` | 取模     |
| `==`     | `equals`      | 比较相等性  |
| `<`      | `compareTo`   | 比较大小   |
| `[]`     | `get`, `set`  | 索引操作   |
| `()`     | `invoke`      | 函数调用操作 |
| `..`     | `rangeTo`     | 范围操作   |
| `in`     | `contains`    | 检查是否包含 |
| `+=`     | `plusAssign`  | 加法赋值   |
| `-=`     | `minusAssign` | 减法赋值   |
| `*=`     | `timesAssign` | 乘法赋值   |
| `/=`     | `divAssign`   | 除法赋值   |
| `%=`     | `remAssign`   | 取模赋值   |
| `unary-` | `unaryMinus`  | 一元负号   |
| `unary+` | `unaryPlus`   | 一元正号   |
| `!`      | `not`         | 逻辑取反   |
| `++`     | `inc`         | 自增     |
| `--`     | `dec`         | 自减     |

---

## **3. 如何实现操作符重载**

操作符重载通过实现特定的函数并添加 `operator` 修饰符来实现。

### 示例 1：实现加法 `+`

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}

fun main() {
    val p1 = Point(1, 2)
    val p2 = Point(3, 4)
    val p3 = p1 + p2 // 等同于 p1.plus(p2)
    println(p3) // 输出：Point(x=4, y=6)
}
```

### 示例 2：实现一元操作符 `-`

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun unaryMinus(): Point {
        return Point(-x, -y)
    }
}

fun main() {
    val p1 = Point(1, 2)
    val p2 = -p1 // 等同于 p1.unaryMinus()
    println(p2) // 输出：Point(x=-1, y=-2)
}
```

### 示例 3：实现比较操作符 `<` 和 `==`

```kotlin
data class Person(val name: String, val age: Int) {
    operator fun compareTo(other: Person): Int {
        return this.age - other.age
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Person) return false
        return this.name == other.name && this.age == other.age
    }
}

fun main() {
    val person1 = Person("Alice", 25)
    val person2 = Person("Bob", 30)
    println(person1 < person2) // 输出：true
    println(person1 == person2) // 输出：false
}
```

### 示例 4：实现索引操作符 `[]`

```kotlin
class Matrix(private val data: Array<Array<Int>>) {
    operator fun get(row: Int, col: Int): Int {
        return data[row][col]
    }

    operator fun set(row: Int, col: Int, value: Int) {
        data[row][col] = value
    }
}

fun main() {
    val matrix = Matrix(arrayOf(arrayOf(1, 2), arrayOf(3, 4)))
    println(matrix[0, 1]) // 输出：2
    matrix[0, 1] = 5
    println(matrix[0, 1]) // 输出：5
}
```

---

## **4. 使用场景**

### **a. 简化自定义类的操作**

操作符重载可以让自定义类与内置类型一样优雅地使用。例如：

- 数学运算类（如 `Matrix`, `Vector`）可以使用 `+`, `-`, `*`, `/`。
- 集合类可以使用 `in` 检查元素是否存在。

### **b. 增强代码可读性**

通过操作符重载，可以更直观地表示逻辑。例如：

```kotlin
val range = 1..10 // 使用 rangeTo 操作符
```

### **c. 自定义 DSL（领域特定语言）**

操作符重载是 Kotlin 支持 DSL 设计的重要基础。例如：

- 自定义 `invoke` 函数让对象像函数一样被调用。

---

## **5. 注意事项**

1. **避免滥用**：操作符重载可能会让代码过于复杂和难以理解，特别是在重载行为不直观时。例如，不建议让 `+` 实现非加法逻辑。
    
2. **遵循语义一致性**：重载操作符时，尽量让行为与该操作符的常见语义保持一致（如 `+` 表示加法）。
    
3. **性能考虑**：
    
    - 操作符重载本质上是函数调用，过于复杂的重载可能增加函数调用开销。
    - 如果是性能敏感的场景，可结合内联函数优化。

---

## **6. 总结**

- **操作符重载的本质**：在 Kotlin 中，操作符只是调用特定的函数，编译器将操作符翻译为对应的函数调用。
- **优点**：
    1. 提升代码可读性。
    2. 让自定义类与内置类型的使用方式一致。
    3. 支持更优雅的 DSL 设计。
- **缺点**：
    1. 滥用可能导致代码难以维护。
    2. 在设计时需要特别注意语义一致性。

通过合理使用操作符重载，开发者可以让代码更优雅、更具表达力，但需谨慎使用以保持代码的清晰性。