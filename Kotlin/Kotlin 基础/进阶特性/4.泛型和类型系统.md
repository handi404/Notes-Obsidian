### **Kotlin 泛型和类型系统详解**

---

Kotlin 的泛型和类型系统是其强大而灵活的一部分，它允许代码在保证类型安全的同时实现更高的复用性和灵活性。在这一章中，我们将深入讲解 **泛型（Generics）** 的概念及其在 Kotlin 中的使用，以及 Kotlin 类型系统中的重要特性。

---

## **1. 泛型基础**

### **1.1 什么是泛型？**

泛型是一种用于编写类型安全、灵活代码的技术，允许类、接口或函数在声明时不指定具体的数据类型，而是使用 **类型参数** 来代替，具体类型会在实例化或调用时确定。

#### 为什么使用泛型？

1. **类型安全**：避免类型强制转换带来的运行时错误。
2. **代码复用**：相同的代码逻辑可以支持不同的数据类型。

---

### **1.2 泛型类**

#### 定义泛型类

使用尖括号 `<T>` 定义泛型类，其中 `T` 是类型参数。

```kotlin
class Box<T>(val value: T)

fun main() {
    val intBox = Box(123)  // T 推断为 Int
    val stringBox = Box("Hello")  // T 推断为 String
    
    println(intBox.value)  // 输出: 123
    println(stringBox.value)  // 输出: Hello
}
```

#### 关键点：

- **`<T>`** 是泛型类型参数，可以用任意字母或单词表示（如 `<E>`、`<K, V>`）。
- 实例化时，类型参数会被推断或显式指定。

---

### **1.3 泛型函数**
[[泛型函数的类型参数]]
#### 定义泛型函数

泛型函数在函数名前添加类型参数 `<T>`。

```kotlin
fun <T> printItem(item: T) {
    println("Item: $item")
}

fun main() {
    printItem(123)  // 输出: Item: 123
    printItem("Hello")  // 输出: Item: Hello
}
```

#### 泛型函数的应用

- 适合编写与具体类型无关的工具函数。
- 支持类型参数的自动推断。

---

### **1.4 多个类型参数**

泛型支持多个类型参数，使用逗号分隔。

```kotlin
class PairBox<K, V>(val key: K, val value: V)

fun main() {
    val pair = PairBox("name", "Alice")
    println("Key: ${pair.key}, Value: ${pair.value}")
    // 输出: Key: name, Value: Alice
}
```

---

## **2. Kotlin 泛型的高级特性**

### **2.1 类型参数约束**

默认情况下，泛型可以是任何类型。如果需要对泛型类型进行约束，可以使用 **`where` 子句** 或继承关键字。

#### 限制为某种类型及其子类

```kotlin
//toDouble()方法不能直接用于泛型类型`T`。需要确保`T`是一个可以转换为 `Double` 的类型。
fun <T : Number> sum(a: T, b: T): Double {
    return a.toDouble() + b.toDouble()
}

fun main() {
    println(sum(5, 10))  // 输出: 15.0
    println(sum(3.5, 4.5))  // 输出: 8.0
    // println(sum("Hello", "World"))  // 编译错误
}
```

#### 多约束限制

```kotlin
fun <T> ensureStringLength(value: T) where T : CharSequence, T : Comparable<T> {
    println("Length: ${value.length}")
}

fun main() {
    ensureStringLength("Hello")  // 输出: Length: 5
    // ensureStringLength(123)  // 编译错误
}
```

---

### **2.2 泛型的协变与逆变**

#### 什么是协变与逆变？

- **协变（Covariance）**：子类型可以安全地替换父类型，用 **`out`** 修饰。
- **逆变（Contravariance）**：父类型可以安全地替换子类型，用 **`in`** 修饰。
- **不变（Invariance）**：类型参数既不能是子类型，也不能是父类型。

---

#### 协变（`out`）

用于 **生产者**（只返回类型，不消费类型）。

```kotlin
class Producer<out T>(val value: T)

fun main() {
    val stringProducer: Producer<String> = Producer("Hello")
    val anyProducer: Producer<Any> = stringProducer  // 协变允许
    println(anyProducer.value)  // 输出: Hello
}
```

---

#### 逆变（`in`）

用于 **消费者**（只消费类型，不返回类型）。

```kotlin
class Consumer<in T> {
    fun consume(item: T) {
        println("Consumed: $item")
    }
}

fun main() {
    val stringConsumer: Consumer<String> = Consumer()
    val anyConsumer: Consumer<Any> = stringConsumer  // 逆变允许
    anyConsumer.consume(123)  // 输出: Consumed: 123
}
```

---

#### 不变（默认行为）

不变类型参数既不能协变，也不能逆变。

```kotlin
class Container<T>(val value: T)

fun main() {
    val stringContainer: Container<String> = Container("Hello")
    // val anyContainer: Container<Any> = stringContainer  // 编译错误
}
```

---

### **2.3 星号投影（Star Projection）**

如果不确定泛型的具体类型，可以使用星号 `*` 来代替。

#### 示例：星号投影

```kotlin
fun printList(list: List<*>) {
    for (item in list) {
        println(item)
    }
}

fun main() {
    val stringList: List<String> = listOf("A", "B", "C")
    val intList: List<Int> = listOf(1, 2, 3)
    
    printList(stringList)
    printList(intList)
}
// 输出:
// A
// B
// C
// 1
// 2
// 3
```

---

## **3. Kotlin 类型系统**

### **3.1 类型推断**

Kotlin 拥有强大的类型推断能力，大多数情况下无需显式声明变量的类型。

#### 示例：

```kotlin
val x = 10  // 推断为 Int
val y = "Hello"  // 推断为 String
val z = listOf(1, 2, 3)  // 推断为 List<Int>
```

---

### **3.2 空安全类型（Nullable Types）**

Kotlin 类型系统天然支持 **空安全**，使用 `?` 表示可为空类型，强制开发者在处理空值时进行显式检查。

#### 示例：

```kotlin
var nullableString: String? = "Hello"
println(nullableString?.length)  // 安全调用
nullableString = null
println(nullableString?.length)  // 输出: null
```

---

### **3.3 类型别名**

类型别名使用 `typealias` 定义，简化复杂类型的使用。

#### 示例：

```kotlin
typealias StringMap = Map<String, String>

fun printMap(map: StringMap) {
    map.forEach { (key, value) -> println("$key -> $value") }
}

fun main() {
    val map: StringMap = mapOf("Name" to "Alice", "Age" to "25")
    printMap(map)
}
```

---

## **4. 泛型和类型系统综合练习**

### **练习题**

1. 定义一个泛型类 `Storage<T>`，可以存储任意类型的值，并实现获取和设置值的功能。
2. 编写一个泛型函数 `compareValues`，接受两个值，并返回它们中较大的值。
3. 使用协变（`out`）定义一个 `Producer` 类，确保子类型可以安全赋值给父类型。
4. 使用逆变（`in`）定义一个 `Consumer` 类，确保父类型可以安全赋值给子类型。
5. 定义一个 `PairBox` 类，支持两个类型参数，并实现一个 `swap` 函数，用于交换这两个值的位置。

完成练习后，可以随时与我讨论答案或遇到的问题！ 😊