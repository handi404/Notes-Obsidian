### **Kotlin 枚举类和密封类详解**

---

在 Kotlin 中，**枚举类**和**密封类**是两种特殊的类，主要用于表示有限个数的可能状态或选项。它们广泛应用于构建类型安全的模型，尤其是在状态管理、事件处理和决策结构中。本节将详细介绍两者的用法和应用场景。

---

## **1. 枚举类（`enum class`）**

### **1.1 什么是枚举类？**

枚举类用于表示一个固定集合的常量值。例如，季节（春夏秋冬）、方向（东南西北）或状态（成功、失败、进行中）等。

#### 定义枚举类

使用 `enum class` 关键字定义枚举类。

```kotlin
enum class Direction {
    NORTH, SOUTH, EAST, WEST
}

fun main() {
    val direction = Direction.NORTH
    println("Direction: $direction")
}
```

#### 输出：

```
Direction: NORTH
```

---

### **1.2 枚举类的特点**

1. **固定值集合**：枚举类的值在编译时已经固定，不可更改。
2. **类型安全**：==每个枚举值都是枚举类的实例==，不可与其他类型混用。
3. **自动实现了 `toString`、`ordinal` 和 `name` 属性**。

---

### **1.3 枚举类的属性和方法**

#### 属性：

- **`name`**：返回枚举常量的名称。
- **`ordinal`**：返回枚举常量的索引（从 0 开始）。

#### 方法：

- **`values()`**：返回所有枚举常量的数组。
- **`valueOf(name: String)`**：根据名称返回对应的枚举常量。

#### 示例：

```kotlin
enum class Direction {
    NORTH, SOUTH, EAST, WEST
}

fun main() {
    val direction = Direction.EAST
    println("Name: ${direction.name}")  // 输出: Name: EAST
    println("Ordinal: ${direction.ordinal}")  // 输出: Ordinal: 2

    // 遍历所有枚举值
    for (dir in Direction.values()) {
        println(dir)
    }

    // 根据名称获取枚举值
    val south = Direction.valueOf("SOUTH")
    println("Direction from valueOf: $south")
}
```

---

### **1.4 枚举类的自定义构造函数**

枚举类可以有构造函数、属性和方法。构造函数需要为每个枚举常量提供参数。
[[枚举值的属性和枚举类构造函数]]
#### 示例：带构造函数的枚举类

```kotlin
enum class Color(val rgb: String) {
    RED("#FF0000"),
    GREEN("#00FF00"),
    BLUE("#0000FF");

    fun getHexCode(): String {
        return rgb
    }
}

fun main() {
    val color = Color.GREEN
    println("Color: ${color.name}, Hex: ${color.getHexCode()}")
}
```

#### 输出：

```
Color: GREEN, Hex: #00FF00
```

---

### **1.5 枚举类中的抽象方法**

枚举类可以定义抽象方法，每个枚举常量需要实现它。

#### 示例：

```kotlin
enum class Shape {
    CIRCLE {
        override fun area(radius: Double): Double = Math.PI * radius * radius
    },
    SQUARE {
        override fun area(side: Double): Double = side * side
    };

    abstract fun area(size: Double): Double
}

fun main() {
    println("Circle Area: ${Shape.CIRCLE.area(5.0)}")  // 输出: Circle Area: 78.53981633974483
    println("Square Area: ${Shape.SQUARE.area(4.0)}")  // 输出: Square Area: 16.0
}
```

---

## **2. 密封类（`sealed class`）**

### **2.1 什么是密封类？**

密封类用于表示受限的层次结构。它是一个 **抽象类**，可以有固定数量的子类。这些子类只能定义在密封类本身或与其同一个文件中。
[[密封类的子类类型]]
#### 定义密封类

使用 `sealed class` 定义密封类。

```kotlin
sealed class Result

data class Success(val data: String) : Result()
data class Failure(val error: String) : Result()

fun handleResult(result: Result) {
    when (result) {
        is Success -> println("Success: ${result.data}")
        is Failure -> println("Failure: ${result.error}")
    }
}

fun main() {
    val success = Success("Data loaded")
    val failure = Failure("Network error")

    handleResult(success)
    handleResult(failure)
}
```

#### 输出：

```
Success: Data loaded
Failure: Network error
```

---

### **2.2 密封类的特点**

1. **受限层次结构**：密封类的所有子类都必须定义在同一个文件中。
2. **用于模式匹配**：通常配合 `when` 表达式使用，且不需要 `else` 分支（如果已经涵盖了所有子类）。
3. **不可实例化**：密封类是抽象的，不能直接创建实例。

---

### **2.3 密封类 vs 枚举类**

| 特性     | 枚举类（Enum）         | 密封类（Sealed Class） |
| ------ | ----------------- | ----------------- |
| 常量值个数  | 固定不变              | 可以通过继承增加子类        |
| 使用场景   | 表示有限的固定值（例如颜色、方向） | 表示状态、事件等具有层次结构的对象 |
| 子类定义位置 | 所有值在类内声明          | 子类可以在类外部同一文件中声明   |
| 支持的类型  | 只能是具体的值           | 可以是数据类、对象、常规类等    |

---

### **2.4 密封类的应用场景**

1. **状态管理**：在应用程序中表示各种状态（如加载中、成功、失败）。
2. **事件处理**：在事件驱动的编程中，封装各种事件类型。
3. **模式匹配**：用于复杂的 `when` 结构。

---

### **2.5 密封接口（`sealed interface`）**

Kotlin 还支持密封接口，允许定义固定的实现层次。

#### 示例：

```kotlin
sealed interface UiState

object Loading : UiState
data class Success(val data: String) : UiState
data class Error(val error: String) : UiState

fun renderUi(state: UiState) {
    when (state) {
        is Loading -> println("Loading...")
        is Success -> println("Data: ${state.data}")
        is Error -> println("Error: ${state.error}")
    }
}

fun main() {
    renderUi(Loading)
    renderUi(Success("User data loaded"))
    renderUi(Error("Failed to fetch data"))
}
```

---

## **3. 枚举类和密封类的综合应用**

以下示例展示了如何结合枚举类和密封类来管理应用状态：

#### 示例：

```kotlin
sealed class ApiResponse

data class Success(val data: String) : ApiResponse()
data class Failure(val error: String) : ApiResponse()
object Loading : ApiResponse()

enum class Status {
    LOADING, SUCCESS, FAILURE
}

fun getApiResponse(status: Status): ApiResponse {
    return when (status) {
        Status.LOADING -> Loading
        Status.SUCCESS -> Success("Data fetched successfully")
        Status.FAILURE -> Failure("Failed to fetch data")
    }
}

fun main() {
    val response = getApiResponse(Status.SUCCESS)
    when (response) {
        is Loading -> println("Loading...")
        is Success -> println("Success: ${response.data}")
        is Failure -> println("Failure: ${response.error}")
    }
}
```

---

## **4. 练习题**

1. 定义一个枚举类 `Season`，包含四个值：春、夏、秋、冬。为每个值添加一个描述属性，并实现一个返回描述的函数。
2. 定义一个密封类 `Shape`，子类包括 `Circle`（圆形）和 `Rectangle`（矩形），实现一个函数计算不同形状的面积。
3. 定义一个枚举类表示交通信号灯的颜色（红、黄、绿），并编写一个函数输出每种颜色对应的行为（如停止、减速、通行）。
4. 定义一个密封类 `NetworkState`，包含 `Loading`、`Success` 和 `Error` 子类，用于表示网络请求的状态，并实现一个函数处理这些状态。

完成练习后可以随时与我讨论答案或问题！ 😊