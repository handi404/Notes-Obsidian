在 exception 包中定义
例如：未找到和无效请求
```kotlin
@ResponseStatus(HttpStatus.NOT_FOUND)
data class TaskNotFoundException(override val message: String): RuntimeException()
```

```kotlin
@ResponseStatus(HttpStatus.BAD_REQUEST)
data class BadRequestException(override val message: String) : RuntimeException()
```

---

如何在 Kotlin 中自定义 **运行时异常（RuntimeException）**。自定义运行时异常的目的是在程序运行时遇到特定的错误时，抛出一个明确的异常类型，这样可以帮助我们更精确地控制程序的错误处理。

下面我将详细讲解如何在 Kotlin 中自定义运行时异常，并展示如何在 Spring Boot 中使用这些自定义异常。

---

### **1. 自定义运行时异常（RuntimeException）**

Kotlin 中定义一个自定义的运行时异常非常简单。你只需要继承 `RuntimeException` 类，然后根据需要为异常添加构造函数、字段等。

#### **1.1 自定义 `ResourceNotFoundException`（资源未找到异常）**

```kotlin
// 自定义异常类：资源未找到
class ResourceNotFoundException(message: String) : RuntimeException(message)
```

- `ResourceNotFoundException` 继承自 `RuntimeException`，并通过构造函数接收错误消息。
- `RuntimeException` 是一个 **运行时异常**（unchecked exception），在程序运行时可能发生的错误。
- 我们可以将 `message` 传递给 `RuntimeException` 构造函数，以便提供错误的详细信息。

#### **1.2 自定义 `BadRequestException`（无效请求异常）**

```kotlin
// 自定义异常类：无效请求
class BadRequestException(message: String) : RuntimeException(message)
```

- `BadRequestException` 同样继承自 `RuntimeException`，用于表示无效请求的错误，如参数无效或格式错误等。

#### **1.3 其他自定义异常**

你可以根据具体的需求创建更多的自定义异常，例如：

- `UnauthorizedAccessException`：表示未授权访问的异常。
- `InternalServerErrorException`：表示服务器内部错误的异常。

```kotlin
class UnauthorizedAccessException(message: String) : RuntimeException(message)
class InternalServerErrorException(message: String) : RuntimeException(message)
```

---

### **2. 在 Spring Boot 中使用自定义运行时异常**

在 Spring Boot 中，使用 `@ControllerAdvice` 和 `@ExceptionHandler` 进行统一的异常处理。通过捕获自定义的运行时异常并返回合适的 HTTP 状态码和错误信息，提升用户体验。

#### **2.1 创建 `@ControllerAdvice` 类**

`@ControllerAdvice` 用于处理所有控制器中抛出的异常。我们可以在这里捕获所有的自定义异常，并根据不同的异常类型返回对应的 HTTP 状态码和响应信息。

```kotlin
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler

@ControllerAdvice
class GlobalExceptionHandler {

    // 处理 ResourceNotFoundException
    @ExceptionHandler(ResourceNotFoundException::class)
    fun handleResourceNotFoundException(ex: ResourceNotFoundException): ResponseEntity<String> {
        return ResponseEntity("Resource not found: ${ex.message}", HttpStatus.NOT_FOUND)
    }

    // 处理 BadRequestException
    @ExceptionHandler(BadRequestException::class)
    fun handleBadRequestException(ex: BadRequestException): ResponseEntity<String> {
        return ResponseEntity("Bad request: ${ex.message}", HttpStatus.BAD_REQUEST)
    }

    // 处理其他所有异常
    @ExceptionHandler(Exception::class)
    fun handleGenericException(ex: Exception): ResponseEntity<String> {
        return ResponseEntity("Internal server error: ${ex.message}", HttpStatus.INTERNAL_SERVER_ERROR)
    }
}
```

- **`@ExceptionHandler`**：该注解标记的方法会捕获指定类型的异常，并返回合适的响应。
- **`ResponseEntity`**：Spring Boot 用于构造完整的 HTTP 响应，包括状态码和内容。
- `HttpStatus.NOT_FOUND`：返回 HTTP 状态码 404。
- `HttpStatus.BAD_REQUEST`：返回 HTTP 状态码 400。
- `HttpStatus.INTERNAL_SERVER_ERROR`：返回 HTTP 状态码 500。

---

#### **2.2 在控制器中抛出自定义异常**

在控制器中，你可以根据业务逻辑抛出自定义的异常。Spring Boot 会自动捕获这些异常并交给 `GlobalExceptionHandler` 类中的相应方法处理。

```kotlin
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
class UserController {

    private val users = listOf(
        User(1, "Alice"),
        User(2, "Bob")
    )

    // 查询用户
    @GetMapping("/users/{id}")
    fun getUser(@PathVariable id: Int): User {
        val user = users.find { it.id == id }
            ?: throw ResourceNotFoundException("User with id $id not found") // 抛出资源未找到异常
        return user
    }

    // 创建用户
    @GetMapping("/users/create")
    fun createUser(@RequestParam name: String): User {
        if (name.isBlank()) {
            throw BadRequestException("Name cannot be empty") // 抛出无效请求异常
        }
        val newUser = User(users.size + 1, name)
        return newUser
    }
}
```

在这个控制器中：

- `getUser` 方法查找 `id` 对应的用户，如果找不到则抛出 `ResourceNotFoundException`。
- `createUser` 方法检查 `name` 是否为空，如果为空则抛出 `BadRequestException`。

---
---

在 Spring Boot 项目中，合理的包结构能够帮助你更好地组织代码，提升项目的可维护性和可扩展性。对于自定义异常类和全局异常处理类的位置，通常遵循以下的包结构约定：

### **推荐的包结构**

```
com.example.demo
│
├── controller           # 控制器（处理 HTTP 请求）
│   └── UserController.kt
│
├── exception            # 异常类
│   ├── ResourceNotFoundException.kt
│   └── BadRequestException.kt
│
├── handler              # 异常处理器（集中处理所有异常）
│   └── GlobalExceptionHandler.kt
│
├── model                # 数据模型或实体类
│   └── User.kt
│
├── repository           # 数据库访问层（JPA 仓库）
│   └── UserRepository.kt
│
├── service              # 业务逻辑层
│   └── UserService.kt
│
└── Application.kt       # 启动类
```

### **1. 自定义异常类的位置（`exception` 包）**

将自定义的异常类放在一个单独的 `exception` 包中，有助于清晰地组织代码，并且易于管理所有与异常相关的类。

#### **例子**：自定义的异常类

```kotlin
// exception/ResourceNotFoundException.kt
package com.example.demo.exception

class ResourceNotFoundException(message: String) : RuntimeException(message)
```

```kotlin
// exception/BadRequestException.kt
package com.example.demo.exception

class BadRequestException(message: String) : RuntimeException(message)
```

### **2. 异常处理器的位置（`handler` 包）**

将异常处理器类放在一个单独的 `handler` 包中，它专门负责捕获和处理应用中抛出的异常。

#### **例子**：全局异常处理器

```kotlin
// handler/GlobalExceptionHandler.kt
package com.example.demo.handler

import com.example.demo.exception.ResourceNotFoundException
import com.example.demo.exception.BadRequestException
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler

@ControllerAdvice
class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException::class)
    fun handleResourceNotFoundException(ex: ResourceNotFoundException): ResponseEntity<String> {
        return ResponseEntity("Resource not found: ${ex.message}", HttpStatus.NOT_FOUND)
    }

    @ExceptionHandler(BadRequestException::class)
    fun handleBadRequestException(ex: BadRequestException): ResponseEntity<String> {
        return ResponseEntity("Bad request: ${ex.message}", HttpStatus.BAD_REQUEST)
    }

    @ExceptionHandler(Exception::class)
    fun handleGenericException(ex: Exception): ResponseEntity<String> {
        return ResponseEntity("Internal server error: ${ex.message}", HttpStatus.INTERNAL_SERVER_ERROR)
    }
}
```

### **3. 控制器的位置（`controller` 包）**

控制器处理具体的 HTTP 请求，调用服务层并返回响应。通常将控制器类放在 `controller` 包中。

#### **例子**：控制器

```kotlin
// controller/UserController.kt
package com.example.demo.controller

import com.example.demo.exception.ResourceNotFoundException
import com.example.demo.exception.BadRequestException
import com.example.demo.model.User
import com.example.demo.service.UserService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
class UserController(private val userService: UserService) {

    @GetMapping("/users/{id}")
    fun getUser(@PathVariable id: Int): User {
        return userService.getUserById(id) ?: throw ResourceNotFoundException("User with id $id not found")
    }

    @GetMapping("/users/create")
    fun createUser(@RequestParam name: String): User {
        if (name.isBlank()) {
            throw BadRequestException("Name cannot be empty")
        }
        return userService.createUser(name)
    }
}
```

### **4. 启动类的位置（`Application.kt`）**

Spring Boot 的启动类通常位于根包下，作为应用程序的入口。

```kotlin
// Application.kt
package com.example.demo

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class Application

fun main(args: Array<String>) {
    runApplication<Application>(*args)
}
```

### **总结**

- **`exception` 包**：用来存放所有自定义的异常类，例如 `ResourceNotFoundException` 和 `BadRequestException`。
- **`handler` 包**：用来存放异常处理器类（`@ControllerAdvice`），负责捕获和处理应用中抛出的自定义异常。
- **`controller` 包**：用来存放处理 HTTP 请求的控制器类。
- **`Application.kt`**：通常放在根包，用作应用的入口。

这种包结构有助于使你的 Spring Boot 项目更加清晰、可维护，异常相关的代码集中管理，易于扩展和修改。
