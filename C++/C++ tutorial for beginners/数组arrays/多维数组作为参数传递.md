## C++ 中多维数组作为参数传递

### 概述

在 C++ 中，多维数组作为函数参数传递时，存在一些特殊情况和需要注意的点。这是因为数组名在传递时，实际上传递的是数组首元素的地址。

### 常见传递方式及问题

#### 1. 直接传递数组名

```C++
void func(int arr[3][4]) {
    // ...
}
```

- **问题:** 编译器会将 `arr[3][4]` 解释为 `int(*arr)[4]`，即指向包含 4 个整数的数组的指针。因此，编译器只知道第二维的大小，而第一维的大小必须在函数调用时由实参确定。
- **限制:** 函数内部无法确定数组的总行数，这可能会导致数组越界访问。

#### 2. 传递数组的维度信息

```C++
void func(int arr[][4], int rows) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < 4; ++j) {
            // ...
        }
    }
}
```

- **优点:** 通过传入 `rows` 参数，函数可以明确知道数组的行数，避免了数组越界。
- **缺点:** 仍需要事先知道第二维的大小。

#### 3. 传递指向数组的指针

```C++
void func(int (*arr)[4], int rows) {
    // ...
}
```

- **优点:** 与方法 2 相似，但更明确地表示了 `arr` 是一个指向包含 4 个整数的数组的指针。
- **缺点:** 仍需要事先知道第二维的大小。

### 推荐做法：使用模板

```C++
template <size_t M, size_t N>
void func(int (&arr)[M][N]) {
    // ...
}
```

- **优点:**
    - **类型安全:** 编译器可以在编译时检查数组的维度是否匹配。
    - **灵活:** 可以处理任意大小的二维数组。
    - **避免了维度信息丢失的问题。**

### 示例

```C++
#include <iostream>

template <size_t M, size_t N>
void printArray(int (&arr)[M][N]) {
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            std::cout << arr[i][j] << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    int arr[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
    printArray(arr);
    return 0;
}
```

### 总结

- **多维数组传递时，本质上是传递指针。**
- **为了保证类型安全和灵活度，推荐使用模板。**
- **如果无法使用模板，可以传递数组的维度信息，但要注意第二维的大小必须提前确定。**

### 注意事项

- **数组的衰减:** 数组名在很多情况下会衰减为指向其首元素的指针。
- **指针的算术运算:** 可以使用指针的算术运算来访问数组元素，但要注意数组越界。
- **C++11 及以后的标准引入了 `std::array`，它是一个模板类，可以更安全地表示固定大小的数组。**