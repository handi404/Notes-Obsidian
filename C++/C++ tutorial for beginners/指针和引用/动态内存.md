
```cpp
#include <iostream>

int main () {

    char *pGrades = NULL;
    int size;

    std::cout << "How many grades to enter in?: ";
    std::cin >> size;

    pGrades = new char[size];

    for(int i = 0; i < size; i++){
        std::cout << "Enter grade #" << i + 1 << ": ";
        std::cin >> pGrades[i];
    }

    for(int i = 0; i < size; i++){
        std::cout << pGrades[i] << " ";
    }

    delete[] pGrades;

    return 0;
}
```

## C++ 动态内存

C++中的动态内存是指在程序运行时根据需要分配和释放内存的过程。 这与静态内存分配不同，后者是指在编译时为变量分配固定量的内存。

动态内存分配通常用于以下情况：

- 当需要分配的数据量在程序运行时才能确定时
- 当需要分配的数据量很大时
- 当需要在多个函数之间共享数据时

### 动态内存分配的实现

C++中提供了 `new` 和 `delete` 运算符来进行动态内存分配。

- `new` 运算符用于分配内存并返回指向分配内存的指针。
- `delete` 运算符用于释放由 `new` 运算符分配的内存。

例如，以下代码分配了一个 `int` 类型的变量并将其值设置为 10：

```C++
int *p = new int;
*p = 10;
```

该代码首先使用 `new` 运算符分配了一个 `int` 类型的变量。 `new` 运算符返回指向分配内存的指针，该指针存储在变量 `p` 中。 然后，使用 `*` 运算符对指向的内存进行解引用，并将其值设置为 10。

以下代码释放了由 `new` 运算符分配的内存：

```C++
delete p;
```

如果不释放动态分配的内存，则会导致内存泄漏。 内存泄漏是指程序不再使用的内存没有被释放，这会导致内存使用量随着时间的推移而增加。

### 动态内存分配的最佳实践

以下是一些有关动态内存分配的最佳实践：

- 始终在不再需要时释放动态分配的内存。
- 使用智能指针来自动释放内存。 智能指针是一种 C++ 类，它可以自动释放指向的内存。
- 避免在循环中分配和释放内存。 在循环中分配和释放内存会导致内存碎片化，这会降低内存分配器的效率。

### C++ 中的动态内存分配的其他功能

C++ 还提供了其他一些用于动态内存分配的功能，例如：

- `malloc` 和 `free` 函数：这些函数与 `new` 和 `delete` 运算符类似，但它们是 C 语言中的函数，而不是 C++ 语言中的运算符。
- `realloc` 函数：此函数用于重新分配先前由 `new` 或 `malloc` 分配的内存。
- `nothrow` 关键字：此关键字可用于指示 `new` 运算符在失败时不引发异常。