
```cpp
#include <iostream>
int factorial(int num);
int main () {

    std::cout << factorial(10);

    return 0;
}
int factorial(int num){
    if(num > 1){
        return num * factorial(num - 1);
    }
    else{
        return 1;
    }
}
```

## C++ 递归是什么？

**递归**（Recursion）是一种编程技巧，即一个函数直接或间接地调用自身。它将一个问题分解为更小的、类似于原问题的子问题，然后递归地解决这些子问题，直到达到一个基本情况（base case），从而得到整个问题的解。

**形象比喻：** 想象一面镜子对着另一面镜子，每面镜子都反射着对面镜子的影像。这就像一个函数不断调用自己，产生无限的嵌套。

## 递归的组成部分：

- **基准情况（Base case）：** 递归的终止条件，当满足这个条件时，函数不再递归调用自己，而是直接返回结果。
- **递归情况（Recursive case）：** 函数调用自身，并将问题分解为更小的子问题。

## 递归的优缺点：

- **优点：**
    - **代码简洁：** 很多复杂问题可以用递归简洁地表达。
    - **思路清晰：** 递归的思路往往与问题的自然解决方式一致。
    - **适用于分治算法：** 许多分治算法（如归并排序、快速排序）都基于递归。
- **缺点：**
    - **效率较低：** 递归调用会消耗大量的栈空间，对于大规模问题可能会导致栈溢出。
    - **不易理解：** 递归的调用过程可能比较复杂，不容易调试。

## 递归的应用场景：

- **数学问题：** 阶乘、斐波那契数列、汉诺塔问题等。
- **数据结构：** 树的遍历、图的深度优先搜索等。
- **算法设计：** 分治算法、回溯算法等。

## C++ 递归示例：

```C++
#include <iostream>

// 计算阶乘
int factorial(int n) {
    if (n == 0) {
        return 1; // 基准情况
    } else {
        return n * factorial(n - 1); // 递归情况
    }
}

int main() {
    int num = 5;
    std::cout << num << "! = " << factorial(num) << std::endl;
    return 0;
}
```

## 递归注意事项：

- **必须有基准情况：** 否则会陷入无限递归，导致栈溢出。
- **递归深度：** 递归深度过深可能导致栈溢出，需要考虑优化。
- **尾递归：** 尾递归是一种特殊的递归形式，编译器可以将其优化为循环，从而提高效率。

## 递归与迭代

- **递归**：将问题分解为更小的子问题，通过函数调用自身来解决。
- **迭代**：使用循环结构，重复执行一段代码，直到满足某个条件。

**选择递归还是迭代**取决于具体的问题和编程风格。一般来说，对于那些问题结构具有自相似性的问题，递归往往能提供更简洁的解决方案；而对于那些问题可以很容易地用循环来描述的问题，迭代可能更适合。

## 总结

递归是一种强大的编程工具，可以使代码更加简洁和优雅。但是，过度使用递归可能会导致性能问题，因此在使用递归时需要仔细考虑。