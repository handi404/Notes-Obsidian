
```cpp
#include <iostream>

template <typename T,typename U>
auto max(T x, U y){
    return (x > y) ? x : y;
}
int main()
{
    std::cout << max(1, 2) << '\n';
    std::cout << max(1.1, 2.2) << '\n';
    std::cout << max(1, 2.1) << '\n';
    std::cout << max('1', '2') << '\n';
 
    return 0;
}
```

## C++ 函数模板  
# 
- [[#什么是函数模板？|什么是函数模板？]]
- [[#函数模板的语法|函数模板的语法]]
- [[#示例：交换两个变量值的函数模板|示例：交换两个变量值的函数模板]]
- [[#函数模板的实例化|函数模板的实例化]]
- [[#函数模板的参数|函数模板的参数]]
- [[#多个模板参数|多个模板参数]]
- [[#非类型模板参数|非类型模板参数]]
- [[#函数模板特化|函数模板特化]]
- [[#函数模板的优点|函数模板的优点]]
- [[#函数模板的缺点|函数模板的缺点]]
- [[#总结|总结]]
- [[#拓展阅读|拓展阅读]]
### 什么是函数模板？

C++ 函数模板是一种泛型编程工具，它允许你编写一个函数，该函数可以适用于多种不同的数据类型。换句话说，你只需要定义一个函数模板，编译器就可以根据你提供的实际参数类型，自动生成多个具体的函数。

**为什么要使用函数模板？**

- **代码复用性高：** 同样的算法逻辑，可以应用于不同的数据类型，减少重复代码。
- **提高代码的可读性：** 通过类型参数，更清晰地表达算法的通用性。
- **增强代码的灵活性：** 可以处理多种数据类型，适应不同的需求。

### 函数模板的语法

```C++
template <typename T>
返回值类型 函数名(参数列表) {
    // 函数体
}
```

```C++
- template <typename T>： 模板关键字，表示这是一个函数模板。T 是一个类型参数，可以代表任意数据类型。
```
- **typename T：** 声明一个类型参数。也可以使用 *class* 关键字。

### 示例：交换两个变量值的函数模板

```C++
template <typename T>
void swap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}
```

这个模板函数可以交换任意类型变量的值，例如：

```C++
int x = 10, y = 20;
double a = 3.14, b = 2.718;
swap(x, y);
swap(a, b);
```

### 函数模板的实例化

当调用一个函数模板时，编译器会根据实参的类型，自动生成一个具体的函数，这个过程称为**实例化**。

### 函数模板的参数

- **类型参数：** 用来表示模板中可以使用的任意类型。
- **非类型参数：** 可以是整型常量表达式，用于控制模板的行为。

### 多个模板参数

函数模板可以有多个模板参数。以下是一个包含两个模板参数的示例：

```cpp
#include <iostream>

// 定义一个函数模板，用于比较两个不同类型的值
template <typename T1, typename T2>
bool areEqual(T1 a, T2 b)
{
    return (a == b);
}

int main()
{
    int i = 10;
    double d = 10.0;
    if (areEqual(i, d))
        std::cout << "i and d are equal." << std::endl;
    else
        std::cout << "i and d are not equal." << std::endl;

    return 0;
}

```


### 非类型模板参数

模板参数不仅可以是类型参数，还可以是非类型参数。非类型参数可以是常量表达式（如整数或指针）。以下是一个包含非类型参数的示例：

```cpp
#include <iostream>

// 定义一个函数模板，使用非类型参数指定数组大小
template <typename T, int size>
void printArray(T (&arr)[size])
{
    for (int i = 0; i < size; ++i)
        std::cout << arr[i] << " ";
    std::cout << std::endl;
}

int main()
{
    int intArray[5] = {1, 2, 3, 4, 5};
    printArray(intArray);

    char charArray[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
    printArray(charArray);

    return 0;
}

```

### 函数模板特化

在某些情况下，你可能希望对特定类型提供不同的实现。这时可以使用模板特化。

```cpp
#include <iostream>

// 定义一个通用的函数模板
template <typename T>
void printValue(T value)
{
    std::cout << "Generic template: " << value << std::endl;
}

// 对 `int` 类型进行特化
template <>
void printValue(int value)
{
    std::cout << "Specialized template for int: " << value << std::endl;
}

int main()
{
    printValue(10);        // 使用特化版本
    printValue(3.14);      // 使用通用版本
    printValue("Hello");   // 使用通用版本

    return 0;
}
```

### 函数模板的优点

- **代码重用：** 减少重复代码的编写。
- **类型安全：** 编译器会检查模板参数的类型是否匹配。
- **提高代码的可读性：** 代码更简洁，易于理解。

### 函数模板的缺点

- **编译时间增加：** 编译器需要为每个实例化的函数生成代码。
- **调试难度增加：** 调试模板代码可能比较复杂。

### 总结

C++ 函数模板是 C++泛型编程的重要组成部分，它大大提高了代码的复用性和灵活性。通过掌握函数模板，可以编写出更加通用、高效的代码。

### 拓展阅读

- **类模板：** 除了函数模板，C++还支持类模板，可以定义具有通用性的类。
- **模板特化：** 对于某些特定的类型，可以为模板提供特殊的实现。
- **模板元编程：** 利用模板机制，在编译期进行计算和类型操作。